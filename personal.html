<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ascend</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #000;
        --wall-background: url('./location/New Wall.jpg');
        background-image: var(--wall-background);
        background-position: center;
        background-size: 100% 100%;
        background-repeat: no-repeat;
        background-attachment: fixed;
        color: #fff;
        overflow: hidden;
      }

      .hidden {
        display: none !important;
      }

      .canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .canvas-container.scrollable {
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
      }

      canvas {
        display: block;
        height: 100%;
        width: auto;
        min-width: 100%;
      }

      .auth-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        padding: 1.5rem;
        backdrop-filter: blur(2px);
        z-index: 10;
      }

      .auth-card {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1rem;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: min(90vw, 360px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      }

      .auth-card h1 {
        font-size: 1.4rem;
        text-align: center;
      }

      .auth-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.95rem;
      }

      .auth-field input {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        padding: 0.65rem 1rem;
        font-size: 1rem;
      }

      .auth-submit {
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1rem;
        background: #7ed957;
        color: #111;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .auth-submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
      }

      .auth-switch {
        font-size: 0.9rem;
        text-align: center;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        justify-content: center;
        align-items: center;
      }

      .auth-switch button {
        background: none;
        border: none;
        color: #7ed957;
        font-weight: 600;
        cursor: pointer;
        text-decoration: underline;
      }

      .auth-error {
        min-height: 1.25rem;
        color: #ff7a7a;
        text-align: center;
        font-size: 0.85rem;
      }

      .app-header {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 5;
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      .header-icon-button {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
        color: #fff;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          border-color 0.2s ease;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        padding: 0;
      }

      .header-icon-button svg {
        width: 20px;
        height: 20px;
        display: block;
      }

      .view-toggle {
        position: relative;
      }

      .view-toggle .view-toggle-icon {
        display: none;
        width: 20px;
        height: 20px;
      }

      .view-toggle .view-toggle-icon svg {
        width: 100%;
        height: 100%;
      }

      .view-toggle[aria-pressed='false'] .view-toggle-icon-grade,
      .view-toggle[aria-pressed='true'] .view-toggle-icon-difficulty {
        display: block;
      }

      .header-icon-button:hover,
      .header-icon-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
        outline: none;
      }

      .view-toggle[aria-pressed='true'] {
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.85), rgba(126, 217, 87, 0.4));
        color: #0f1a08;
        border-color: rgba(126, 217, 87, 0.65);
        box-shadow: 0 10px 24px rgba(126, 217, 87, 0.35);
      }

      .location-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(3px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        z-index: 20;
      }

      .location-modal.hidden {
        display: none !important;
      }

      .progression-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(3px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        z-index: 20;
      }

      .progression-modal.hidden {
        display: none !important;
      }

      .location-modal-content {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1.25rem;
        width: min(720px, 92vw);
        max-height: 90vh;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .progression-modal-content {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1.25rem;
        width: min(540px, 92vw);
        max-height: 90vh;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .location-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .location-modal-title {
        font-size: 1.35rem;
        font-weight: 700;
      }

      .progression-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .progression-modal-title {
        font-size: 1.35rem;
        font-weight: 700;
      }

      .location-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.4rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .location-modal-close:hover,
      .location-modal-close:focus-visible {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .progression-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.4rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .progression-modal-close:hover,
      .progression-modal-close:focus-visible {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .location-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
      }

      .progression-description {
        color: rgba(255, 255, 255, 0.75);
        font-size: 0.95rem;
      }

      .progression-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        overflow-y: auto;
        padding-right: 0.25rem;
      }

      .progression-entry {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border-radius: 0.85rem;
        background: rgba(255, 255, 255, 0.08);
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      }

      .progression-entry:hover {
        background: rgba(255, 255, 255, 0.14);
        transform: translateY(-1px);
      }

      .progression-entry:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.16);
      }

      .progression-entry.is-focused {
        background: rgba(255, 255, 255, 0.18);
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.45);
      }

      .progression-entry-grade {
        font-variant-numeric: tabular-nums;
        font-weight: 600;
        min-width: 3ch;
        text-align: right;
      }

      .progression-entry-name {
        font-size: 1rem;
        font-weight: 600;
      }

      .progression-entry-status {
        font-size: 1.15rem;
        width: 1.5rem;
        text-align: center;
        color: rgba(255, 255, 255, 0.45);
      }

      .progression-entry-status.is-ascended {
        color: #7ed957;
      }

      .progression-empty-message {
        text-align: center;
        color: rgba(255, 255, 255, 0.75);
        font-size: 0.95rem;
        padding: 2rem 0;
      }

      .location-option {
        border: none;
        border-radius: 1rem;
        padding: 0;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        cursor: pointer;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        text-align: left;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .location-option:hover,
      .location-option:focus-visible {
        transform: translateY(-4px);
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.4);
        outline: none;
        background: rgba(255, 255, 255, 0.18);
      }

      .location-option[aria-current='true'] {
        box-shadow: 0 0 0 3px rgba(126, 217, 87, 0.75);
        background: rgba(126, 217, 87, 0.18);
      }

      .location-option-preview {
        position: relative;
        width: 100%;
        padding-top: 66%;
        background-size: cover;
        background-position: center;
      }

      .location-option-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.9rem 1rem;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      .location-option-name {
        flex: 1;
      }

      .info-wrapper {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 6;
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
      }

      .info-button {
        width: 40px;
        height: 40px;
        border: 2px solid rgba(255, 255, 255, 0.35);
        background: linear-gradient(135deg, rgba(36, 36, 36, 0.9), rgba(92, 92, 92, 0.45));
        color: #f8fafc;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease,
          background 0.2s ease, color 0.2s ease;
      }

      .info-button.is-active {
        border-color: rgba(126, 217, 87, 0.65);
        background: #7ed957;
        color: #0c1905;
        box-shadow: 0 8px 22px rgba(126, 217, 87, 0.35);
      }

      .info-button:hover,
      .info-button:focus-visible {
        transform: translateY(-2px);
      }

      .info-button:not(.is-active):hover,
      .info-button:not(.is-active):focus-visible {
        border-color: rgba(255, 255, 255, 0.55);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.5);
        outline: none;
      }

      .info-button.is-active:hover,
      .info-button.is-active:focus-visible {
        box-shadow: 0 12px 28px rgba(126, 217, 87, 0.45);
        border-color: rgba(126, 217, 87, 0.9);
        outline: none;
      }

      .info-button.is-active:focus-visible {
        box-shadow: 0 0 0 4px rgba(126, 217, 87, 0.25), 0 12px 28px rgba(126, 217, 87, 0.45);
      }

      .tutorial-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
        background: transparent;
        z-index: 40;
      }

      .tutorial-overlay.is-bottom-aligned {
        align-items: flex-end;
      }

      .tutorial-card {
        width: min(420px, 92vw);
        background: rgba(8, 15, 10, 0.95);
        border-radius: 1.25rem;
        padding: 1.75rem;
        box-shadow: 0 28px 70px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .tutorial-progress {
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.55);
      }

      .tutorial-title {
        font-size: 1.5rem;
        font-weight: 700;
        letter-spacing: 0.02em;
      }

      .tutorial-description {
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        font-size: 0.95rem;
        line-height: 1.5;
        color: rgba(255, 255, 255, 0.85);
      }

      .tutorial-description p {
        margin: 0;
      }

      .tutorial-actions {
        margin-top: 0.5rem;
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .tutorial-button {
        flex: 1;
        border-radius: 999px;
        padding: 0.75rem 1rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        border: none;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .tutorial-primary {
        background: #7ed957;
        color: #081507;
        box-shadow: 0 16px 34px rgba(126, 217, 87, 0.35);
      }

      .tutorial-primary:hover,
      .tutorial-primary:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 20px 40px rgba(126, 217, 87, 0.45);
        outline: none;
      }

      .tutorial-secondary {
        background: rgba(255, 255, 255, 0.15);
        color: rgba(255, 255, 255, 0.85);
      }

      .tutorial-secondary:hover,
      .tutorial-secondary:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.4);
        outline: none;
      }

      .tutorial-highlight {
        position: relative;
        z-index: 50;
        outline: 3px solid rgba(126, 217, 87, 0.9);
        border-radius: 1rem;
      }

      .tutorial-illuminated {
        animation: tutorial-illuminate 1.2s ease-in-out infinite;
      }

      .tutorial-pointer {
        position: fixed;
        width: 102px;
        height: 162px;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        z-index: 60;
        transform: translate(-50%, 0);
      }

      .tutorial-pointer.hidden {
        display: none;
      }

      .tutorial-pointer svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 10px 18px rgba(0, 0, 0, 0.45));
        animation: tutorial-pointer-bounce 1.05s ease-in-out infinite;
      }

      @media (max-width: 768px) {
        .tutorial-pointer {
          width: 51px;
          height: 81px;
        }
      }

      @keyframes tutorial-pointer-bounce {
        0%,
        100% {
          transform: translateY(4px);
        }
        50% {
          transform: translateY(-6px);
        }
      }

      @keyframes tutorial-illuminate {
        0%,
        100% {
          box-shadow: 0 0 0 6px rgba(126, 217, 87, 0.7), 0 0 28px rgba(126, 217, 87, 0.55);
        }
        50% {
          box-shadow: 0 0 0 10px rgba(255, 140, 66, 0.85), 0 0 42px rgba(255, 140, 66, 0.75);
        }
      }

      .setter-link {
        text-decoration: none;
        color: inherit;
      }

      .setter-link.header-icon-button {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.82), rgba(255, 255, 255, 0.4));
        color: #0c1905;
        border-color: rgba(255, 255, 255, 0.6);
      }

      .walls-button {
        backdrop-filter: blur(6px);
      }

      .sign-out {
        background: linear-gradient(135deg, rgba(255, 116, 116, 0.85), rgba(255, 116, 116, 0.55));
        color: #2d0a0a;
        border-color: rgba(255, 180, 180, 0.65);
      }

      .sign-out:hover,
      .sign-out:focus-visible {
        border-color: rgba(255, 200, 200, 0.85);
        background: linear-gradient(135deg, rgba(255, 116, 116, 0.95), rgba(255, 116, 116, 0.65));
      }

      .info-popover {
        position: absolute;
        top: calc(100% + 0.75rem);
        left: 0;
        width: min(280px, 70vw);
        padding: 0.9rem 1rem;
        border-radius: 0.75rem;
        background: rgba(0, 0, 0, 0.85);
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.85rem;
        line-height: 1.4;
        text-align: left;
        pointer-events: auto;
      }

      .info-popover p {
        color: rgba(255, 255, 255, 0.85);
      }

      .info-popover p + p {
        margin-top: 0.5rem;
      }

      .info-highlights {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 40;
      }

      .info-callout {
        --info-callout-bg: rgba(10, 16, 11, 0.94);
        --info-callout-border: rgba(126, 217, 87, 0.55);
        position: absolute;
        min-width: 200px;
        max-width: 260px;
        padding: 0.85rem 1rem;
        border-radius: 0.85rem;
        background: var(--info-callout-bg);
        border: 1px solid var(--info-callout-border);
        color: rgba(255, 255, 255, 0.94);
        box-shadow: 0 18px 42px rgba(0, 0, 0, 0.45);
        transform: translate(-50%, 0);
        pointer-events: none;
        line-height: 1.45;
      }

      .info-callout::before {
        content: '';
        position: absolute;
        width: 0;
        height: 0;
        border: 10px solid transparent;
        left: var(--callout-arrow-offset, 50%);
        transform: translateX(-50%);
      }

      .info-callout[data-arrow='top']::before {
        top: -18px;
        border-bottom-color: var(--info-callout-bg);
      }

      .info-callout[data-arrow='bottom']::before {
        bottom: -18px;
        border-top-color: var(--info-callout-bg);
      }

      .info-callout strong {
        display: block;
        font-weight: 600;
        letter-spacing: 0.01em;
        margin-bottom: 0.35rem;
      }

      .info-callout p {
        font-size: 0.82rem;
        color: rgba(255, 255, 255, 0.88);
      }

      .info-callout p + p {
        margin-top: 0.4rem;
      }

      .info-callout-chart-wrapper {
        margin-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .info-callout-chart {
        display: flex;
        align-items: flex-end;
        gap: 0.18rem;
        height: 52px;
        padding: 0 0.15rem;
      }

      .info-callout-chart-bar {
        flex: 1;
        min-width: 0.15rem;
        border-radius: 0.4rem 0.4rem 0 0;
        background: #2f9e44;
        height: 45%;
        opacity: 0.95;
      }

      .info-callout-chart-bar:first-child {
        border-top-left-radius: 0.45rem;
      }

      .info-callout-chart-bar:last-child {
        border-top-right-radius: 0.45rem;
      }

      .info-callout-chart-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.7rem;
        color: rgba(255, 255, 255, 0.75);
        padding: 0 0.15rem;
        letter-spacing: 0.02em;
      }

      .nav-links {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .nav-links a {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.55));
        color: #0c1905;
        border-color: rgba(255, 255, 255, 0.65);
        box-shadow: 0 10px 22px rgba(255, 255, 255, 0.25);
      }

      .nav-links a:hover,
      .nav-links a:focus-visible {
        box-shadow: 0 14px 28px rgba(255, 255, 255, 0.35);
      }

      .sign-out {
        background: linear-gradient(135deg, rgba(220, 38, 38, 0.85), rgba(153, 27, 27, 0.65));
        border-color: rgba(248, 113, 113, 0.75);
      }

      .route-tooltip {
        --tooltip-accent: #7ed957;
        --tooltip-accent-rgb: 126, 217, 87;
        --tooltip-accent-soft: rgba(126, 217, 87, 0.18);
        --tooltip-accent-strong: rgba(126, 217, 87, 0.85);
        --tooltip-on-accent: #000;
        --tooltip-foreground: #fff;
        --tooltip-soft-foreground: #000;
        --tooltip-muted-foreground: #d1d5db;
        --tooltip-surface: #0e150f;
        --tooltip-border-color: #7ed957;
        --tooltip-grade-size: 7.5rem;
        position: fixed;
        pointer-events: none;
        color: var(--tooltip-foreground, #fff);
        padding: 0.75rem 1rem;
        padding-right: calc(1rem + var(--tooltip-grade-size, 7.5rem) * 0.7);
        border-radius: 0.75rem;
        font-size: 0.85rem;
        line-height: 1.4;
        max-width: min(280px, 80vw);
        height: 80vh;
        max-height: 80vh;
        z-index: 6;
        opacity: 0;
        transform: translate(-50%, -12px);
        transition: opacity 0.12s ease, transform 0.12s ease;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        overflow: visible;
        background-color: var(--tooltip-surface, #0e150f);
        background: var(--tooltip-surface, #0e150f);
        border: 1px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.45);
      }

      .route-tooltip .tooltip-content {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        flex: 1;
        min-height: 0;
        overflow-y: auto;
        padding-right: 0.25rem;
        padding-bottom: 0.25rem;
      }

      .route-tooltip.pinned {
        pointer-events: auto;
      }

      .route-tooltip.visible {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      .route-tooltip .tooltip-header {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 0.5rem;
        margin-bottom: 0.35rem;
      }

      .route-tooltip .tooltip-title {
        display: block;
        font-size: 0.95rem;
        font-weight: 600;
      }

      .route-tooltip .tooltip-lines {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        white-space: pre-line;
      }

      .route-tooltip .tooltip-line {
        display: block;
      }

      .route-tooltip .tooltip-tips {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-top: 0.25rem;
      }

      .route-tooltip .tooltip-tips-title {
        font-size: 0.9rem;
        font-weight: 600;
      }

      .route-tooltip .tooltip-tips-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .route-tooltip .tooltip-tip-entry {
        white-space: pre-line;
        background: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.12);
        border-radius: 0.65rem;
        padding: 0.6rem 0.75rem;
        border: 1px solid rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.25);
        line-height: 1.4;
      }

      .route-tooltip .tooltip-tip-empty {
        color: rgba(255, 255, 255, 0.65);
        font-size: 0.85rem;
      }

      .route-tooltip .tooltip-tip-form {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .route-tooltip .tooltip-tip-input {
        width: 100%;
        border-radius: 0.75rem;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(0, 0, 0, 0.35);
        color: inherit;
        padding: 0.75rem;
        font-size: 0.9rem;
        resize: vertical;
        min-height: 4.5rem;
        max-height: 12rem;
      }

      .route-tooltip .tooltip-tip-input:focus-visible {
        outline: 2px solid var(--tooltip-accent, #7ed957);
        outline-offset: 2px;
      }

      .route-tooltip .tooltip-tip-submit {
        align-self: flex-start;
        border-radius: 999px;
        border: 2px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
        padding: 0.5rem 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          border-color 0.2s ease;
      }

      .route-tooltip .tooltip-tip-submit:hover,
      .route-tooltip .tooltip-tip-submit:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 10px 18px rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.25);
        outline: none;
      }

      .route-tooltip .tooltip-tip-submit:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      .route-tooltip .tooltip-tip-status {
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.7);
      }

      .route-tooltip .tooltip-tip-status.is-error {
        color: #ff9f9f;
      }

      .route-tooltip .tooltip-grade-cluster {
        position: absolute;
        top: 0;
        right: 0;
        transform: translate(50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.55rem;
        min-width: var(--tooltip-grade-size, 7.5rem);
        z-index: 1;
      }

      .route-tooltip .tooltip-grade-badge {
        width: var(--tooltip-grade-size, 7.5rem);
        height: var(--tooltip-grade-size, 7.5rem);
        border-radius: 50%;
        border: var(--tooltip-grade-stroke-width, 2px) solid var(--tooltip-accent, #7ed957);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: calc(var(--tooltip-grade-size, 7.5rem) * 0.32);
        line-height: 1;
        color: var(--tooltip-on-accent, #000);
        background: rgb(var(--tooltip-accent-rgb, 126, 217, 87));
        pointer-events: none;
        overflow: hidden;
      }

      .route-tooltip .tooltip-actions {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        margin-top: 0.5rem;
        width: 100%;
        pointer-events: auto;
      }

      .route-tooltip .tooltip-action-button {
        width: 100%;
        border-radius: 999px;
        padding: 0.6rem 0.9rem;
        font-size: 0.82rem;
        font-weight: 600;
        border: 2px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
        text-align: center;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease,
          color 0.15s ease, border-color 0.15s ease;
      }

      .route-tooltip .tooltip-action-button:hover,
      .route-tooltip .tooltip-action-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        outline: none;
      }

      .route-tooltip .tooltip-action-button.is-quiet {
        background: var(--tooltip-surface, #0e150f);
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-action-button.is-quiet:hover,
      .route-tooltip .tooltip-action-button.is-quiet:focus-visible {
        border-color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .tooltip-action-button[aria-pressed='true'] {
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      }

      .route-tooltip .ascend-toggle[aria-pressed='true'] {
        background: var(--tooltip-on-accent, #000);
        color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .focus-toggle {
        text-align: center;
      }

      .route-tooltip .focus-toggle[aria-pressed='true'] {
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
      }

      .route-tooltip .tooltip-grade-value {
        position: relative;
        z-index: 1;
      }

      .route-tooltip .tooltip-grade-badge.ascended {
        box-shadow: 0 0 0 0.35rem rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
      }

      .grade-section {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        margin-top: 0.75rem;
      }

      .grade-form {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .grade-form label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.8rem;
        font-weight: 600;
      }

      .grade-input-row {
        display: flex;
        gap: 0.5rem;
        align-items: stretch;
      }

      .grade-input-row label {
        flex: 1;
      }

      .grade-input-row input[type='number'] {
        flex: 1;
      }

      .grade-form input[type='number'] {
        border-radius: 0.65rem;
        border: 1px solid #fff;
        background: #fff;
        color: #111;
        padding: 0.45rem 0.6rem;
        font-size: 0.85rem;
      }

      .grade-form input[type='number']:disabled {
        cursor: not-allowed;
      }

      .grade-note {
        font-size: 0.75rem;
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-close-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.15rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: rgba(0, 0, 0, 0.25);
        color: var(--tooltip-foreground, #fff);
        font-size: 1rem;
        line-height: 1;
        min-width: 0;
        transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease,
          box-shadow 0.2s ease;
      }

      .route-tooltip .tooltip-close-button:hover,
      .route-tooltip .tooltip-close-button:focus-visible {
        border-color: rgba(255, 255, 255, 0.6);
        background: rgba(255, 255, 255, 0.2);
        color: #0b0f03;
        box-shadow: 0 0 0 0.15rem rgba(255, 255, 255, 0.2);
      }

      .route-tooltip .tooltip-close-button svg {
        width: 1em;
        height: 1em;
        display: block;
      }

    </style>
  </head>
  <body>
    <div id="authOverlay" class="auth-overlay" role="dialog" aria-modal="true" aria-labelledby="authTitle">
      <form id="authForm" class="auth-card">
        <h1 id="authTitle">Sign in to continue</h1>
        <label class="auth-field">
          <span>Username</span>
          <input id="authUsername" type="text" name="username" autocomplete="username" required />
        </label>
        <label class="auth-field">
          <span>Password</span>
          <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="6" required />
        </label>
        <p id="authError" class="auth-error" role="alert" aria-live="assertive"></p>
        <button type="submit" class="auth-submit">Sign In</button>
        <p class="auth-switch">
          <span id="authSwitchLabel">Don't have an account?</span>
          <button type="button" id="toggleAuthMode">Create one</button>
        </p>
      </form>
    </div>
    <div id="appContent" class="app hidden" aria-live="polite">
      <div class="info-wrapper">
        <button
          id="infoButton"
          class="header-icon-button info-button"
          type="button"
          aria-label="Learn about Ascend"
          aria-haspopup="dialog"
          aria-pressed="false"
          aria-expanded="false"
          aria-controls="infoPopover"
          title="Learn about Ascend"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2" />
            <rect x="11" y="10" width="2" height="7" rx="1" />
            <circle cx="12" cy="7" r="1.5" />
          </svg>
        </button>
        <div
          id="infoPopover"
          class="info-popover hidden"
          role="dialog"
          aria-modal="false"
          aria-hidden="true"
          aria-label="About Ascend"
          tabindex="-1"
        >
          <p>Tap a header button to learn what it does.</p>
          <p>The next button you press will open its tooltip and close this message.</p>
        </div>
      </div>
      <header class="app-header">
        <button
          id="viewToggle"
          class="header-icon-button view-toggle"
          type="button"
          aria-pressed="false"
          aria-label="Show Grade Colors"
          title="Show Grade Colors"
        >
          <span class="view-toggle-icon view-toggle-icon-grade" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
              <path
                d="M6 19a3 3 0 0 1 0-6h12a2 2 0 0 0 0-4H8a4 4 0 0 1 0-8h10v2H8a2 2 0 0 0 0 4h10a4 4 0 0 1 0 8H6a1 1 0 0 0 0 2h12v2H6a3 3 0 0 1-3-3Z"
                fill="currentColor"
              />
            </svg>
          </span>
          <span class="view-toggle-icon view-toggle-icon-difficulty" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
              <rect x="5" y="13.5" width="3.5" height="6" rx="1.75" fill="#2f9e44" />
              <rect x="10.25" y="9.5" width="3.5" height="10" rx="1.75" fill="#facc15" />
              <rect x="15.5" y="5" width="3.5" height="14.5" rx="1.75" fill="#ef4444" />
              <rect x="4" y="20" width="16" height="1.5" rx="0.75" fill="#ffffff" fill-opacity="0.55" />
            </svg>
          </span>
        </button>
        <button
          id="progressionButton"
          class="header-icon-button progression-button"
          type="button"
          aria-haspopup="dialog"
          aria-expanded="false"
          aria-label="View progression"
          title="View progression"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M4 4a1 1 0 0 1 1-1h1.5a1 1 0 0 1 0 2H6v14h15v2H5a1 1 0 0 1-1-1V4Z" fill="currentColor" />
            <path
              d="m10.2 12.8 2.3 2.3 5.2-5.2a1 1 0 0 1 1.4 1.4l-5.9 5.9a1 1 0 0 1-1.4 0l-3-3a1 1 0 0 1 1.4-1.4Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <a
          id="setterLink"
          class="header-icon-button setter-link hidden"
          href="setter.html"
          aria-label="Open setter tools"
          title="Open setter tools"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M10.5 4.5a3 3 0 0 1 3.87 2.88l3.13 3.12-2.12 2.13-3.13-3.13a3 3 0 1 1-4.75-3.44l2.12 2.12 1.41-1.41Z"
              fill="currentColor"
            />
            <path
              d="M6.34 14.34 9.66 17.66a2 2 0 0 1 0 2.83l-.83.83a2 2 0 0 1-2.83 0L2.68 17.2a1 1 0 0 1 0-1.41l2.25-2.25a1 1 0 0 1 1.41 0Z"
              fill="currentColor"
            />
          </svg>
        </a>
        <button
          id="locationButton"
          class="header-icon-button walls-button"
          type="button"
          aria-haspopup="dialog"
          aria-label="Select wall"
          title="Select wall"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M12 2a7 7 0 0 1 7 7c0 4.42-4.56 9.52-6.38 11.34a0.88 0.88 0 0 1-1.24 0C9.56 18.52 5 13.42 5 9a7 7 0 0 1 7-7Zm0 4a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <button
          id="signOutButton"
          class="header-icon-button sign-out"
          type="button"
          aria-label="Sign out"
          title="Sign out"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M13 4a1 1 0 0 1 1-1h6v18h-6a1 1 0 0 1-1-1V4Zm-2.29 4.29 1.42 1.42L9.83 12l2.3 2.29-1.42 1.42L6 12l4.71-3.71Z"
              fill="currentColor"
            />
          </svg>
        </button>
      </header>
      <div class="canvas-container">
        <canvas id="previewCanvas" aria-hidden="true"></canvas>
      </div>
    </div>
    <div
      id="routeTooltip"
      class="route-tooltip"
      role="status"
      aria-live="polite"
      aria-hidden="true"
    ></div>
    <div
      id="progressionModal"
      class="progression-modal hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="progressionModalTitle"
    >
      <div class="progression-modal-content">
        <div class="progression-modal-header">
          <h2 id="progressionModalTitle" class="progression-modal-title">Progression</h2>
          <button
            id="progressionModalClose"
            class="progression-modal-close"
            type="button"
            aria-label="Close progression"
            title="Close progression"
          >
            ×
          </button>
        </div>
        <p class="progression-description">
          Track your climbs at a glance. Routes are sorted by their grade number with ascended climbs
          highlighted.
        </p>
        <div id="progressionList" class="progression-list" role="list"></div>
      </div>
    </div>
    <div
      id="locationModal"
      class="location-modal hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="locationModalTitle"
    >
      <div class="location-modal-content">
        <div class="location-modal-header">
          <h2 id="locationModalTitle" class="location-modal-title">Select a wall</h2>
          <button id="locationModalClose" class="location-modal-close" type="button" aria-label="Close wall selector">
            ×
          </button>
        </div>
        <div id="locationOptions" class="location-options" role="listbox"></div>
      </div>
    </div>
    <div
      id="tutorialOverlay"
      class="tutorial-overlay hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="tutorialTitle"
      aria-describedby="tutorialDescription"
      data-tutorial-exempt="true"
    >
      <div id="tutorialDialogCard" class="tutorial-card" role="document" tabindex="-1">
        <div id="tutorialProgress" class="tutorial-progress hidden" aria-live="polite"></div>
        <h2 id="tutorialTitle" class="tutorial-title"></h2>
        <div id="tutorialDescription" class="tutorial-description"></div>
        <div class="tutorial-actions">
          <button
            id="tutorialSecondaryAction"
            class="tutorial-button tutorial-secondary hidden"
            type="button"
            data-tutorial-exempt="true"
          >
            Back
          </button>
          <button
            id="tutorialPrimaryAction"
            class="tutorial-button tutorial-primary"
            type="button"
            data-tutorial-exempt="true"
          >
            Next
          </button>
        </div>
      </div>
    </div>
    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
        updateProfile,
        deleteUser,
        getIdTokenResult,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        serverTimestamp,
        collection,
        getDocs,
        query,
        limit,
        where,
        addDoc,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
      import { firebaseConfig } from './config.js';

      const firebaseApp = initializeApp(firebaseConfig);
      const auth = getAuth(firebaseApp);

      const db = getFirestore(firebaseApp);

      const authOverlay = document.getElementById('authOverlay');
      const appContent = document.getElementById('appContent');
      const authForm = document.getElementById('authForm');
      const authUsername = document.getElementById('authUsername');
      const authPassword = document.getElementById('authPassword');
      const authError = document.getElementById('authError');
      const authTitle = document.getElementById('authTitle');
      const authSwitchLabel = document.getElementById('authSwitchLabel');
      const toggleAuthModeButton = document.getElementById('toggleAuthMode');
      const signOutButton = document.getElementById('signOutButton');
      const setterLink = document.getElementById('setterLink');
      const setterLinkBaseHref = setterLink?.getAttribute('href') || 'setter.html';
      const tooltip = document.getElementById('routeTooltip');
      const infoButton = document.getElementById('infoButton');
      const infoPopover = document.getElementById('infoPopover');
      const locationButton = document.getElementById('locationButton');
      const viewToggleButton = document.getElementById('viewToggle');
      const progressionButton = document.getElementById('progressionButton');
      const locationModal = document.getElementById('locationModal');
      const locationOptions = document.getElementById('locationOptions');
      const locationModalClose = document.getElementById('locationModalClose');
      const progressionModal = document.getElementById('progressionModal');
      const progressionModalClose = document.getElementById('progressionModalClose');
      const progressionList = document.getElementById('progressionList');
      const tutorialOverlay = document.getElementById('tutorialOverlay');
      const tutorialDialogCard = document.getElementById('tutorialDialogCard');
      const tutorialTitle = document.getElementById('tutorialTitle');
      const tutorialDescription = document.getElementById('tutorialDescription');
      const tutorialPrimaryAction = document.getElementById('tutorialPrimaryAction');
      const tutorialSecondaryAction = document.getElementById('tutorialSecondaryAction');
      const tutorialProgress = document.getElementById('tutorialProgress');

      let infoHighlightsContainer = null;
      let infoModeActive = false;
      let awaitingInfoTargetSelection = false;
      let activeInfoCallout = null;
      let pendingInfoRepositionFrame = null;
      let ephemeralCalloutDismissTimer = null;
      let tutorialPointer = null;
      let tutorialPointerTarget = null;
      let tutorialHighlightedElement = null;
      let tutorialHighlightedElementOptions = { illuminate: false };
      let tutorialPreviousFocus = null;
      let tutorialActive = false;
      let tutorialStepIndex = -1;
      let tutorialTransitionInProgress = false;
      let tutorialSteps = [];
      let tutorialHighlightedRouteId = null;

      const LOCATIONS = [
        { key: 'new-wall', name: 'New Wall', image: './location/New Wall.jpg', hidden: false },
        { key: 'old-wall', name: 'Old Wall', image: './location/Old Wall.jpg', hidden: false },
      ];

      const isLocationVisible = (location) => !!location && location.hidden !== true;

      const getDefaultLocation = () => LOCATIONS.find(isLocationVisible) || null;

      const LOCATION_STORAGE_KEY = 'ascend.selectedWall';
      const WALL_QUERY_PARAM = 'wall';

      async function signOutAndRedirectToIndex() {
        try {
          await signOut(auth);
        } catch (error) {
          console.error('Failed to sign out:', error);
          return false;
        }

        window.location.href = 'index.html';
        return true;
      }

      function ensureInfoHighlightsContainer() {
        if (infoHighlightsContainer && document.body?.contains(infoHighlightsContainer)) {
          return infoHighlightsContainer;
        }

        if (!document.body) {
          return null;
        }

        const container = document.createElement('div');
        container.id = 'infoHighlights';
        container.className = 'info-highlights hidden';
        document.body.appendChild(container);
        infoHighlightsContainer = container;
        return container;
      }

      function clearInfoHighlights() {
        const container = ensureInfoHighlightsContainer();
        if (!container) {
          return;
        }

        if (pendingInfoRepositionFrame) {
          cancelAnimationFrame(pendingInfoRepositionFrame);
          pendingInfoRepositionFrame = null;
        }

        if (ephemeralCalloutDismissTimer) {
          clearTimeout(ephemeralCalloutDismissTimer);
          ephemeralCalloutDismissTimer = null;
        }

        container.innerHTML = '';
        container.classList.add('hidden');
        activeInfoCallout = null;
      }

      function createBasicCallout(title, lines = []) {
        const callout = document.createElement('div');
        callout.className = 'info-callout';

        if (title) {
          const heading = document.createElement('strong');
          heading.textContent = title;
          callout.appendChild(heading);
        }

        lines
          .filter((line) => typeof line === 'string' && line.trim().length)
          .forEach((line) => {
            const paragraph = document.createElement('p');
            paragraph.textContent = line;
            callout.appendChild(paragraph);
          });

        return callout;
      }

      function createGradeChartElement() {
        const wrapper = document.createElement('div');
        wrapper.className = 'info-callout-chart-wrapper';
        wrapper.setAttribute('aria-hidden', 'true');

        const chart = document.createElement('div');
        chart.className = 'info-callout-chart';
        wrapper.appendChild(chart);

        const gradeEntries = Array.from(GRADE_COLOR_MAP.entries());
        const totalGrades = gradeEntries.length;
        const minimumHeight = 22;
        const maximumHeight = 100;
        const heightRange = maximumHeight - minimumHeight;

        gradeEntries.forEach(([grade, color], index) => {
          const bar = document.createElement('span');
          bar.className = 'info-callout-chart-bar';
          const relative = totalGrades > 1 ? index / (totalGrades - 1) : 0;
          const heightPercent = minimumHeight + relative * heightRange;
          bar.style.height = `${heightPercent}%`;
          bar.style.backgroundColor = color;
          bar.dataset.grade = String(grade);
          chart.appendChild(bar);
        });

        if (gradeEntries.length) {
          const labels = document.createElement('div');
          labels.className = 'info-callout-chart-labels';

          const middleIndex = Math.round((gradeEntries.length - 1) / 2);

          const startLabel = document.createElement('span');
          startLabel.textContent = formatGradeDisplay(Number(gradeEntries[0]?.[0] ?? NaN));

          const middleLabel = document.createElement('span');
          middleLabel.textContent = formatGradeDisplay(Number(gradeEntries[middleIndex]?.[0] ?? NaN));

          const endLabel = document.createElement('span');
          endLabel.textContent = formatGradeDisplay(Number(gradeEntries[gradeEntries.length - 1]?.[0] ?? NaN));

          labels.appendChild(startLabel);
          labels.appendChild(middleLabel);
          labels.appendChild(endLabel);

          wrapper.appendChild(labels);
        }

        return wrapper;
      }

      function isElementVisible(element) {
        if (!element) {
          return false;
        }

        if (element.classList?.contains('hidden')) {
          return false;
        }

        const rect = element.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0;
      }

      function setTutorialDescriptionContent(content = []) {
        if (!tutorialDescription) {
          return;
        }

        tutorialDescription.innerHTML = '';

        const fragment = document.createDocumentFragment();
        const items = Array.isArray(content) ? content : [content];

        items.forEach((item) => {
          if (typeof item === 'string') {
            const paragraph = document.createElement('p');
            paragraph.textContent = item;
            fragment.appendChild(paragraph);
            return;
          }

          if (typeof item === 'function') {
            try {
              const result = item();
              if (result instanceof Node) {
                fragment.appendChild(result);
              } else if (typeof result === 'string') {
                const paragraph = document.createElement('p');
                paragraph.textContent = result;
                fragment.appendChild(paragraph);
              }
            } catch (error) {
              console.warn('Unable to render tutorial content item:', error);
            }
            return;
          }

          if (item instanceof Node) {
            fragment.appendChild(item);
          }
        });

        tutorialDescription.appendChild(fragment);
      }

      function ensureTutorialPointer() {
        if (tutorialPointer) {
          return tutorialPointer;
        }

        tutorialPointer = document.createElement('div');
        tutorialPointer.className = 'tutorial-pointer hidden';
        tutorialPointer.setAttribute('aria-hidden', 'true');
        tutorialPointer.innerHTML =
          '<svg viewBox="0 0 64 96" role="presentation" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><path fill="#27b4db" d="M32 0l32 36H44v56H20V36H0z"/></svg>';
        document.body.appendChild(tutorialPointer);

        return tutorialPointer;
      }

      function updateTutorialPointerPosition() {
        if (!tutorialPointer || tutorialPointer.classList.contains('hidden')) {
          return;
        }

        if (!tutorialPointerTarget || !isElementVisible(tutorialPointerTarget)) {
          hideTutorialPointer();
          return;
        }

        const rect = tutorialPointerTarget.getBoundingClientRect();
        const verticalOffset = 12;

        tutorialPointer.style.left = `${rect.left + rect.width / 2}px`;
        tutorialPointer.style.top = `${rect.bottom + verticalOffset}px`;
      }

      function showTutorialPointerFor(element) {
        if (!(element instanceof HTMLElement) || !isElementVisible(element)) {
          hideTutorialPointer();
          return;
        }

        ensureTutorialPointer();

        tutorialPointerTarget = element;
        tutorialPointer.classList.remove('hidden');
        tutorialPointer.setAttribute('aria-hidden', 'false');
        updateTutorialPointerPosition();
      }

      function hideTutorialPointer() {
        if (!tutorialPointer) {
          tutorialPointerTarget = null;
          return;
        }

        tutorialPointerTarget = null;
        tutorialPointer.classList.add('hidden');
        tutorialPointer.setAttribute('aria-hidden', 'true');
      }

      window.addEventListener('resize', updateTutorialPointerPosition);
      window.addEventListener('scroll', updateTutorialPointerPosition, true);

      function highlightTutorialElement(element, options = {}) {
        const shouldIlluminate = options?.illuminate === true;

        if (tutorialHighlightedElement) {
          if (tutorialHighlightedElement !== element || !element) {
            tutorialHighlightedElement.classList.remove('tutorial-highlight');
            tutorialHighlightedElement.classList.remove('tutorial-illuminated');
            tutorialHighlightedElementOptions = { illuminate: false };
          } else if (tutorialHighlightedElementOptions.illuminate !== shouldIlluminate) {
            tutorialHighlightedElement.classList.toggle('tutorial-illuminated', shouldIlluminate);
            tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
            return;
          } else {
            return;
          }
        }

        if (element instanceof HTMLElement) {
          element.classList.add('tutorial-highlight');
          element.classList.toggle('tutorial-illuminated', shouldIlluminate);
          tutorialHighlightedElement = element;
          tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
        } else {
          tutorialHighlightedElement = null;
          tutorialHighlightedElementOptions = { illuminate: false };
        }
      }

      function setTutorialOverlayAlignment(alignment = 'center') {
        if (!tutorialOverlay) {
          return;
        }

        const shouldAlignBottom = alignment === 'bottom';
        tutorialOverlay.classList.toggle('is-bottom-aligned', shouldAlignBottom);
      }

      function openTutorialOverlay() {
        if (!tutorialOverlay) {
          return;
        }

        tutorialPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;

        tutorialOverlay.classList.remove('hidden');
        tutorialOverlay.setAttribute('aria-hidden', 'false');

        if (tutorialDialogCard && typeof tutorialDialogCard.focus === 'function') {
          tutorialDialogCard.focus();
        }
      }

      function closeTutorialOverlay() {
        if (!tutorialOverlay) {
          return;
        }

        tutorialOverlay.classList.add('hidden');
        tutorialOverlay.setAttribute('aria-hidden', 'true');

        if (tutorialPreviousFocus && typeof tutorialPreviousFocus.focus === 'function') {
          tutorialPreviousFocus.focus();
        }

        tutorialPreviousFocus = null;
      }

      function renderTutorialStepContent() {
        if (!tutorialActive) {
          return;
        }

        const step = tutorialSteps[tutorialStepIndex];
        if (!step) {
          return;
        }

        if (tutorialTitle) {
          tutorialTitle.textContent = step.title || '';
        }

        setTutorialDescriptionContent(step.body || []);

        if (tutorialProgress) {
          tutorialProgress.textContent = `Step ${tutorialStepIndex + 1} of ${tutorialSteps.length}`;
          tutorialProgress.classList.toggle('hidden', tutorialSteps.length <= 1);
        }

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.textContent =
            tutorialStepIndex === tutorialSteps.length - 1 ? 'Finish' : 'Next';
        }

        if (tutorialSecondaryAction) {
          tutorialSecondaryAction.classList.toggle('hidden', tutorialStepIndex <= 0);
        }
      }

      async function ensureRoutesAvailableForTutorial() {
        if (Array.isArray(routes) && routes.length) {
          return routes;
        }

        if (Array.isArray(allRoutes) && allRoutes.length) {
          return allRoutes;
        }

        try {
          await loadRoutes();
        } catch (error) {
          console.warn('Unable to refresh routes for tutorial:', error);
        }

        if (Array.isArray(routes) && routes.length) {
          return routes;
        }

        if (Array.isArray(allRoutes) && allRoutes.length) {
          return allRoutes;
        }

        return [];
      }

      async function showTutorialRouteTooltip() {
        const availableRoutes = await ensureRoutesAvailableForTutorial();
        if (!Array.isArray(availableRoutes) || availableRoutes.length === 0) {
          return;
        }

        const targetRoute = availableRoutes.find((route) => route && typeof route.id === 'string');
        if (!targetRoute) {
          return;
        }

        tutorialHighlightedRouteId = targetRoute.id;
        focusRoute(targetRoute);
        showTooltip(targetRoute, window.innerWidth / 2, window.innerHeight / 2, { pin: true });
      }

      function closeTutorialRouteTooltip() {
        if (tutorialHighlightedRouteId) {
          const targetRoute =
            (Array.isArray(routes) ? routes : []).find((route) => route?.id === tutorialHighlightedRouteId) ||
            (Array.isArray(allRoutes) ? allRoutes : []).find((route) => route?.id === tutorialHighlightedRouteId);

          if (targetRoute) {
            setRouteFocus(targetRoute, false);
          } else if (focusedRouteId === tutorialHighlightedRouteId) {
            focusedRouteId = null;
            redraw();
          }
        }

        tutorialHighlightedRouteId = null;
        hideTooltip({ force: true });
      }

      function buildPersonalTutorialSteps() {
        const steps = [
          {
            title: 'Welcome to your dashboard',
            body: [
              'This is your personal space for logging sends, saving projects, and keeping track of the climbs you care about.',
              'Use it to scan the wall, review your history, and stay focused on the problems you want to finish next.',
            ],
            onEnter: () => {
              setTutorialOverlayAlignment('center');
              highlightTutorialElement(null);
              hideTutorialPointer();
              closeTutorialRouteTooltip();
            },
            onExit: () => {
              highlightTutorialElement(null);
            },
          },
          {
            title: 'Route details & tracking',
            body: [
              'Tap any climb to open its tooltip. You\'ll see the setter, community grade, and everything you\'ve logged.',
              'Mark Ascended when you send it to add the climb to your ticklist automatically.',
              'Use Focus to isolate the route on the wall so you can study holds without distractions.',
              'Fill in Your grade to capture how the problem felt and compare it with the gym consensus.',
            ],
            onEnter: async () => {
              setTutorialOverlayAlignment('bottom');
              highlightTutorialElement(null);
              hideTutorialPointer();
              await showTutorialRouteTooltip();
            },
            onExit: () => {
              hideTutorialPointer();
              closeTutorialRouteTooltip();
              setTutorialOverlayAlignment('center');
            },
          },
          {
            title: 'Track your progression',
            body: [
              'Open the Progression button to review your ascents, see focused projects, and keep tabs on what\'s next.',
              'It pulls together the climbs you\'ve marked Ascended or focused so you can manage your training plan.',
            ],
            onEnter: () => {
              setTutorialOverlayAlignment('bottom');
              if (progressionButton && isElementVisible(progressionButton)) {
                openProgressionModal();
                highlightTutorialElement(progressionButton, { illuminate: true });
                showTutorialPointerFor(progressionButton);
              } else {
                closeProgressionModal();
                highlightTutorialElement(null);
                hideTutorialPointer();
              }
            },
            onExit: () => {
              hideTutorialPointer();
              highlightTutorialElement(null);
              closeProgressionModal();
              setTutorialOverlayAlignment('center');
            },
          },
        ];

        if (setterLink && !setterLink.classList.contains('hidden') && isElementVisible(setterLink)) {
          steps.push({
            title: 'Setter tools',
            body: [
              'Setters can jump straight into the workspace from here to plan new climbs and publish updates.',
              'Use it whenever you need to switch from climbing to setting mode without leaving the dashboard.',
            ],
            onEnter: () => {
              setTutorialOverlayAlignment('center');
              if (setterLink && isElementVisible(setterLink)) {
                highlightTutorialElement(setterLink, { illuminate: true });
                showTutorialPointerFor(setterLink);
              } else {
                highlightTutorialElement(null);
                hideTutorialPointer();
              }
            },
            onExit: () => {
              hideTutorialPointer();
              highlightTutorialElement(null);
            },
          });
        }

        return steps;
      }

      function detachTutorialKeydown() {
        document.removeEventListener('keydown', handleTutorialKeydown, true);
      }

      function attachTutorialKeydown() {
        document.addEventListener('keydown', handleTutorialKeydown, true);
      }

      async function goToTutorialStep(index) {
        if (!tutorialActive || tutorialTransitionInProgress) {
          return;
        }

        if (index < 0 || index >= tutorialSteps.length) {
          return;
        }

        tutorialTransitionInProgress = true;

        if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
          const currentStep = tutorialSteps[tutorialStepIndex];
          if (currentStep && typeof currentStep.onExit === 'function') {
            try {
              await currentStep.onExit();
            } catch (error) {
              console.warn('Tutorial step cleanup failed:', error);
            }
          }
        }

        tutorialStepIndex = index;
        renderTutorialStepContent();

        const nextStep = tutorialSteps[tutorialStepIndex];
        if (nextStep && typeof nextStep.onEnter === 'function') {
          try {
            await nextStep.onEnter();
          } catch (error) {
            console.warn('Tutorial step setup failed:', error);
          }
        }

        tutorialTransitionInProgress = false;

        if (tutorialPrimaryAction && tutorialStepIndex === tutorialSteps.length - 1) {
          tutorialPrimaryAction.focus();
        }
      }

      async function startTutorial() {
        if (tutorialActive) {
          return;
        }

        tutorialSteps = buildPersonalTutorialSteps();
        if (!Array.isArray(tutorialSteps) || tutorialSteps.length === 0) {
          return;
        }

        tutorialActive = true;
        tutorialStepIndex = -1;
        tutorialTransitionInProgress = false;
        openTutorialOverlay();
        attachTutorialKeydown();

        await goToTutorialStep(0);
      }

      async function finishTutorial() {
        if (!tutorialActive && !tutorialTransitionInProgress) {
          return;
        }

        tutorialTransitionInProgress = true;

        if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
          const finalStep = tutorialSteps[tutorialStepIndex];
          if (finalStep && typeof finalStep.onExit === 'function') {
            try {
              await finalStep.onExit();
            } catch (error) {
              console.warn('Tutorial step cleanup failed:', error);
            }
          }
        }

        tutorialActive = false;
        tutorialStepIndex = -1;
        tutorialTransitionInProgress = false;
        tutorialSteps = [];

        highlightTutorialElement(null);
        hideTutorialPointer();
        closeTutorialRouteTooltip();
        setTutorialOverlayAlignment('center');
        detachTutorialKeydown();
        closeTutorialOverlay();

        if (tutorialProgress) {
          tutorialProgress.classList.add('hidden');
        }
      }

      function handleTutorialKeydown(event) {
        if (!tutorialActive) {
          return;
        }

        if (event.key === 'Escape') {
          event.preventDefault();
          finishTutorial();
          return;
        }

        if (event.key === 'ArrowRight') {
          event.preventDefault();
          if (tutorialStepIndex < tutorialSteps.length - 1) {
            void goToTutorialStep(tutorialStepIndex + 1);
          } else {
            finishTutorial();
          }
          return;
        }

        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          if (tutorialStepIndex > 0) {
            void goToTutorialStep(tutorialStepIndex - 1);
          }
        }
      }


      function buildViewModeCallout() {
        if (!viewToggleButton) {
          return null;
        }

        const showingGradeColors = viewMode === VIEW_MODE_GRADE_COLORS;
        const title = showingGradeColors ? 'Grade colors' : 'Hold colors';
        const lines = showingGradeColors
          ? [
              'Routes are tinted by difficulty right now.',
              'The spectrum below runs from the easiest greens on the left to the hardest reds on the right, covering every grade color.',
            ]
          : [
              'Routes are showing the color of each hold set.',
              'Toggle to reveal grade colors and compare difficulty at a glance.',
            ];

        const callout = createBasicCallout(title, lines);
        if (showingGradeColors) {
          callout.appendChild(createGradeChartElement());
        }

        return {
          target: viewToggleButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildSetterCallout() {
        if (!setterLink || !isElementVisible(setterLink)) {
          return null;
        }

        const callout = createBasicCallout('Setter tools', [
          'Open the route-setting workspace to draw climbs for this wall.',
        ]);

        return {
          target: setterLink,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildLocationCallout() {
        if (!locationButton) {
          return null;
        }

        const callout = createBasicCallout('Wall selector', [
          'Choose a different wall or angle to load its background and routes.',
        ]);

        return {
          target: locationButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildProgressionCallout() {
        if (!progressionButton) {
          return null;
        }

        const callout = createBasicCallout('Progression tracker', [
          'Open a sortable list of every visible climb.',
          'Completed routes show a green tick beside their grade.',
        ]);

        return {
          target: progressionButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildSignOutCallout() {
        if (!signOutButton || !isElementVisible(signOutButton)) {
          return null;
        }

        const callout = createBasicCallout('Sign out', [
          'Log out of Ascend and return to the sign-in screen.',
        ]);

        return {
          target: signOutButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildRouteAscentCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const isMarkedAscended = target.getAttribute('aria-pressed') === 'true';
        const title = isMarkedAscended ? 'Marked ascended' : 'Not ascended';
        const callout = createBasicCallout(title, [
          'Toggle this when you send the climb to track your personal ascents.',
          'Turn it off again to keep projects on your list.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function buildRouteFocusCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const isFocused = target.getAttribute('aria-pressed') === 'true';
        const callout = createBasicCallout('Focus view', [
          isFocused
            ? 'All routes are visible again. Toggle Focus to isolate a single climb.'
            : 'Show only this route to inspect its holds without distractions.',
          'Use it to study beta before hopping back to the full wall.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function buildRouteGradeCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const callout = createBasicCallout('Your grade', [
          'This is your personal grade — how you think the climb feels.',
          'Your grade helps shape the community average shown in the top right.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function positionCallout(entry) {
        if (!entry?.target || !entry?.element) {
          return;
        }

        const targetRect = entry.target.getBoundingClientRect();
        if (targetRect.width === 0 && targetRect.height === 0) {
          entry.element.style.opacity = '0';
          return;
        }

        entry.element.style.opacity = '1';

        const placement = entry.options?.placement === 'top' ? 'top' : 'bottom';
        const offset = Number.isFinite(entry.options?.offset) ? entry.options.offset : 14;
        const margin = Number.isFinite(entry.options?.margin) ? entry.options.margin : 16;
        const targetCenterX = targetRect.left + targetRect.width / 2;

        if (placement === 'top') {
          entry.element.dataset.arrow = 'bottom';
          entry.element.style.top = `${targetRect.top - offset}px`;
          entry.element.style.transform = 'translate(-50%, -100%)';
        } else {
          entry.element.dataset.arrow = 'top';
          entry.element.style.top = `${targetRect.bottom + offset}px`;
          entry.element.style.transform = 'translate(-50%, 0)';
        }

        const calloutRect = entry.element.getBoundingClientRect();
        const calloutWidth = calloutRect.width;
        const minCenter = margin + calloutWidth / 2;
        const maxCenter = window.innerWidth - margin - calloutWidth / 2;
        const clampedCenter = clamp(targetCenterX, minCenter, maxCenter);
        entry.element.style.left = `${clampedCenter}px`;

        const updatedRect = entry.element.getBoundingClientRect();
        const arrowOffset = clamp(targetCenterX - updatedRect.left, 12, updatedRect.width - 12);
        entry.element.style.setProperty('--callout-arrow-offset', `${arrowOffset}px`);
      }

      function scheduleInfoHighlightsReposition() {
        if (!activeInfoCallout) {
          return;
        }

        if (pendingInfoRepositionFrame) {
          cancelAnimationFrame(pendingInfoRepositionFrame);
        }

        pendingInfoRepositionFrame = requestAnimationFrame(() => {
          pendingInfoRepositionFrame = null;
          if (activeInfoCallout) {
            positionCallout(activeInfoCallout);
          }
        });
      }

      function showInfoCallout(entry) {
        if (!entry?.element) {
          return;
        }

        const container = ensureInfoHighlightsContainer();
        if (!container) {
          return;
        }

        container.innerHTML = '';
        container.classList.remove('hidden');
        container.appendChild(entry.element);
        activeInfoCallout = entry;

        requestAnimationFrame(() => {
          if (activeInfoCallout === entry) {
            positionCallout(entry);
          }
        });
      }

      function showTemporaryInfoCallout(entry, duration = 8000) {
        if (!entry) {
          return;
        }

        showInfoCallout(entry);

        if (ephemeralCalloutDismissTimer) {
          clearTimeout(ephemeralCalloutDismissTimer);
        }

        const timeout = Number.isFinite(duration) && duration > 0 ? duration : 8000;
        ephemeralCalloutDismissTimer = window.setTimeout(() => {
          ephemeralCalloutDismissTimer = null;
          if (activeInfoCallout === entry) {
            clearInfoHighlights();
          }
        }, timeout);
      }

      function setInfoButtonActiveState(active) {
        if (!infoButton) {
          return;
        }

        infoButton.setAttribute('aria-pressed', active ? 'true' : 'false');
        infoButton.setAttribute('aria-expanded', active ? 'true' : 'false');
        infoButton.classList.toggle('is-active', active);
      }

      function hideInfoPopover() {
        if (!infoPopover) {
          return;
        }

        infoPopover.classList.add('hidden');
        infoPopover.setAttribute('aria-hidden', 'true');
      }

      function activateInfoMode() {
        infoModeActive = true;
        awaitingInfoTargetSelection = true;
        setInfoButtonActiveState(true);
        clearInfoHighlights();

        if (infoPopover) {
          infoPopover.classList.remove('hidden');
          infoPopover.setAttribute('aria-hidden', 'false');
          if (typeof infoPopover.focus === 'function') {
            infoPopover.focus({ preventScroll: true });
          }
        }
      }

      function deactivateInfoMode({ clearCallout = false } = {}) {
        awaitingInfoTargetSelection = false;

        if (infoModeActive) {
          infoModeActive = false;
        }

        setInfoButtonActiveState(false);
        hideInfoPopover();

        if (clearCallout) {
          clearInfoHighlights();
        }

      }

      function toggleInfoMode() {
        if (infoModeActive) {
          deactivateInfoMode({ clearCallout: true });
        } else {
          activateInfoMode();
        }
      }

      function handleInfoRequestFor(targetKey, event, context = {}) {
        if (!infoModeActive || !awaitingInfoTargetSelection) {
          return false;
        }

        awaitingInfoTargetSelection = false;

        if (event) {
          if (typeof event.preventDefault === 'function') {
            event.preventDefault();
          }
          if (typeof event.stopPropagation === 'function') {
            event.stopPropagation();
          }
        }

        let entry = null;
        switch (targetKey) {
          case 'view-toggle':
            entry = buildViewModeCallout();
            break;
          case 'setter-link':
            entry = buildSetterCallout();
            break;
          case 'location':
            entry = buildLocationCallout();
            break;
          case 'progression':
            entry = buildProgressionCallout();
            break;
          case 'sign-out':
            entry = buildSignOutCallout();
            break;
          case 'route-ascent':
            entry = buildRouteAscentCallout(context);
            break;
          case 'route-focus':
            entry = buildRouteFocusCallout(context);
            break;
          case 'route-grade':
            entry = buildRouteGradeCallout(context);
            break;
          default:
            break;
        }

        if (entry) {
          showInfoCallout(entry);
          deactivateInfoMode({ clearCallout: false });
        } else {
          deactivateInfoMode({ clearCallout: true });
        }

        return true;
      }

      const PATH_TYPE_BREZER = 'brezer';
      const PATH_TYPE_POINT = 'point';
      const PATH_TYPE_RECTANGLE = 'rectangle';
      const DEFAULT_PATH_TYPE = PATH_TYPE_BREZER;
      const MIN_POINT_DIAMETER = 12;
      const MAX_POINT_DIAMETER = 160;
      const DEFAULT_POINT_DIAMETER = 48;
      const MIN_RECTANGLE_SIZE = 12;
      const MAX_RECTANGLE_SIZE = 200;
      const DEFAULT_RECTANGLE_WIDTH = 80;
      const DEFAULT_RECTANGLE_HEIGHT = 60;
      const MIN_GRADE_VALUE = 1;
      const MAX_GRADE_VALUE = 31;
      const MIN_GRADE_BAR_BASE_HEIGHT = 0;
      const MAX_GRADE_BAR_HEIGHT = 1000;
      const DEFAULT_GRADE_BAR_BASE_HEIGHT = 40;
      const DEFAULT_GRADE_BAR_MAX_HEIGHT = 220;
      const MIN_GRADE_BAR_WIDTH = 4;
      const MAX_GRADE_BAR_WIDTH = 160;
      const DEFAULT_GRADE_BAR_WIDTH = 24;
      const DEFAULT_GRADE_BAR_TRANSPARENCY = 0.85;
      const MIN_UNFOCUSED_TRANSPARENCY = 0;
      const MAX_UNFOCUSED_TRANSPARENCY = 1;
      const DEFAULT_UNFOCUSED_TRANSPARENCY = 0.25;
      const WALL_COLLECTION = 'walls';
      const GRADE_COLOR_MAP = new Map([
        [1, '#2F7E13'],
        [2, '#378B14'],
        [3, '#3E9015'],
        [4, '#459616'],
        [5, '#4BA218'],
        [6, '#50AE1A'],
        [7, '#59B51A'],
        [8, '#60BA19'],
        [9, '#68BF16'],
        [10, '#71C314'],
        [11, '#87C112'],
        [12, '#92C510'],
        [13, '#C6D208'],
        [14, '#DDD805'],
        [15, '#F3DF01'],
        [16, '#F6C20E'],
        [17, '#EEA21C'],
        [18, '#EA9621'],
        [19, '#E78A27'],
        [20, '#E37B27'],
        [21, '#E06A23'],
        [22, '#DC5A1E'],
        [23, '#D94A1B'],
        [24, '#D63F18'],
        [25, '#D33314'],
        [26, '#D02711'],
        [27, '#CE1A0D'],
        [28, '#C90E0B'],
        [29, '#C50809'],
        [30, '#C10407'],
        [31, '#BD0306'],
      ]);
      const VIEW_MODE_HOLD_COLORS = 'hold-colors';
      const VIEW_MODE_GRADE_COLORS = 'grade-colors';

      function normalizePathType(value) {
        if (typeof value === 'string') {
          const normalized = value.trim().toLowerCase();
          if (normalized === PATH_TYPE_POINT) {
            return PATH_TYPE_POINT;
          }
          if (normalized === PATH_TYPE_RECTANGLE) {
            return PATH_TYPE_RECTANGLE;
          }
        }
        return DEFAULT_PATH_TYPE;
      }

      function normalizePointDiameter(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_POINT_DIAMETER;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_POINT_DIAMETER),
          MAX_POINT_DIAMETER,
        );
        return clamped;
      }

      function normalizeRectangleSize(value, fallback = DEFAULT_RECTANGLE_WIDTH) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallback;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_RECTANGLE_SIZE),
          MAX_RECTANGLE_SIZE,
        );
        return clamped;
      }

      function normalizeGradeBarHeight(value, fallback) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallback;
        }
        const clamped = Math.min(
          Math.max(numeric, MIN_GRADE_BAR_BASE_HEIGHT),
          MAX_GRADE_BAR_HEIGHT,
        );
        return Math.round(clamped);
      }

      function normalizeGradeBarWidth(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_WIDTH;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_GRADE_BAR_WIDTH),
          MAX_GRADE_BAR_WIDTH,
        );
        return clamped;
      }

      function normalizeGradeBarTransparency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_TRANSPARENCY;
        }
        const clamped = Math.min(Math.max(numeric, 0), 1);
        return Math.round(clamped * 1000) / 1000;
      }

      function normalizeUnfocusedTransparency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_UNFOCUSED_TRANSPARENCY;
        }
        const clamped = Math.min(
          Math.max(numeric, MIN_UNFOCUSED_TRANSPARENCY),
          MAX_UNFOCUSED_TRANSPARENCY,
        );
        return Math.round(clamped * 1000) / 1000;
      }

      function normalizeWallSettings(raw = {}) {
        if (!raw || typeof raw !== 'object') {
          return {
            pointDiameter: DEFAULT_POINT_DIAMETER,
            rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
            rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
            gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
            gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
            gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
            gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
            unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
          };
        }

        const pointDiameter = normalizePointDiameter(raw.pointDiameter);
        const rectangleWidth = normalizeRectangleSize(
          raw.rectangleWidth,
          DEFAULT_RECTANGLE_WIDTH,
        );
        const rectangleHeight = normalizeRectangleSize(
          raw.rectangleHeight,
          DEFAULT_RECTANGLE_HEIGHT,
        );
        const gradeBarBaseHeight = normalizeGradeBarHeight(
          raw.gradeBarBaseHeight,
          DEFAULT_GRADE_BAR_BASE_HEIGHT,
        );
        const gradeBarMaxHeight = Math.max(
          gradeBarBaseHeight,
          normalizeGradeBarHeight(raw.gradeBarMaxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
        );
        const gradeBarWidth = normalizeGradeBarWidth(raw.gradeBarWidth);
        const gradeBarTransparency = normalizeGradeBarTransparency(
          raw.gradeBarTransparency ?? raw.transparency,
        );
        const unfocusedTransparency = normalizeUnfocusedTransparency(
          raw.unfocusedTransparency ?? raw.unfocused_transparency,
        );

        return {
          pointDiameter,
          rectangleWidth,
          rectangleHeight,
          gradeBarBaseHeight,
          gradeBarMaxHeight,
          gradeBarWidth,
          gradeBarTransparency,
          unfocusedTransparency,
        };
      }

      const wallSettingsCache = new Map();

      const normalizeLocationName = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      const normalizeWallKey = (value) => normalizeLocationName(value);

      function resolveWallSettings(locationKey, fallback = null) {
        const key = normalizeWallKey(locationKey);
        if (key) {
          const cached = wallSettingsCache.get(key);
          if (cached) {
            return { ...cached };
          }
        }

        if (fallback) {
          const normalized = normalizeWallSettings(fallback);
          if (key) {
            wallSettingsCache.set(key, normalized);
          }
          return normalized;
        }

        return {
          pointDiameter: DEFAULT_POINT_DIAMETER,
          rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
          rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
          gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
          gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
          gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
          gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
          unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
        };
      }

      const findLocationByKey = (key) =>
        LOCATIONS.find((location) => location.key === key && isLocationVisible(location));

      const findLocationByName = (name) => {
        const normalized = normalizeLocationName(name);
        return (
          LOCATIONS.find(
            (location) => normalizeLocationName(location.name) === normalized && isLocationVisible(location),
          ) || null
        );
      };

      function buildWallAwareHref(baseHref, wallKey) {
        const normalizedKey = normalizeWallKey(wallKey);
        if (typeof baseHref !== 'string' || !baseHref) {
          return '';
        }

        try {
          const url = new URL(baseHref, window.location.origin);
          if (normalizedKey) {
            url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
          } else {
            url.searchParams.delete(WALL_QUERY_PARAM);
          }
          url.hash = '';
          const relativePath = `${url.pathname.replace(/^\//, '')}${url.search}`;
          return relativePath || baseHref;
        } catch (error) {
          if (!normalizedKey) {
            return baseHref;
          }

          const separator = baseHref.includes('?') ? '&' : '?';
          return `${baseHref}${separator}${encodeURIComponent(WALL_QUERY_PARAM)}=${encodeURIComponent(normalizedKey)}`;
        }
      }

      function getWallKeyFromQuery() {
        try {
          const params = new URLSearchParams(window.location.search);
          const raw = params.get(WALL_QUERY_PARAM);
          return normalizeWallKey(raw);
        } catch (error) {
          console.warn('Unable to read wall from query string:', error);
          return '';
        }
      }

      function updateWallQueryParam(wallKey) {
        try {
          const normalizedKey = normalizeWallKey(wallKey);
          const url = new URL(window.location.href);
          if (normalizedKey) {
            url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
          } else {
            url.searchParams.delete(WALL_QUERY_PARAM);
          }
          url.hash = '';
          const next = url.toString();
          if (next !== window.location.href) {
            window.history.replaceState({}, '', next);
          }
        } catch (error) {
          console.warn('Unable to update wall query parameter:', error);
        }
      }

      function persistSelectedWall(wallKey) {
        const normalizedKey = normalizeWallKey(wallKey);
        try {
          if (normalizedKey) {
            window.localStorage?.setItem(LOCATION_STORAGE_KEY, normalizedKey);
          } else {
            window.localStorage?.removeItem(LOCATION_STORAGE_KEY);
          }
        } catch (error) {
          console.warn('Unable to persist location preference:', error);
        }
      }

      function upsertLocation({
        key = '',
        name = '',
        image = '',
        fallbackName = '',
        hidden = false,
      } = {}) {
        const trimmedName = typeof name === 'string' && name.trim() ? name.trim() : '';
        const fallback =
          trimmedName || (typeof fallbackName === 'string' && fallbackName.trim() ? fallbackName.trim() : '');
        const keySource = typeof key === 'string' && key.trim() ? key.trim() : fallback;
        const normalizedKey = normalizeWallKey(keySource);
        const displayName = fallback;
        if (!normalizedKey || !displayName) {
          return { entry: null, changed: false };
        }

        const normalizedImage = typeof image === 'string' ? image.trim() : '';
        const normalizedHidden = Boolean(hidden);
        const existingIndex = LOCATIONS.findIndex((location) => {
          if (!location) {
            return false;
          }
          if (location.key === normalizedKey) {
            return true;
          }
          return normalizeLocationName(location.name) === normalizeLocationName(displayName);
        });

        if (existingIndex >= 0) {
          const existing = LOCATIONS[existingIndex];
          const needsUpdate =
            existing.key !== normalizedKey || existing.name !== displayName || existing.image !== normalizedImage;

          if (!needsUpdate) {
            const hiddenChanged = Boolean(existing.hidden) !== normalizedHidden;
            if (hiddenChanged) {
              existing.hidden = normalizedHidden;
              return { entry: existing, changed: true };
            }
            return { entry: existing, changed: false };
          }

          const updated = {
            ...existing,
            key: normalizedKey,
            name: displayName,
            image: normalizedImage,
            hidden: normalizedHidden,
          };
          LOCATIONS[existingIndex] = updated;
          return { entry: updated, changed: true };
        }

        const created = {
          key: normalizedKey,
          name: displayName,
          image: normalizedImage,
          hidden: normalizedHidden,
        };
        LOCATIONS.push(created);
        return { entry: created, changed: true };
      }

      function ensureCurrentLocationVisible() {
        if (isLocationVisible(currentLocation)) {
          return;
        }

        const fallback = getDefaultLocation();
        if (fallback) {
          const changed = !currentLocation || currentLocation.key !== fallback.key;
          currentLocation = fallback;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          updateBackgroundForCurrentLocation();
          const fallbackKey = getCurrentLocationKey();
          if (fallbackKey) {
            persistSelectedWall(fallbackKey);
            updateWallQueryParam(fallbackKey);
          } else {
            persistSelectedWall('');
            updateWallQueryParam('');
          }
          updateSetterLinkHref();
          if (changed) {
            applyLocationFilter();
          }
          return;
        }

        currentLocation = null;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();
        persistSelectedWall('');
        updateWallQueryParam('');
        updateSetterLinkHref();
        applyLocationFilter();
      }

      function synchronizeCurrentLocationReference() {
        if (!currentLocation) {
          ensureCurrentLocationVisible();
          return;
        }

        const normalizedKey = normalizeWallKey(currentLocation.key || currentLocation.name);
        const refreshed =
          (normalizedKey && findLocationByKey(normalizedKey)) ||
          findLocationByName(currentLocation.name);

        if (refreshed && refreshed !== currentLocation) {
          currentLocation = refreshed;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          updateBackgroundForCurrentLocation();
          const refreshedKey = getCurrentLocationKey();
          if (refreshedKey) {
            persistSelectedWall(refreshedKey);
            updateWallQueryParam(refreshedKey);
          } else {
            persistSelectedWall('');
            updateWallQueryParam('');
          }
          updateSetterLinkHref();
        }

        ensureCurrentLocationVisible();
      }

      let currentLocation = getDefaultLocation();

      function getCurrentLocationKey() {
        return normalizeWallKey(currentLocation?.key || currentLocation?.name);
      }

      function updateSetterLinkHref() {
        if (!setterLink) {
          return;
        }

        const wallKey = getCurrentLocationKey();
        setterLink.href = buildWallAwareHref(setterLinkBaseHref, wallKey);
      }

      let backgroundReady = false;
      let backgroundImageSource = '';
      let viewMode = VIEW_MODE_HOLD_COLORS;

      const backgroundImage = new Image();

      function updateLocationButtonLabel() {
        const labelText = currentLocation?.name || 'Select wall';
        if (locationButton) {
          locationButton.setAttribute('aria-label', `Select wall: ${labelText}`);
          locationButton.setAttribute('title', labelText);
        }
      }

      function syncViewModeState() {
        if (!document.body) {
          return;
        }
        document.body.classList.toggle('view-mode-grade-colors', viewMode === VIEW_MODE_GRADE_COLORS);
        document.body.classList.toggle('view-mode-hold-colors', viewMode === VIEW_MODE_HOLD_COLORS);
      }

      function updateViewToggleButton() {
        if (!viewToggleButton) {
          return;
        }

        const showingGradeColors = viewMode === VIEW_MODE_GRADE_COLORS;
        const labelText = showingGradeColors ? 'Show Hold Colors' : 'Show Grade Colors';
        viewToggleButton.setAttribute('aria-pressed', showingGradeColors ? 'true' : 'false');
        viewToggleButton.setAttribute('aria-label', labelText);
        viewToggleButton.setAttribute('title', labelText);
      }

      function setViewMode(mode) {
        const normalized =
          mode === VIEW_MODE_GRADE_COLORS ? VIEW_MODE_GRADE_COLORS : VIEW_MODE_HOLD_COLORS;
        if (viewMode === normalized) {
          return;
        }

        viewMode = normalized;
        syncViewModeState();
        updateViewToggleButton();
        hideTooltip({ force: true });
        if (canvas) {
          canvas.style.cursor = '';
        }
        redraw();
      }

      function updateLocationOptionsState() {
        if (!locationOptions) {
          return;
        }

        const buttons = locationOptions.querySelectorAll('[data-location-key]');
        buttons.forEach((button) => {
          const key = button?.dataset?.locationKey;
          if (key && currentLocation && key === currentLocation.key) {
            button.setAttribute('aria-current', 'true');
          } else {
            button.removeAttribute('aria-current');
          }
        });
      }

      function applyBodyBackground(imagePath) {
        if (!document.body) {
          return;
        }

        if (imagePath) {
          document.body.style.setProperty('--wall-background', `url('${imagePath}')`);
        } else {
          document.body.style.removeProperty('--wall-background');
        }
      }

      function updateBackgroundForCurrentLocation() {
        const imagePath = currentLocation?.image || '';
        applyBodyBackground(imagePath);

        if (imagePath && imagePath !== backgroundImageSource) {
          backgroundImageSource = imagePath;
          backgroundReady = false;
          backgroundImage.src = imagePath;
        } else if (!imagePath) {
          backgroundImageSource = '';
          backgroundReady = false;
        }
      }

      backgroundImage.onload = () => {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      };

      backgroundImage.onerror = () => {
        backgroundReady = false;
        resizeCanvas();
      };

      function closeLocationModal() {
        if (!locationModal) {
          return;
        }

        if (!locationModal.classList.contains('hidden')) {
          locationModal.classList.add('hidden');
          locationModal.setAttribute('aria-hidden', 'true');
          locationButton?.setAttribute('aria-expanded', 'false');
        }
      }

      function openLocationModal() {
        if (!locationModal) {
          return;
        }

        locationModal.classList.remove('hidden');
        locationModal.setAttribute('aria-hidden', 'false');
        locationButton?.setAttribute('aria-expanded', 'true');
        updateLocationOptionsState();
      }

      function handleLocationSelection(locationKey) {
        const location = findLocationByKey(locationKey);
        if (!location) {
          return;
        }

        const changed = !currentLocation || currentLocation.key !== location.key;
        currentLocation = location;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();

        const nextLocationKey = getCurrentLocationKey();
        if (nextLocationKey) {
          persistSelectedWall(nextLocationKey);
        }
        updateWallQueryParam(nextLocationKey);
        updateSetterLinkHref();

        if (changed) {
          applyLocationFilter();
        }

        closeLocationModal();
      }

      function renderLocationOptions() {
        if (!locationOptions) {
          return;
        }

        locationOptions.replaceChildren();

        LOCATIONS.filter(isLocationVisible).forEach((location) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'location-option';
          button.dataset.locationKey = location.key;
          button.setAttribute('role', 'option');

          const preview = document.createElement('div');
          preview.className = 'location-option-preview';
          preview.style.backgroundImage = `url('${location.image}')`;
          button.appendChild(preview);

          const label = document.createElement('span');
          label.className = 'location-option-label';
          const name = document.createElement('span');
          name.className = 'location-option-name';
          name.textContent = location.name;
          label.appendChild(name);
          button.appendChild(label);

          button.addEventListener('click', () => {
            handleLocationSelection(location.key);
          });

          locationOptions.appendChild(button);
        });

        updateLocationOptionsState();
      }

      const SYNTHETIC_EMAIL_DOMAIN = 'users.anuascend.local';
      const USERNAME_PATTERN = /^[a-z0-9_]{3,20}$/;

      const normalizeUsername = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      function cacheAuthenticatedUsername(username) {
        const normalized = normalizeUsername(username);
        authenticatedUsernameClaim = isValidUsername(normalized) ? normalized : '';
        return authenticatedUsernameClaim;
      }

      async function resolveAuthenticatedUsername(options = {}) {
        const { forceRefresh = false } = options;

        if (!currentUser) {
          authenticatedUsernameClaim = '';
          return isValidUsername(currentUsername) ? normalizeUsername(currentUsername) : '';
        }

        if (!forceRefresh) {
          const cachedClaim = normalizeUsername(authenticatedUsernameClaim);
          if (isValidUsername(cachedClaim)) {
            return cachedClaim;
          }
        }

        const fallbackUsername = isValidUsername(currentUsername)
          ? normalizeUsername(currentUsername)
          : '';

        try {
          const tokenResult = await getIdTokenResult(currentUser, forceRefresh);
          const claimUsername = normalizeUsername(tokenResult?.claims?.username);

          if (isValidUsername(claimUsername)) {
            return cacheAuthenticatedUsername(claimUsername);
          }
        } catch (error) {
          console.warn(
            forceRefresh
              ? 'Failed to refresh authenticated username claim:'
              : 'Failed to read authenticated username claim:',
            error,
          );
        }

        if (!forceRefresh) {
          return resolveAuthenticatedUsername({ forceRefresh: true });
        }

        if (fallbackUsername) {
          return cacheAuthenticatedUsername(fallbackUsername);
        }

        return '';
      }

      const buildSyntheticEmail = (username) => {
        const normalized = normalizeUsername(username);
        return normalized ? `${normalized}@${SYNTHETIC_EMAIL_DOMAIN}` : '';
      };

      const isValidUsername = (value) => USERNAME_PATTERN.test(normalizeUsername(value));

      const tooltipColorCanvas = document.createElement('canvas');
      const tooltipColorContext = tooltipColorCanvas.getContext('2d');

      function getTextColor(bgColor) {
        const context = document.createElement('canvas').getContext('2d');
        if (!context) {
          return '#fff';
        }

        context.fillStyle = '#000';
        context.fillStyle = bgColor;
        const values = context.fillStyle.match(/\d+/g);

        if (!values || values.length < 3) {
          return '#fff';
        }

        const [r, g, b] = values.map(Number);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        return luminance > 0.5 ? '#000' : '#fff';
      }

      function parseTooltipColor(color) {
        if (!tooltipColorContext || typeof color !== 'string') {
          return null;
        }

        let normalized;
        try {
          tooltipColorContext.fillStyle = '#000000';
          tooltipColorContext.fillStyle = color;
          normalized = tooltipColorContext.fillStyle;
        } catch (error) {
          return null;
        }

        if (typeof normalized !== 'string' || !normalized) {
          return null;
        }

        if (/^#[0-9a-f]{6}$/i.test(normalized)) {
          const r = parseInt(normalized.slice(1, 3), 16);
          const g = parseInt(normalized.slice(3, 5), 16);
          const b = parseInt(normalized.slice(5, 7), 16);
          return { r, g, b, hex: normalized };
        }

        const rgbaMatch = normalized
          .replace(/\s+/g, '')
          .match(/^rgba?\((\d+),(\d+),(\d+)(?:,(0|1|0?\.\d+))?\)$/i);

        if (rgbaMatch) {
          const [, r, g, b] = rgbaMatch;
          return {
            r: Number.parseInt(r, 10),
            g: Number.parseInt(g, 10),
            b: Number.parseInt(b, 10),
            hex: null,
          };
        }

        return null;
      }

      function deriveTooltipColorScheme(color) {
        const parsed = parseTooltipColor(color);

        if (!parsed) {
          return null;
        }

        const clamp = (value) => Math.max(0, Math.min(255, value));
        const r = clamp(parsed.r);
        const g = clamp(parsed.g);
        const b = clamp(parsed.b);
        const rgbString = `${r}, ${g}, ${b}`;
        const accent = parsed.hex ? parsed.hex : `rgb(${rgbString})`;
        const soft = `rgba(${rgbString}, 0.18)`;
        const strong = `rgba(${rgbString}, 0.85)`;
        const surfaceFactor = 0.22;
        const surfaceOffset = 18;
        const mixChannel = (channel) => clamp(Math.round(channel * surfaceFactor + surfaceOffset));
        const surface = `rgb(${mixChannel(r)}, ${mixChannel(g)}, ${mixChannel(b)})`;
        const onAccent = getTextColor(strong);
        const foreground = getTextColor(surface);
        const softForeground = foreground;
        const mutedForeground = foreground === '#000' ? '#333333' : '#d1d5db';

        return {
          accent,
          rgb: rgbString,
          soft,
          strong,
          onAccent,
          foreground,
          softForeground,
          mutedForeground,
          surface,
          border: accent,
        };
      }

      const FALLBACK_TOOLTIP_SCHEME = (() => {
        const defaultRgb = '126, 217, 87';
        const soft = 'rgba(126, 217, 87, 0.18)';
        const strong = 'rgba(126, 217, 87, 0.85)';
        const surface = 'rgb(43, 71, 47)';
        const foreground = getTextColor(surface);

        return {
          accent: '#7ed957',
          rgb: defaultRgb,
          soft,
          strong,
          onAccent: getTextColor(strong),
          foreground,
          softForeground: foreground,
          mutedForeground: foreground === '#000' ? '#333333' : '#d1d5db',
          surface,
          border: '#7ed957',
        };
      })();

      const DEFAULT_TOOLTIP_SCHEME =
        deriveTooltipColorScheme('#7ed957') ?? FALLBACK_TOOLTIP_SCHEME;

      function applyTooltipColorScheme(route) {
        if (!tooltip) {
          return;
        }

        const base = DEFAULT_TOOLTIP_SCHEME;
        const scheme = deriveTooltipColorScheme(getRouteDisplayColor(route)) ?? base;

        const accent = scheme.accent ?? base.accent;
        const rgb = scheme.rgb ?? base.rgb;
        const soft = scheme.soft ?? base.soft;
        const strong = scheme.strong ?? base.strong;
        const onAccent = scheme.onAccent ?? base.onAccent;
        const foreground = scheme.foreground ?? base.foreground;
        const softForeground = scheme.softForeground ?? base.softForeground;
        const mutedForeground = scheme.mutedForeground ?? base.mutedForeground;
        const surface = scheme.surface ?? base.surface;
        const border = scheme.border ?? base.border ?? accent;

        tooltip.style.setProperty('--tooltip-accent', accent);
        tooltip.style.setProperty('--tooltip-accent-rgb', rgb);
        tooltip.style.setProperty('--tooltip-accent-soft', soft);
        tooltip.style.setProperty('--tooltip-accent-strong', strong);
        tooltip.style.setProperty('--tooltip-on-accent', onAccent);
        tooltip.style.setProperty('--tooltip-foreground', foreground);
        tooltip.style.setProperty('--tooltip-soft-foreground', softForeground);
        tooltip.style.setProperty('--tooltip-muted-foreground', mutedForeground);
        tooltip.style.setProperty('--tooltip-surface', surface);
        tooltip.style.setProperty('--tooltip-border-color', border);
      }

      if (infoButton) {
        infoButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleInfoMode();
        });
      }

      if (infoPopover) {
        infoPopover.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }

      document.addEventListener(
        'pointerdown',
        (event) => {
          if (!infoModeActive || !awaitingInfoTargetSelection) {
            return;
          }

          const targetElement =
            event.target instanceof Element ? event.target.closest('[data-info-target]') : null;
          if (!targetElement) {
            return;
          }

          const infoKey = targetElement.getAttribute('data-info-target');
          if (!infoKey) {
            return;
          }

          handleInfoRequestFor(infoKey, event, { target: targetElement });
        },
        true,
      );

      document.addEventListener(
        'keydown',
        (event) => {
          if (!infoModeActive || !awaitingInfoTargetSelection) {
            return;
          }

          const key = event.key;
          if (key !== 'Enter' && key !== ' ' && key !== 'Spacebar') {
            return;
          }

          const targetElement =
            event.target instanceof Element ? event.target.closest('[data-info-target]') : null;
          if (!targetElement) {
            return;
          }

          const infoKey = targetElement.getAttribute('data-info-target');
          if (!infoKey) {
            return;
          }

          handleInfoRequestFor(infoKey, event, { target: targetElement });
        },
        true,
      );

      renderLocationOptions();

      const wallKeyFromQuery = getWallKeyFromQuery();
      let initialLocation = wallKeyFromQuery
        ? findLocationByKey(wallKeyFromQuery) || findLocationByName(wallKeyFromQuery)
        : null;

      let storedLocationKey = null;
      if (!initialLocation) {
        try {
          storedLocationKey = window.localStorage?.getItem(LOCATION_STORAGE_KEY) || null;
        } catch (error) {
          console.warn('Unable to read location preference:', error);
        }

        if (storedLocationKey) {
          const normalizedStoredKey = normalizeWallKey(storedLocationKey);
          initialLocation =
            findLocationByKey(normalizedStoredKey) || findLocationByName(normalizedStoredKey);
        }
      }

      if (initialLocation) {
        currentLocation = initialLocation;
      }

      ensureCurrentLocationVisible();

      const currentLocationKey = getCurrentLocationKey();
      if (currentLocationKey) {
        persistSelectedWall(currentLocationKey);
      }
      updateWallQueryParam(currentLocationKey);
      updateSetterLinkHref();

      updateLocationButtonLabel();
      updateLocationOptionsState();
      if (locationButton) {
        locationButton.setAttribute('aria-expanded', 'false');
      }
      updateBackgroundForCurrentLocation();

      if (locationButton) {
        locationButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('location', event)) {
            return;
          }
          if (activeInfoCallout?.target === locationButton) {
            clearInfoHighlights();
          }
          event.preventDefault();
          openLocationModal();
        });
      }

      if (viewToggleButton) {
        viewToggleButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('view-toggle', event)) {
            return;
          }
          if (activeInfoCallout?.target === viewToggleButton) {
            clearInfoHighlights();
          }
          const nextMode =
            viewMode === VIEW_MODE_HOLD_COLORS ? VIEW_MODE_GRADE_COLORS : VIEW_MODE_HOLD_COLORS;
          setViewMode(nextMode);
        });
      }

      if (progressionButton) {
        progressionButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('progression', event)) {
            return;
          }
          if (activeInfoCallout?.target === progressionButton) {
            clearInfoHighlights();
          }
          event.preventDefault();
          if (isProgressionModalOpen()) {
            closeProgressionModal();
          } else {
            openProgressionModal();
          }
        });
      }

      if (setterLink) {
        setterLink.addEventListener('click', (event) => {
          if (handleInfoRequestFor('setter-link', event)) {
            return;
          }
          if (activeInfoCallout?.target === setterLink) {
            clearInfoHighlights();
          }
        });
      }

      if (tutorialPrimaryAction) {
        tutorialPrimaryAction.addEventListener('click', () => {
          if (!tutorialActive) {
            return;
          }

          if (tutorialStepIndex >= tutorialSteps.length - 1) {
            void finishTutorial();
          } else {
            void goToTutorialStep(tutorialStepIndex + 1);
          }
        });
      }

      if (tutorialSecondaryAction) {
        tutorialSecondaryAction.addEventListener('click', () => {
          if (!tutorialActive || tutorialStepIndex <= 0) {
            return;
          }

          void goToTutorialStep(tutorialStepIndex - 1);
        });
      }

      if (tutorialOverlay) {
        tutorialOverlay.addEventListener('click', (event) => {
          if (event.target === tutorialOverlay) {
            void finishTutorial();
          }
        });
      }

      if (locationModalClose) {
        locationModalClose.addEventListener('click', (event) => {
          event.preventDefault();
          closeLocationModal();
        });
      }

      if (locationModal) {
        locationModal.addEventListener('click', (event) => {
          if (event.target === locationModal) {
            closeLocationModal();
          }
        });
      }

      if (progressionModalClose) {
        progressionModalClose.addEventListener('click', (event) => {
          event.preventDefault();
          closeProgressionModal();
        });
      }

      if (progressionModal) {
        progressionModal.addEventListener('click', (event) => {
          if (event.target === progressionModal) {
            closeProgressionModal();
          }
        });
      }

      window.addEventListener('resize', scheduleInfoHighlightsReposition);
      window.addEventListener('scroll', scheduleInfoHighlightsReposition, true);

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeLocationModal();
          closeProgressionModal();
          if (infoModeActive) {
            deactivateInfoMode({ clearCallout: true });
            if (infoButton) {
              infoButton.focus();
            }
          } else if (activeInfoCallout) {
            clearInfoHighlights();
            if (infoButton) {
              infoButton.focus();
            }
          }
        }
      });

      let authMode = 'login';
      let currentUser = null;
      let currentUsername = '';
      let authenticatedUsernameClaim = '';
      
      function setAuthMode(mode) {
        authMode = mode;
        const isLogin = authMode === 'login';
        authTitle.textContent = isLogin ? 'Sign in to continue' : 'Create your account';
        authSwitchLabel.textContent = isLogin ? "Don't have an account?" : 'Already have an account?';
        toggleAuthModeButton.textContent = isLogin ? 'Create one' : 'Sign in';
        authForm.querySelector('.auth-submit').textContent = isLogin ? 'Sign In' : 'Create Account';
        authPassword.setAttribute('autocomplete', isLogin ? 'current-password' : 'new-password');
        authError.textContent = '';
      }

      toggleAuthModeButton.addEventListener('click', () => {
        setAuthMode(authMode === 'login' ? 'register' : 'login');
      });

      async function lookupUsernameByUid(uid) {
        if (!uid) {
          return '';
        }

        try {
          const snapshot = await getDocs(
            query(collection(db, 'usernames'), where('uid', '==', uid), limit(1)),
          );

          if (snapshot.empty) {
            return '';
          }

          const docSnap = snapshot.docs[0];
          const data = docSnap.data() || {};
          const fromField = normalizeUsername(data.username);
          const fromId = normalizeUsername(docSnap.id);
          return fromField || fromId;
        } catch (error) {
          console.error('Failed to look up username by UID:', error);
          return '';
        }
      }

      async function resolveUsernameForUser(user) {
        if (!user) {
          return '';
        }

        const displayName = normalizeUsername(user.displayName);
        if (isValidUsername(displayName)) {
          return displayName;
        }

        const mapped = await lookupUsernameByUid(user.uid);
        if (isValidUsername(mapped)) {
          if (!displayName) {
            try {
              await updateProfile(user, { displayName: mapped });
            } catch (error) {
              console.warn('Unable to synchronise display name with username:', error);
            }
          }
          return mapped;
        }

        const syntheticEmail = typeof user.email === 'string' ? user.email : '';
        if (syntheticEmail.endsWith(`@${SYNTHETIC_EMAIL_DOMAIN}`)) {
          const derived = normalizeUsername(
            syntheticEmail.slice(0, -(`@${SYNTHETIC_EMAIL_DOMAIN}`.length)),
          );
          if (isValidUsername(derived)) {
            return derived;
          }
        }

        return '';
      }

      authForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        authError.textContent = '';

        const rawUsername = authUsername.value;
        const normalizedUsername = normalizeUsername(rawUsername);
        const password = authPassword.value;

        if (!normalizedUsername) {
          authError.textContent = 'Enter your username to continue.';
          return;
        }

        if (!isValidUsername(normalizedUsername)) {
          authError.textContent =
            'Usernames must be 3-20 characters using only letters, numbers, or underscores.';
          return;
        }

        const syntheticEmail = buildSyntheticEmail(normalizedUsername);

        try {
          if (authMode === 'login') {
            await signInWithEmailAndPassword(auth, syntheticEmail, password);
            return;
          }

          const credentials = await createUserWithEmailAndPassword(auth, syntheticEmail, password);
          const { user } = credentials;

          try {
            await setDoc(doc(db, 'usernames', normalizedUsername), {
              uid: user.uid,
              username: normalizedUsername,
              createdAt: serverTimestamp(),
              updatedAt: serverTimestamp(),
            });
          } catch (error) {
            console.error('Failed to reserve username:', error);
            try {
              await deleteUser(user);
            } catch (cleanupError) {
              console.warn('Unable to clean up user after username failure:', cleanupError);
            }
            const usernameError = new Error('Username unavailable');
            usernameError.code = 'auth/username-unavailable';
            throw usernameError;
          }

          try {
            await updateProfile(user, { displayName: normalizedUsername });
          } catch (profileError) {
            console.warn('Failed to update display name:', profileError);
          }
        } catch (error) {
          let message = 'Unable to complete the request. Please try again.';

          switch (error?.code) {
            case 'auth/user-not-found':
            case 'auth/wrong-password':
              message = 'Invalid username or password.';
              break;
            case 'auth/email-already-in-use':
            case 'auth/username-unavailable':
            case 'permission-denied':
              message = 'That username is already taken. Choose another one.';
              break;
            case 'auth/invalid-email':
              message = 'Enter a valid username.';
              break;
            case 'auth/weak-password':
              message = 'Choose a stronger password (at least 6 characters).';
              break;
            default:
              if (error?.message) {
                message = error.message;
              }
          }

          authError.textContent = message;
        }
      });

      if (signOutButton) {
        signOutButton.addEventListener('click', async (event) => {
          if (handleInfoRequestFor('sign-out', event)) {
            return;
          }
          if (activeInfoCallout?.target === signOutButton) {
            clearInfoHighlights();
          }
          await signOutAndRedirectToIndex();
        });
      }

      async function ensureUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return { role: 'default' };
        }

        const roleRef = doc(db, 'roles', user.uid);
        const existingSnap = await getDoc(roleRef);

        if (existingSnap.exists()) {
          const existingData = existingSnap.data() || {};
          const storedLowerRaw =
            typeof existingData.usernameLower === 'string'
              ? existingData.usernameLower
              : typeof existingData.username === 'string'
              ? existingData.username
              : '';
          let effectiveLower = normalizeUsername(storedLowerRaw);
          const trimmedRole =
            typeof existingData.role === 'string'
              ? existingData.role.trim().toLowerCase()
              : 'default';
          const mergedData = {
            ...existingData,
            role: trimmedRole,
          };

          if (effectiveLower !== normalizedUsername || !existingData.username) {
            try {
              await setDoc(
                roleRef,
                {
                  username: normalizedUsername,
                  usernameLower: normalizedUsername,
                  updatedAt: serverTimestamp(),
                },
                { merge: true },
              );
              mergedData.username = normalizedUsername;
              mergedData.usernameLower = normalizedUsername;
              effectiveLower = normalizedUsername;
            } catch (error) {
              console.warn('Failed to synchronise username on role document:', error);
            }
          }

          if (effectiveLower !== normalizedUsername) {
            mergedData.role = 'default';
          }

          return mergedData;
        }

        let role = 'default';

        try {
          const snapshot = await getDocs(
            query(collection(db, 'roles'), where('role', '==', 'setter'), limit(1)),
          );
          if (snapshot.empty) {
            role = 'setter';
          }
        } catch (error) {
          console.warn('Unable to inspect existing roles:', error);
        }

        const roleData = {
          role,
          username: normalizedUsername,
          usernameLower: normalizedUsername,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        };

        await setDoc(roleRef, roleData, { merge: true });
        return roleData;
      }

      async function resolveUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return 'default';
        }

        try {
          const ensuredRole = await ensureUserRole(user, normalizedUsername);
          return typeof ensuredRole?.role === 'string'
            ? ensuredRole.role.trim().toLowerCase()
            : 'default';
        } catch (error) {
          console.error('Failed to fetch user role:', error);
          return 'default';
        }
      }

        function updateNavigationForRole(role) {
          updateSetterLinkHref();
          if (!setterLink) {
            return;
          }

          const shouldHideSetterLink = role !== 'setter';
          setterLink.classList.toggle('hidden', shouldHideSetterLink);

          if (shouldHideSetterLink && activeInfoCallout?.target === setterLink) {
            clearInfoHighlights();
          }
        }

      onAuthStateChanged(auth, async (user) => {
        if (user) {
          authOverlay.classList.add('hidden');

          currentUser = user;

          const resolvedUsername = await resolveUsernameForUser(user);
          if (!isValidUsername(resolvedUsername)) {
            authError.textContent =
              'Unable to resolve your username. Please contact a setter for assistance.';
            await signOutAndRedirectToIndex();
            return;
          }

          currentUsername = normalizeUsername(resolvedUsername);
          authenticatedUsernameClaim = '';
          const canonicalUsername = await resolveAuthenticatedUsername();
          if (isValidUsername(canonicalUsername)) {
            currentUsername = canonicalUsername;
          }

          const role = await resolveUserRole(user, currentUsername);

          updateNavigationForRole(role);
          appContent.classList.remove('hidden');

          await loadAscents({ userId: user.uid, username: currentUsername });
          await loadRoutes();
          await startTutorial();
        } else {
          authOverlay.classList.remove('hidden');
          appContent.classList.add('hidden');
          setterLink.classList.add('hidden');
          void finishTutorial();
          if (infoModeActive) {
            deactivateInfoMode({ clearCallout: true });
          } else if (activeInfoCallout) {
            clearInfoHighlights();
          }
          authForm.reset();
          setAuthMode('login');
          routes = [];
          focusedRouteId = null;
          currentUser = null;
          currentUsername = '';
          authenticatedUsernameClaim = '';
          ascendedRoutes.clear();
          routeGrades.clear();
          routeMedianGrades = new Map();
          hideTooltip({ force: true });
          redraw();
        }
      });

      setAuthMode('login');

      const canvasContainer = document.querySelector('.canvas-container');
      const canvas = document.getElementById('previewCanvas');
      const ctx = canvas.getContext('2d');

      syncViewModeState();
      updateViewToggleButton();

      const DEFAULT_CANVAS_ASPECT_RATIO = 1536 / 1024;
      let canvasAspectRatio = DEFAULT_CANVAS_ASPECT_RATIO;
      let isHorizontalScrollEnabled = false;

      let allRoutes = [];
      let routes = [];
      let focusedRouteId = null;
      let routeInteractionEntries = [];
      let activeRouteId = null;
      let pinnedRouteId = null;
      let pinnedPosition = null;
      const ascendedRoutes = new Set();
      const routeGrades = new Map();
      let userAscentDetails = new Map();
      let routeMedianGrades = new Map();
      let progressionPreviouslyFocusedElement = null;

      const ROUTE_TIPS_COLLECTION = 'routeTips';
      const ROUTE_TIPS_ENTRIES_COLLECTION = 'entries';
      const MAX_ROUTE_TIP_LENGTH = 500;
      const routeTipsCache = new Map();

      function synchroniseAscentsWithRoutes(options = {}) {
        const { shouldRedraw = true } = options;
        ascendedRoutes.clear();
        routeGrades.clear();

        if (!Array.isArray(routes) || routes.length === 0) {
          renderProgressionList();
          if (shouldRedraw) {
            redraw();
          }
          return;
        }

        routes.forEach((route) => {
          if (!route?.id) {
            return;
          }

          const ascent = userAscentDetails.get(route.id);
          if (!ascent) {
            return;
          }

          if (typeof ascent.grade === 'number' && Number.isFinite(ascent.grade)) {
            routeGrades.set(route.id, ascent.grade);
          }

          if (ascent.ascended) {
            ascendedRoutes.add(route.id);
          }
        });

        renderProgressionList();

        if (shouldRedraw) {
          redraw();
        }
      }

      async function loadAscents({ userId, username }) {
        ascendedRoutes.clear();
        routeGrades.clear();
        userAscentDetails = new Map();

        const normalizedUserId = typeof userId === 'string' ? userId.trim() : '';
        const normalizedUsername = normalizeUsername(username);
        const hasValidUsername = isValidUsername(normalizedUsername);
        if (!normalizedUserId && !hasValidUsername) {
          return;
        }

        try {
          let ascentData = null;

          if (normalizedUserId) {
            const ascentRef = doc(db, 'ascents', normalizedUserId);
            const ascentSnap = await getDoc(ascentRef);
            if (ascentSnap.exists()) {
              ascentData = ascentSnap.data() ?? {};
            }

            if (!ascentData && hasValidUsername && normalizedUsername !== normalizedUserId) {
              const legacyRef = doc(db, 'ascents', normalizedUsername);
              const legacySnap = await getDoc(legacyRef);

              if (legacySnap.exists()) {
                ascentData = legacySnap.data() ?? {};

                try {
                  const migrationPayload = {
                    ...ascentData,
                    climber_uid: normalizedUserId,
                    updatedAt: serverTimestamp(),
                  };

                  if (hasValidUsername) {
                    migrationPayload.climber_username = normalizedUsername;
                  }

                  await setDoc(ascentRef, migrationPayload, { merge: true });
                } catch (migrationError) {
                  console.warn('Failed to migrate legacy ascent document to UID path:', migrationError);
                }
              }
            }
          }

          if (!ascentData && hasValidUsername && normalizedUsername !== normalizedUserId) {
            const ascentRef = doc(db, 'ascents', normalizedUsername);
            const ascentSnap = await getDoc(ascentRef);

            if (!ascentSnap.exists()) {
              return;
            }

            ascentData = ascentSnap.data() ?? {};
          }

          if (!ascentData) {
            return;
          }

          const routesData = ascentData.routes;

          if (routesData && typeof routesData === 'object') {
            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!routeId || !details) {
                return;
              }

              const gradeValue = normalizeGradeValue(details?.grade);
              const normalizedDate = normalizeDate(details?.date_ascended);
              const ascended = details?.ascended === true || Boolean(normalizedDate);

              const entry = {
                ascended,
                grade: gradeValue,
              };

              if (normalizedDate) {
                entry.dateAscended = normalizedDate;
              }

              userAscentDetails.set(routeId, entry);
            });

            synchroniseAscentsWithRoutes();
            return;
          }

          const singleRouteId = typeof ascentData.route_id === 'string' ? ascentData.route_id : null;
          if (singleRouteId) {
            userAscentDetails.set(singleRouteId, { ascended: true, grade: null });
            synchroniseAscentsWithRoutes();
            return;
          }
        } catch (error) {
          console.error('Failed to load ascents:', error);
        }

        synchroniseAscentsWithRoutes();
      }

      function normalizeDate(value) {
        if (!value) {
          return null;
        }

        if (typeof value === 'string') {
          const date = new Date(value);
          return Number.isNaN(date.getTime()) ? null : date.toISOString();
        }

        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }

        if (typeof value?.toDate === 'function') {
          const date = value.toDate();
          if (date instanceof Date && !Number.isNaN(date.getTime())) {
            return date.toISOString();
          }
          return null;
        }

        return null;
      }

      function formatDisplayDate(isoString) {
        if (!isoString) {
          return 'Unknown';
        }

        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return 'Unknown';
        }

        return date.toLocaleDateString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
        });
      }

      function normalizeGradeValue(value) {
        if (value === null || value === undefined) {
          return null;
        }

        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return null;
        }

        if (!Number.isInteger(numeric)) {
          return null;
        }

        if (numeric < MIN_GRADE_VALUE || numeric > MAX_GRADE_VALUE) {
          return null;
        }

        return numeric;
      }

      function formatGradeDisplay(value) {
        if (typeof value !== 'number' || !Number.isFinite(value)) {
          return '—';
        }

        return Number.isInteger(value) ? String(value) : value.toFixed(1);
      }

      function resolveProgressionGradeValue(route) {
        if (!route) {
          return null;
        }

        if (typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)) {
          return route.medianGrade;
        }

        const stored = routeGrades.get(route.id);
        if (typeof stored === 'number' && Number.isFinite(stored)) {
          return stored;
        }

        return null;
      }

      function renderProgressionList() {
        if (!progressionList) {
          return;
        }

        progressionList.innerHTML = '';

        const desiredLocation = normalizeLocationName(currentLocation?.name);
        const fallbackLocation = normalizeLocationName(getDefaultLocation()?.name);
        const targetLocation = desiredLocation || fallbackLocation || null;

        const relevantRoutes = Array.isArray(routes)
          ? routes.filter((route) => {
              if (!route) {
                return false;
              }

              if (!targetLocation) {
                return true;
              }

              const routeLocationKey =
                typeof route.locationKey === 'string' && route.locationKey
                  ? route.locationKey
                  : normalizeLocationName(route.location);

              return routeLocationKey === targetLocation;
            })
          : [];

        if (!relevantRoutes.length) {
          const emptyMessage = document.createElement('p');
          emptyMessage.className = 'progression-empty-message';
          emptyMessage.textContent = 'No routes available for this wall yet.';
          progressionList.appendChild(emptyMessage);
          return;
        }

        const sorted = relevantRoutes.slice().sort((routeA, routeB) => {
          const gradeA = resolveProgressionGradeValue(routeA);
          const gradeB = resolveProgressionGradeValue(routeB);

          if (gradeA === null && gradeB === null) {
            const nameA = (routeA.title || routeA.id || '').toLowerCase();
            const nameB = (routeB.title || routeB.id || '').toLowerCase();
            return nameA.localeCompare(nameB);
          }

          if (gradeA === null) {
            return 1;
          }

          if (gradeB === null) {
            return -1;
          }

          if (gradeA !== gradeB) {
            return gradeA - gradeB;
          }

          const nameA = (routeA.title || routeA.id || '').toLowerCase();
          const nameB = (routeB.title || routeB.id || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });

        sorted.forEach((route) => {
          if (!route) {
            return;
          }

          const listItem = document.createElement('div');
          listItem.className = 'progression-entry';
          listItem.setAttribute('role', 'listitem');
          listItem.setAttribute('tabindex', '0');

          if (route.id) {
            listItem.dataset.routeId = route.id;
          }

          const isFocused = typeof route.id === 'string' && route.id === focusedRouteId;
          if (isFocused) {
            listItem.classList.add('is-focused');
            listItem.setAttribute('aria-current', 'true');
          }

          const grade = document.createElement('span');
          grade.className = 'progression-entry-grade';
          const gradeValue = resolveProgressionGradeValue(route);
          grade.textContent = formatGradeDisplay(gradeValue);

          const gradeColor = getRouteGradeColor(route);
          if (gradeColor) {
            grade.style.color = gradeColor;
          }

          listItem.appendChild(grade);

          const details = document.createElement('div');
          const title = document.createElement('span');
          title.className = 'progression-entry-name';
          title.textContent = route.title || route.id || 'Untitled route';

          if (gradeColor) {
            title.style.color = gradeColor;
          }

          details.appendChild(title);
          listItem.appendChild(details);

          const status = document.createElement('span');
          status.className = 'progression-entry-status';
          const isAscended = Boolean(route.id && ascendedRoutes.has(route.id));

          if (isAscended) {
            status.textContent = '✓';
            status.classList.add('is-ascended');
            status.setAttribute('aria-label', 'Ascended');
            status.setAttribute('title', 'Ascended');
          } else {
            status.textContent = '';
            status.setAttribute('aria-hidden', 'true');
          }

          listItem.appendChild(status);

          listItem.addEventListener('click', (event) => {
            event.preventDefault();
            focusRoute(route);
          });

          listItem.addEventListener('keydown', (event) => {
            const { key } = event;
            if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
              event.preventDefault();
              focusRoute(route);
            }
          });

          progressionList.appendChild(listItem);
        });
      }

      function isProgressionModalOpen() {
        if (!progressionModal) {
          return false;
        }

        return !progressionModal.classList.contains('hidden');
      }

      function closeProgressionModal() {
        if (!progressionModal) {
          return;
        }

        progressionModal.classList.add('hidden');
        progressionModal.setAttribute('aria-hidden', 'true');

        if (progressionButton) {
          progressionButton.setAttribute('aria-expanded', 'false');
        }

        document.removeEventListener('keydown', handleProgressionKeydown, true);

        if (progressionPreviouslyFocusedElement && typeof progressionPreviouslyFocusedElement.focus === 'function') {
          progressionPreviouslyFocusedElement.focus();
        }
        progressionPreviouslyFocusedElement = null;
      }

      function handleProgressionKeydown(event) {
        if (event.key === 'Escape' && isProgressionModalOpen()) {
          event.preventDefault();
          closeProgressionModal();
        }
      }

      function openProgressionModal() {
        if (!progressionModal) {
          return;
        }

        renderProgressionList();

        progressionPreviouslyFocusedElement =
          document.activeElement instanceof HTMLElement ? document.activeElement : null;

        progressionModal.classList.remove('hidden');
        progressionModal.setAttribute('aria-hidden', 'false');

        if (progressionButton) {
          progressionButton.setAttribute('aria-expanded', 'true');
        }

        document.addEventListener('keydown', handleProgressionKeydown, true);

        const focusTarget =
          progressionModalClose && typeof progressionModalClose.focus === 'function'
            ? progressionModalClose
            : progressionModal;
        focusTarget.focus();
      }

      function getUserGradeForRoute(routeId) {
        if (!routeId) {
          return null;
        }

        const stored = routeGrades.get(routeId);
        return typeof stored === 'number' && Number.isFinite(stored) ? stored : null;
      }

      function createTooltipCloseButton() {
        const closeButton = document.createElement('button');
        closeButton.type = 'button';
        closeButton.className = 'tooltip-close-button';
        closeButton.setAttribute('aria-label', 'Close route details');
        closeButton.setAttribute('title', 'Close route details');
        closeButton.innerHTML = `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M6.34 6.34a1 1 0 0 1 1.32-.08l.1.08L12 10.59l4.24-4.25a1 1 0 0 1 1.5 1.32l-.08.1L13.41 12l4.25 4.24a1 1 0 0 1-1.32 1.5l-.1-.08L12 13.41l-4.24 4.25a1 1 0 0 1-1.5-1.32l.08-.1L10.59 12 6.34 7.76a1 1 0 0 1 0-1.42Z"
              fill="currentColor"
            />
          </svg>
        `;
        closeButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          hideTooltip({ force: true });
        });
        return closeButton;
      }

      function buildGradeControls(route) {
        if (!route || !route.id) {
          return null;
        }

        const container = document.createElement('div');
        container.className = 'grade-section';

        const gradeForm = document.createElement('form');
        gradeForm.className = 'grade-form';
        gradeForm.noValidate = true;

        const gradeLabel = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.textContent = `Your grade (${MIN_GRADE_VALUE}-${MAX_GRADE_VALUE})`;
        gradeLabel.appendChild(labelText);

        const gradeInput = document.createElement('input');
        gradeInput.type = 'number';
        gradeInput.min = String(MIN_GRADE_VALUE);
        gradeInput.max = String(MAX_GRADE_VALUE);
        gradeInput.step = '1';
        gradeInput.inputMode = 'numeric';
        const existingGrade = getUserGradeForRoute(route.id);
        gradeInput.value = existingGrade !== null ? String(existingGrade) : '';
        gradeInput.placeholder = '—';
        gradeInput.dataset.infoTarget = 'route-grade';

        gradeLabel.appendChild(gradeInput);

        const gradeInputRow = document.createElement('div');
        gradeInputRow.className = 'grade-input-row';
        gradeInputRow.appendChild(gradeLabel);

        gradeForm.appendChild(gradeInputRow);

        let isSubmittingGrade = false;
        let lastSubmittedValue = gradeInput.value.trim();

        const commitGradeFromInput = async () => {
          if (isSubmittingGrade) {
            return;
          }

          const rawValue = gradeInput.value.trim();
          if (rawValue === lastSubmittedValue) {
            return;
          }

          isSubmittingGrade = true;

          try {
            if (!rawValue) {
              gradeInput.setCustomValidity('');
              await applyUserRouteGrade(route, null);
              lastSubmittedValue = '';
              gradeInput.value = '';
              return;
            }

            const parsed = normalizeGradeValue(rawValue);
            if (parsed === null) {
              gradeInput.setCustomValidity(
                `Enter a whole number between ${MIN_GRADE_VALUE} and ${MAX_GRADE_VALUE}.`,
              );
              gradeInput.reportValidity();
              return;
            }

            gradeInput.setCustomValidity('');
            await applyUserRouteGrade(route, parsed);
            lastSubmittedValue = String(parsed);
            gradeInput.value = String(parsed);
          } finally {
            isSubmittingGrade = false;
          }
        };

        gradeInput.addEventListener('input', () => {
          gradeInput.setCustomValidity('');
        });

        gradeInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            gradeForm.requestSubmit();
          }
        });

        gradeInput.addEventListener('blur', () => {
          void commitGradeFromInput();
        });

        gradeForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          event.stopPropagation();
          await commitGradeFromInput();
        });

        container.appendChild(gradeForm);

        return container;
      }

      async function applyUserRouteGrade(route, gradeValue) {
        if (!route || !route.id) {
          return;
        }

        if (!currentUser) {
          console.warn('Unable to save grade: no authenticated user.');
          return;
        }

        const username = await resolveAuthenticatedUsername();
        if (!username) {
          console.warn('Unable to save grade: user username missing.');
          return;
        }

        const userId = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to save grade: user ID missing.');
          return;
        }

        const sanitizedGrade = gradeValue === null ? null : normalizeGradeValue(gradeValue);
        if (sanitizedGrade === null && gradeValue !== null) {
          console.warn('Unable to save grade: invalid grade value provided.');
          return;
        }

        const ascentRef = doc(db, 'ascents', userId);

        try {
          await setDoc(
            ascentRef,
            {
              climber_uid: userId,
              climber_username: username,
              updatedAt: serverTimestamp(),
              routes: {
                [route.id]: {
                  grade: sanitizedGrade,
                  route_id: route.id,
                  climber_uid: userId,
                  climber_username: username,
                },
              },
            },
            { merge: true },
          );

          const existingEntry = userAscentDetails.get(route.id);
          const isAscended = existingEntry?.ascended === true;

          if (sanitizedGrade === null) {
            routeGrades.delete(route.id);

            if (existingEntry) {
              userAscentDetails.set(route.id, { ...existingEntry, ascended: isAscended, grade: null });
            } else {
              userAscentDetails.delete(route.id);
            }
          } else {
            routeGrades.set(route.id, sanitizedGrade);
            const nextEntry = { ...(existingEntry || {}), ascended: isAscended, grade: sanitizedGrade };
            userAscentDetails.set(route.id, nextEntry);
          }

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          await refreshMedianGrades();
        } catch (error) {
          console.error('Failed to update route grade:', error);
        }
      }

      async function fetchMedianGrades() {
        const medianMap = new Map();

        try {
          const snapshot = await getDocs(collection(db, 'ascents'));
          const gradeBuckets = new Map();

          snapshot.forEach((docSnap) => {
            const data = docSnap.data() ?? {};
            const routesData = data.routes;

            if (!routesData || typeof routesData !== 'object') {
              return;
            }

            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!details) {
                return;
              }

              const grade = normalizeGradeValue(details.grade);
              if (grade === null) {
                return;
              }

              if (!gradeBuckets.has(routeId)) {
                gradeBuckets.set(routeId, []);
              }

              gradeBuckets.get(routeId).push(grade);
            });
          });

          gradeBuckets.forEach((grades, routeId) => {
            if (!Array.isArray(grades) || grades.length === 0) {
              return;
            }

            grades.sort((a, b) => a - b);
            const mid = Math.floor(grades.length / 2);

            if (grades.length % 2 === 0) {
              medianMap.set(routeId, (grades[mid - 1] + grades[mid]) / 2);
            } else {
              medianMap.set(routeId, grades[mid]);
            }
          });
        } catch (error) {
          console.error('Failed to load route grades:', error);
        }

        return medianMap;
      }

      async function refreshMedianGrades() {
        routeMedianGrades = await fetchMedianGrades();

        if (Array.isArray(allRoutes)) {
          allRoutes.forEach((route) => {
            const median = routeMedianGrades.get(route.id);
            route.medianGrade = typeof median === 'number' && Number.isFinite(median) ? median : null;
          });
        }

        redraw();
      }

      function createRouteTipsSection(route, ariaLines) {
        const section = document.createElement('div');
        section.className = 'tooltip-tips';

        const title = document.createElement('p');
        title.className = 'tooltip-tips-title';
        title.textContent = 'Route tips';
        section.appendChild(title);

        if (Array.isArray(ariaLines)) {
          ariaLines.push('Route tips');
        }

        const tipsList = document.createElement('div');
        tipsList.className = 'tooltip-tips-list';
        tipsList.setAttribute('role', 'list');
        const routeIdValue = route && typeof route.id === 'string' ? route.id : '';
        tipsList.dataset.routeId = routeIdValue;
        tipsList.textContent = 'Loading tips…';
        section.appendChild(tipsList);

        const status = document.createElement('p');
        status.className = 'tooltip-tip-status';
        status.setAttribute('role', 'status');
        status.setAttribute('aria-live', 'polite');
        status.hidden = true;
        section.appendChild(status);

        let form = null;
        let textarea = null;
        let submit = null;

        if (currentUser) {
          form = document.createElement('form');
          form.className = 'tooltip-tip-form';
          form.setAttribute('novalidate', '');

          const label = document.createElement('label');
          label.className = 'sr-only';
          const sanitizedRouteKey = routeIdValue.replace(/[^a-zA-Z0-9_-]/g, '');
          const textareaId = sanitizedRouteKey
            ? `routeTipInput-${sanitizedRouteKey}`
            : `routeTipInput-${Math.random().toString(36).slice(2)}`;
          label.setAttribute('for', textareaId);
          label.textContent = 'Add a tip for this route';

          textarea = document.createElement('textarea');
          textarea.id = textareaId;
          textarea.className = 'tooltip-tip-input';
          textarea.rows = 3;
          textarea.maxLength = MAX_ROUTE_TIP_LENGTH;
          textarea.placeholder = 'Share beta or helpful notes…';
          textarea.required = true;

          submit = document.createElement('button');
          submit.type = 'submit';
          submit.className = 'tooltip-tip-submit';
          submit.textContent = 'Add tip';

          form.append(label, textarea, submit);
          section.appendChild(form);
        } else {
          const signInNote = document.createElement('p');
          signInNote.className = 'tooltip-tip-empty';
          signInNote.textContent = 'Sign in to share a tip.';
          section.appendChild(signInNote);
        }

        return { section, list: tipsList, status, form, textarea, submit };
      }

      function renderRouteTipsList(listElement, tips) {
        if (!listElement) {
          return [];
        }

        listElement.replaceChildren();
        const ariaEntries = [];
        const entries = Array.isArray(tips) ? tips : [];

        entries.forEach((tip) => {
          if (!tip) {
            return;
          }

          const rawUsername = typeof tip.username === 'string' ? tip.username.trim() : '';
          const username = rawUsername || 'Anonymous';
          const rawTipText = typeof tip.tip === 'string' ? tip.tip.trim() : '';
          if (!rawTipText) {
            return;
          }

          const entry = document.createElement('div');
          entry.className = 'tooltip-tip-entry';
          entry.setAttribute('role', 'listitem');
          entry.textContent = `${username}\n${rawTipText}`;
          listElement.appendChild(entry);

          const ariaTipText = rawTipText.replace(/\s+/g, ' ');
          ariaEntries.push(`${username}: ${ariaTipText}`);
        });

        if (!listElement.childElementCount) {
          const empty = document.createElement('p');
          empty.className = 'tooltip-tip-empty';
          empty.textContent = 'No tips yet. Be the first to share one.';
          listElement.appendChild(empty);
          ariaEntries.push('No tips yet');
        }

        return ariaEntries;
      }

      async function loadRouteTips(routeId, options = {}) {
        const { force = false } = options;
        const normalizedRouteId = typeof routeId === 'string' ? routeId.trim() : '';

        if (!normalizedRouteId) {
          return [];
        }

        if (!force && routeTipsCache.has(normalizedRouteId)) {
          return routeTipsCache.get(normalizedRouteId) || [];
        }

        try {
          const tipsRef = collection(
            db,
            ROUTE_TIPS_COLLECTION,
            normalizedRouteId,
            ROUTE_TIPS_ENTRIES_COLLECTION,
          );
          const snapshot = await getDocs(tipsRef);
          const tips = [];

          snapshot.forEach((docSnap) => {
            const data = docSnap.data() ?? {};
            const rawTipText = typeof data.tip === 'string' ? data.tip.trim() : '';
            if (!rawTipText) {
              return;
            }

            const rawUsername = typeof data.username === 'string' ? data.username.trim() : '';
            const createdAtValue =
              typeof data.createdAt?.toMillis === 'function'
                ? data.createdAt.toMillis()
                : typeof data.createdAt === 'number'
                ? data.createdAt
                : 0;

            tips.push({
              id: docSnap.id,
              username: rawUsername || 'Anonymous',
              tip: rawTipText,
              createdAt: createdAtValue,
            });
          });

          tips.sort((a, b) => {
            if (a.createdAt !== b.createdAt) {
              return a.createdAt - b.createdAt;
            }
            return a.id.localeCompare(b.id);
          });

          routeTipsCache.set(normalizedRouteId, tips);
          return tips;
        } catch (error) {
          console.error('Failed to load route tips:', error);
          throw error;
        }
      }

      async function refreshRouteTips(routeId, options = {}) {
        const { listElement, statusElement, applyAriaLabel, force = false } = options;
        if (!listElement) {
          return;
        }

        const normalizedRouteId = typeof routeId === 'string' ? routeId.trim() : '';
        listElement.dataset.routeId = normalizedRouteId;

        const updateAria = typeof applyAriaLabel === 'function' ? applyAriaLabel : null;

        if (!normalizedRouteId) {
          const ariaEntries = renderRouteTipsList(listElement, []);
          if (updateAria) {
            updateAria(ariaEntries);
          }
          return;
        }

        if (!force && routeTipsCache.has(normalizedRouteId)) {
          const cachedTips = routeTipsCache.get(normalizedRouteId) || [];
          const ariaEntries = renderRouteTipsList(listElement, cachedTips);
          if (statusElement) {
            statusElement.hidden = true;
            statusElement.textContent = '';
            statusElement.classList.remove('is-error');
          }
          if (updateAria) {
            updateAria(ariaEntries);
          }
          return;
        }

        listElement.textContent = 'Loading tips…';
        if (statusElement) {
          statusElement.hidden = true;
          statusElement.textContent = '';
          statusElement.classList.remove('is-error');
        }
        if (updateAria) {
          updateAria(['Loading tips']);
        }

        try {
          const tips = await loadRouteTips(normalizedRouteId, { force });
          if (listElement.dataset.routeId !== normalizedRouteId) {
            return;
          }
          if (activeRouteId && activeRouteId !== normalizedRouteId) {
            return;
          }
          const ariaEntries = renderRouteTipsList(listElement, tips);
          if (updateAria) {
            updateAria(ariaEntries);
          }
        } catch (error) {
          if (statusElement) {
            statusElement.textContent = 'Unable to load tips right now.';
            statusElement.hidden = false;
            statusElement.classList.add('is-error');
          }
          if (updateAria) {
            updateAria(['Unable to load tips right now.']);
          }
        }
      }

      async function saveRouteTip(route, tipText) {
        if (!currentUser) {
          throw new Error('User must be signed in to add tips.');
        }

        const routeId = route && typeof route.id === 'string' ? route.id.trim() : '';
        if (!routeId) {
          throw new Error('Route is missing an identifier.');
        }

        const rawTip = typeof tipText === 'string' ? tipText.trim() : '';
        if (!rawTip) {
          throw new Error('Tip text cannot be empty.');
        }

        const sanitizedTip = rawTip.slice(0, MAX_ROUTE_TIP_LENGTH);
        const usernameCandidate = isValidUsername(currentUsername)
          ? currentUsername
          : normalizeUsername(currentUser?.displayName);
        const username = usernameCandidate || 'Anonymous';

        const tipsRef = collection(db, ROUTE_TIPS_COLLECTION, routeId, ROUTE_TIPS_ENTRIES_COLLECTION);
        await addDoc(tipsRef, {
          tip: sanitizedTip,
          username,
          userId: currentUser.uid,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        });

        routeTipsCache.delete(routeId);
      }

      function updateTooltipContent(route) {
        if (!tooltip) {
          return;
        }

        applyTooltipColorScheme(route);

        const fragment = document.createDocumentFragment();
        const contentContainer = document.createElement('div');
        contentContainer.className = 'tooltip-content';
        fragment.appendChild(contentContainer);

        const ariaLines = [];

        const header = document.createElement('div');
        header.className = 'tooltip-header';
        header.appendChild(createTooltipCloseButton());

        const displayTitle = (route && (route.title || route.id) ? route.title || route.id : '').trim();
        const titleLine = document.createElement('strong');
        titleLine.className = 'tooltip-title';
        titleLine.textContent = displayTitle || 'Route details';
        header.appendChild(titleLine);
        contentContainer.appendChild(header);
        if (titleLine.textContent) {
          ariaLines.push(titleLine.textContent);
        }

        const medianGrade =
          route && typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)
            ? route.medianGrade
            : null;
        const gradeDisplay = formatGradeDisplay(medianGrade);
        const gradeBadge = document.createElement('div');
        gradeBadge.className = 'tooltip-grade-badge';
        gradeBadge.setAttribute('aria-hidden', 'true');
        gradeBadge.setAttribute('data-grade', gradeDisplay);
        const gradeValue = document.createElement('span');
        gradeValue.className = 'tooltip-grade-value';
        gradeValue.textContent = gradeDisplay;
        gradeBadge.appendChild(gradeValue);
        const isAscended = Boolean(route && ascendedRoutes.has(route.id));
        if (isAscended) {
          gradeBadge.classList.add('ascended');
        }
        const gradeStrokeWidth = Math.max(2, Math.round(calculateRouteStrokeWidth(route)) || 2);
        gradeBadge.style.setProperty('--tooltip-grade-stroke-width', `${gradeStrokeWidth}px`);
        tooltip.style.setProperty('--tooltip-grade-stroke-width', `${gradeStrokeWidth}px`);
        const gradeCluster = document.createElement('div');
        gradeCluster.className = 'tooltip-grade-cluster';
        gradeCluster.appendChild(gradeBadge);

        let actionsContainer = null;
        const ensureActionsContainer = () => {
          if (!actionsContainer) {
            actionsContainer = document.createElement('div');
            actionsContainer.className = 'tooltip-actions';
          }
          return actionsContainer;
        };

        if (currentUser) {
          const actionButton = document.createElement('button');
          actionButton.type = 'button';
          actionButton.className = 'tooltip-action-button ascend-toggle';
          actionButton.setAttribute('aria-pressed', isAscended ? 'true' : 'false');
          actionButton.textContent = isAscended ? 'Ascended' : 'Not ascended';
          actionButton.dataset.infoTarget = 'route-ascent';
          actionButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            toggleRouteAscent(route);
          });
          ensureActionsContainer().appendChild(actionButton);
        }

        const focusButton = document.createElement('button');
        focusButton.type = 'button';
        focusButton.className = 'tooltip-action-button focus-toggle';
        const isFocused = focusedRouteId === route.id;
        if (!isFocused) {
          focusButton.classList.add('is-quiet');
        }
        focusButton.textContent = isFocused ? 'Remove focus' : 'Focus';
        focusButton.setAttribute('aria-pressed', isFocused ? 'true' : 'false');
        focusButton.dataset.infoTarget = 'route-focus';
        focusButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleRouteFocus(route);
        });
        ensureActionsContainer().appendChild(focusButton);

        fragment.appendChild(gradeCluster);
        if (actionsContainer) {
          contentContainer.appendChild(actionsContainer);
        }
        ariaLines.push(`Grade: ${gradeDisplay}`);
        ariaLines.push(isAscended ? 'Ascended' : 'Not ascended');

        const infoContainer = document.createElement('div');
        infoContainer.className = 'tooltip-lines';
        contentContainer.appendChild(infoContainer);

        const appendInfoLine = (text, className = '') => {
          if (!text) {
            return;
          }
          const line = document.createElement('div');
          line.className = className ? `tooltip-line ${className}` : 'tooltip-line';
          line.textContent = text;
          infoContainer.appendChild(line);
          ariaLines.push(text);
        };

        const setterValue = typeof route.setter === 'string' ? route.setter : '';
        appendInfoLine(`Setter: ${setterValue.trim() || 'Unknown'}`);

        const descriptionText =
          typeof route.description === 'string' ? route.description.trim() : '';
        appendInfoLine(descriptionText ? `Description: ${descriptionText}` : 'Description: —');

        appendInfoLine(`Date set: ${formatDisplayDate(route.date_set)}`);

        if (currentUser) {
          const gradeControls = buildGradeControls(route);
          if (gradeControls) {
            contentContainer.appendChild(gradeControls);
          }
        }

        const tipsSection = createRouteTipsSection(route, ariaLines);
        contentContainer.appendChild(tipsSection.section);

        const baseAriaLines = [...ariaLines];
        const applyAriaLabel = (additionalLines = []) => {
          const extras = Array.isArray(additionalLines)
            ? additionalLines.filter((line) => typeof line === 'string' && line)
            : [];
          const combined = extras.length ? baseAriaLines.concat(extras) : [...baseAriaLines];
          if (combined.length) {
            tooltip.setAttribute('aria-label', combined.join('\n'));
          } else {
            tooltip.removeAttribute('aria-label');
          }
        };

        tooltip.replaceChildren(fragment);
        applyAriaLabel();

        const routeId = route && typeof route.id === 'string' ? route.id : '';
        void refreshRouteTips(routeId, {
          listElement: tipsSection.list,
          statusElement: tipsSection.status,
          applyAriaLabel,
        });

        if (tipsSection.form && tipsSection.textarea && tipsSection.submit) {
          tipsSection.form.addEventListener('submit', async (event) => {
            event.preventDefault();
            event.stopPropagation();

            const statusElement = tipsSection.status;
            if (statusElement) {
              statusElement.hidden = true;
              statusElement.textContent = '';
              statusElement.classList.remove('is-error');
            }

            if (!currentUser) {
              if (statusElement) {
                statusElement.textContent = 'Sign in to share tips.';
                statusElement.hidden = false;
                statusElement.classList.add('is-error');
              }
              applyAriaLabel(['Sign in to share tips.']);
              return;
            }

            const rawTip = tipsSection.textarea.value.trim();
            if (!rawTip) {
              if (statusElement) {
                statusElement.textContent = 'Enter a tip before submitting.';
                statusElement.hidden = false;
                statusElement.classList.add('is-error');
              }
              tipsSection.textarea.focus();
              applyAriaLabel(['Enter a tip before submitting.']);
              return;
            }

            if (!routeId) {
              if (statusElement) {
                statusElement.textContent = 'Unable to determine the selected route.';
                statusElement.hidden = false;
                statusElement.classList.add('is-error');
              }
              applyAriaLabel(['Unable to determine the selected route.']);
              return;
            }

            const trimmedTip = rawTip.slice(0, MAX_ROUTE_TIP_LENGTH);

            tipsSection.submit.disabled = true;
            tipsSection.textarea.disabled = true;

            try {
              await saveRouteTip(route, trimmedTip);
              tipsSection.textarea.value = '';
              await refreshRouteTips(routeId, {
                listElement: tipsSection.list,
                statusElement,
                applyAriaLabel,
                force: true,
              });
              if (statusElement) {
                statusElement.hidden = true;
                statusElement.textContent = '';
                statusElement.classList.remove('is-error');
              }
            } catch (error) {
              console.error('Failed to save route tip:', error);
              if (statusElement) {
                statusElement.textContent = 'Unable to save tip. Try again.';
                statusElement.hidden = false;
                statusElement.classList.add('is-error');
              }
              applyAriaLabel(['Unable to save tip. Try again.']);
            } finally {
              tipsSection.submit.disabled = false;
              tipsSection.textarea.disabled = false;
              tipsSection.textarea.focus();
            }
          });
        }
      }

      function positionTooltip() {
        if (!tooltip) {
          return null;
        }

        const tooltipWidth = tooltip.offsetWidth || 0;
        const tooltipHeight = tooltip.offsetHeight || 0;
        const halfWidth = tooltipWidth / 2;

        const minHorizontalMargin = 12;
        const minLeft = halfWidth + minHorizontalMargin;
        const maxLeft = window.innerWidth - halfWidth - minHorizontalMargin;
        const desiredLeft = window.innerWidth / 2;
        const clampedLeft = maxLeft < minLeft ? window.innerWidth / 2 : Math.min(maxLeft, Math.max(minLeft, desiredLeft));

        const minVerticalMargin = 12;
        const maxTop = window.innerHeight - tooltipHeight - minVerticalMargin;
        const safeMaxTop = maxTop < minVerticalMargin ? Math.max(minVerticalMargin, maxTop) : maxTop;
        const desiredTop = (window.innerHeight - tooltipHeight) / 2;
        const clampedTop = Math.min(safeMaxTop, Math.max(minVerticalMargin, desiredTop));

        tooltip.style.left = `${clampedLeft}px`;
        tooltip.style.top = `${clampedTop}px`;

        return { x: clampedLeft, y: clampedTop };
      }

      function showTooltip(route, clientX, clientY, options = {}) {
        if (!tooltip) {
          return;
        }

        const { pin = false } = options;

        if (route.id !== activeRouteId) {
          updateTooltipContent(route);
        }

        const position = positionTooltip();
        tooltip.classList.add('visible');
        tooltip.setAttribute('aria-hidden', 'false');
        activeRouteId = route.id;

        if (pin) {
          pinnedRouteId = route.id;
          pinnedPosition = position;
          tooltip.classList.add('pinned');
        } else {
          pinnedRouteId = null;
          pinnedPosition = null;
          tooltip.classList.remove('pinned');
        }
      }

      function hideTooltip(options = {}) {
        if (!tooltip) {
          return;
        }

        const { force = false } = options;

        if (!force && pinnedRouteId) {
          return;
        }

        tooltip.classList.remove('visible');
        tooltip.classList.remove('pinned');
        tooltip.setAttribute('aria-hidden', 'true');
        activeRouteId = null;
        pinnedRouteId = null;
        pinnedPosition = null;
      }

      function setRouteFocus(route, shouldFocus) {
        if (!route || typeof route.id !== 'string') {
          return;
        }

        const nextFocusedId = shouldFocus ? route.id : null;
        const shouldRestoreProgressionFocus = Boolean(
          shouldFocus && progressionList && isProgressionModalOpen()
        );

        if (focusedRouteId === nextFocusedId) {
          redraw();

          if (tooltip && tooltip.classList.contains('visible') && activeRouteId === route.id) {
            updateTooltipContent(route);
          }

          renderProgressionList();

          if (shouldRestoreProgressionFocus) {
            const entry = progressionList.querySelector(
              `[data-route-id="${route.id}"]`,
            );
            if (entry && typeof entry.focus === 'function') {
              entry.focus();
            }
          }
          return;
        }

        focusedRouteId = nextFocusedId;

        redraw();

        if (tooltip && tooltip.classList.contains('visible') && activeRouteId === route.id) {
          updateTooltipContent(route);
        }

        renderProgressionList();

        if (shouldRestoreProgressionFocus) {
          const entry = progressionList.querySelector(`[data-route-id="${route.id}"]`);
          if (entry && typeof entry.focus === 'function') {
            entry.focus();
          }
        }
      }

      function focusRoute(route) {
        const shouldCloseProgression = isProgressionModalOpen();
        setRouteFocus(route, true);

        if (shouldCloseProgression) {
          closeProgressionModal();
        }
      }

      function toggleRouteFocus(route) {
        if (!route || typeof route.id !== 'string') {
          return;
        }

        setRouteFocus(route, focusedRouteId !== route.id);
      }

      function extractClientPoint(event) {
        if (typeof event.clientX === 'number' && typeof event.clientY === 'number') {
          return { x: event.clientX, y: event.clientY };
        }

        const touch = event.touches?.[0] ?? event.changedTouches?.[0];
        if (touch) {
          return { x: touch.clientX, y: touch.clientY };
        }

        return null;
      }

      function distanceSquared(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return dx * dx + dy * dy;
      }

      function isPointNearSegment(px, py, x1, y1, x2, y2, padding = 0) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSquared = dx * dx + dy * dy;

        if (lengthSquared <= 0.0001) {
          return distanceSquared(px, py, x1, y1) <= padding * padding;
        }

        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));

        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        return distanceSquared(px, py, projX, projY) <= padding * padding;
      }

      function getRouteEntryAtClientPoint(clientX, clientY) {
        if (!Array.isArray(routeInteractionEntries) || routeInteractionEntries.length === 0) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        for (let index = routeInteractionEntries.length - 1; index >= 0; index -= 1) {
          const entry = routeInteractionEntries[index];
          if (!entry || !entry.route) {
            continue;
          }

          if (entry.type === 'circle') {
            const radius = Number(entry.r) || 0;
            if (radius > 0) {
              const distance = distanceSquared(x, y, Number(entry.cx), Number(entry.cy));
              if (distance <= radius * radius) {
                return { route: entry.route, canvasX: entry.cx, canvasY: entry.cy };
              }
            }
          } else if (entry.type === 'rect') {
            const left = Number(entry.left);
            const right = Number(entry.right);
            const top = Number(entry.top);
            const bottom = Number(entry.bottom);
            if (x >= left && x <= right && y >= top && y <= bottom) {
              return {
                route: entry.route,
                canvasX: (left + right) / 2,
                canvasY: (top + bottom) / 2,
              };
            }
          } else if (entry.type === 'segment') {
            const padding = Number(entry.padding) || 0;
            const x1 = Number(entry.x1);
            const y1 = Number(entry.y1);
            const x2 = Number(entry.x2);
            const y2 = Number(entry.y2);
            if (isPointNearSegment(x, y, x1, y1, x2, y2, padding)) {
              return {
                route: entry.route,
                canvasX: (x1 + x2) / 2,
                canvasY: (y1 + y2) / 2,
              };
            }
          }
        }

        return null;
      }

      function applyLocationFilter() {
        const desiredLocation = normalizeLocationName(currentLocation?.name);
        const fallbackLocation = normalizeLocationName(getDefaultLocation()?.name);
        const targetLocation = desiredLocation || fallbackLocation;

        if (!targetLocation) {
          routes = [...allRoutes];
        } else {
          routes = allRoutes.filter((route) => {
            const routeLocation =
              typeof route?.locationKey === 'string'
                ? route.locationKey
                : normalizeLocationName(route?.location);
            return routeLocation === targetLocation;
          });
        }

        if (focusedRouteId) {
          const hasFocusedRoute = routes.some((route) => route.id === focusedRouteId);
          if (!hasFocusedRoute) {
            focusedRouteId = null;
            hideTooltip({ force: true });
          }
        }

        synchroniseAscentsWithRoutes({ shouldRedraw: false });
        redraw();
      }

      async function loadRoutes() {
        try {
          const [routesSnapshot, medianMap, wallSnapshot] = await Promise.all([
            getDocs(collection(db, 'routes')),
            fetchMedianGrades(),
            getDocs(collection(db, WALL_COLLECTION)),
          ]);

          routeMedianGrades = medianMap instanceof Map ? medianMap : new Map();

          wallSettingsCache.clear();
          const hiddenWallKeys = new Set();
          let locationsChanged = false;
          wallSnapshot.forEach((docSnap) => {
            const data = docSnap.data();
            const settings = normalizeWallSettings(data);
            const normalizedId = normalizeWallKey(docSnap.id);
            const normalizedName = normalizeWallKey(data?.name);
            const normalizedKeyField = normalizeWallKey(data?.key);
            const isHidden = data?.hidden === true;

            if (normalizedId) {
              wallSettingsCache.set(normalizedId, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedId);
              }
            }

            if (normalizedName) {
              wallSettingsCache.set(normalizedName, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedName);
              }
            }

            if (normalizedKeyField) {
              wallSettingsCache.set(normalizedKeyField, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedKeyField);
              }
            }

            const { changed } = upsertLocation({
              key: typeof data?.key === 'string' ? data.key : docSnap.id,
              name: typeof data?.name === 'string' ? data.name : '',
              image: typeof data?.background_url === 'string' ? data.background_url : '',
              fallbackName: typeof data?.name === 'string' && data.name ? data.name : docSnap.id,
              hidden: isHidden,
            });

            if (changed) {
              locationsChanged = true;
            }
          });

          if (locationsChanged) {
            renderLocationOptions();
            synchronizeCurrentLocationReference();
          } else {
            ensureCurrentLocationVisible();
          }

          allRoutes = routesSnapshot.docs
            .map((docSnap) => {
              const data = docSnap.data();
              const normalizedPoints = Array.isArray(data.points)
                ? data.points
                    .map((point) => {
                      const x = Number(point?.x);
                      const y = Number(point?.y);
                      if (!Number.isFinite(x) || !Number.isFinite(y)) {
                        return null;
                      }
                      return { x, y };
                    })
                    .filter(Boolean)
                : [];

              const median = routeMedianGrades.get(docSnap.id);
              const medianGrade = typeof median === 'number' && Number.isFinite(median) ? median : null;
              const rawLocationValue = typeof data.location === 'string' ? data.location.trim() : '';
              const defaultLocation = getDefaultLocation();
              const normalizedLocation =
                normalizeLocationName(rawLocationValue) || normalizeLocationName(defaultLocation?.name);
              const displayLocation = rawLocationValue || defaultLocation?.name || '';

              if (normalizedLocation && hiddenWallKeys.has(normalizedLocation)) {
                return null;
              }

              const fallbackWallSettings = {
                pointDiameter: data.pointDiameter,
                rectangleWidth: data.rectangleWidth,
                rectangleHeight: data.rectangleHeight,
                gradeBarBaseHeight: data.gradeBarBaseHeight,
                gradeBarMaxHeight: data.gradeBarMaxHeight,
                gradeBarWidth: data.gradeBarWidth,
                transparency: data.transparency ?? data.gradeBarTransparency,
                unfocusedTransparency: data.unfocusedTransparency,
              };
              const wallSettings = resolveWallSettings(normalizedLocation, fallbackWallSettings);

              return {
                id: docSnap.id,
                strokeColor: typeof data.strokeColor === 'string' ? data.strokeColor : '#ffde59',
                points: normalizedPoints,
                title: typeof data.title === 'string' ? data.title : '',
                setter: typeof data.setter === 'string' ? data.setter : '',
                description: typeof data.description === 'string' ? data.description : '',
                date_set: normalizeDate(data.date_set),
                date_removed: normalizeDate(data.date_removed),
                location: displayLocation,
                locationKey: normalizedLocation,
                medianGrade,
                pathType: normalizePathType(data.pathType),
                pointDiameter: wallSettings.pointDiameter,
                rectangleWidth: wallSettings.rectangleWidth,
                rectangleHeight: wallSettings.rectangleHeight,
                gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
                gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
                gradeBarWidth: wallSettings.gradeBarWidth,
                gradeBarTransparency: wallSettings.gradeBarTransparency,
                unfocusedTransparency: wallSettings.unfocusedTransparency,
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              const nameA = (a.title || a.id).toLowerCase();
              const nameB = (b.title || b.id).toLowerCase();
              return nameA.localeCompare(nameB);
            });

          applyLocationFilter();
        } catch (error) {
          console.error('Failed to load routes:', error);
          allRoutes = [];
          routes = [];
          focusedRouteId = null;
          routeMedianGrades = new Map();
          renderProgressionList();
          redraw();
        }
      }

      async function toggleRouteAscent(route) {
        if (!currentUser) {
          return;
        }

        const username = await resolveAuthenticatedUsername();
        if (!username) {
          console.warn('Unable to mark ascent: user username missing.');
          return;
        }

        const userId = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to mark ascent: user ID missing.');
          return;
        }

        const routeId = route?.id;
        if (!routeId) {
          console.warn('Unable to mark ascent: route ID missing.');
          return;
        }
        const ascentRef = doc(db, 'ascents', userId);
        const isAscended = ascendedRoutes.has(routeId);
        const previousEntry = userAscentDetails.get(routeId) || {};
        const persistedGrade =
          typeof previousEntry.grade === 'number' && Number.isFinite(previousEntry.grade)
            ? previousEntry.grade
            : getUserGradeForRoute(routeId);
        const normalizedGrade =
          typeof persistedGrade === 'number' && Number.isFinite(persistedGrade)
            ? persistedGrade
            : null;

        try {
          if (isAscended) {
            await setDoc(
              ascentRef,
              {
                climber_uid: userId,
                climber_username: username,
                updatedAt: serverTimestamp(),
                routes: {
                  [routeId]: {
                    route_id: routeId,
                    climber_uid: userId,
                    climber_username: username,
                    grade: normalizedGrade,
                    ascended: false,
                    date_ascended: null,
                  },
                },
              },
              { merge: true },
            );

            userAscentDetails.set(routeId, {
              ascended: false,
              grade: normalizedGrade,
            });
          } else {
            const now = new Date().toISOString();
            await setDoc(
              ascentRef,
              {
                climber_uid: userId,
                climber_username: username,
                updatedAt: serverTimestamp(),
                routes: {
                  [routeId]: {
                    route_id: routeId,
                    date_ascended: now,
                    climber_uid: userId,
                    climber_username: username,
                    grade: normalizedGrade,
                    ascended: true,
                  },
                },
              },
              { merge: true },
            );
            userAscentDetails.set(routeId, {
              ascended: true,
              grade: normalizedGrade,
              dateAscended: now,
            });
          }

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          redraw();
        } catch (error) {
          console.error('Failed to update ascent:', error);
        }
      }

      function computeCanvasDimensions() {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const aspectRatio = Number.isFinite(canvasAspectRatio) && canvasAspectRatio > 0
          ? canvasAspectRatio
          : DEFAULT_CANVAS_ASPECT_RATIO;
        const enableScroll = viewportWidth <= 768 && viewportHeight > viewportWidth;

        if (enableScroll) {
          const height = viewportHeight;
          const width = Math.max(viewportWidth, Math.round(height * aspectRatio));
          return { width, height, enableScroll };
        }

        return {
          width: viewportWidth,
          height: viewportHeight,
          enableScroll: false,
        };
      }

      function resizeCanvas() {
        const { width, height, enableScroll } = computeCanvasDimensions();

        if (canvasContainer) {
          canvasContainer.classList.toggle('scrollable', enableScroll);
        }

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        if (canvasContainer) {
          if (enableScroll) {
            const maxScrollLeft = Math.max(0, width - window.innerWidth);
            if (!isHorizontalScrollEnabled) {
              canvasContainer.scrollLeft = Math.max(0, maxScrollLeft / 2);
            } else if (canvasContainer.scrollLeft > maxScrollLeft) {
              canvasContainer.scrollLeft = maxScrollLeft;
            }
          } else if (isHorizontalScrollEnabled) {
            canvasContainer.scrollLeft = 0;
          }
        }

        isHorizontalScrollEnabled = enableScroll;
        redraw();
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (backgroundReady && backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        routeInteractionEntries = [];
        let isFocusActive = false;
        let resolvedFocusRoute = null;
        let focusedRoutePointKeys = null;

        if (focusedRouteId) {
          resolvedFocusRoute = routes.find((route) => route.id === focusedRouteId) || null;
          if (resolvedFocusRoute) {
            isFocusActive = true;
            focusedRoutePointKeys = buildNormalizedPointKeySet(resolvedFocusRoute.points);
          } else {
            focusedRouteId = null;
          }
        }

        const shouldPreservePinned = Boolean(
          pinnedRouteId &&
            pinnedPosition &&
            (!isFocusActive || pinnedRouteId === focusedRouteId),
        );
        const pinnedRoute = shouldPreservePinned
          ? routes.find((route) => route.id === pinnedRouteId)
          : null;

        if (!shouldPreservePinned) {
          hideTooltip();
        } else if (!pinnedRoute) {
          hideTooltip({ force: true });
        }

        const overlapGroups = buildOverlappingShapeGroups(routes);
        const routeAlphaMap = new Map();

        routes.forEach((route) => {
          if (!route || typeof route.id !== 'string') {
            return;
          }
          const isFocused = isFocusActive && route.id === focusedRouteId;
          const routeAlpha = isFocused
            ? 1
            : isFocusActive
              ? normalizeUnfocusedTransparency(route.unfocusedTransparency)
              : 1;
          routeAlphaMap.set(route.id, routeAlpha);
        });

        const handledOverlapKeys = new Set();

        routes.forEach((route) => {
          const isFocused = isFocusActive && route.id === focusedRouteId;
          const routeAlpha = routeAlphaMap.get(route?.id) ?? 1;
          const omitOverlaps = !isFocused && focusedRoutePointKeys?.size ? focusedRoutePointKeys : null;
          drawRoute(route, {
            alpha: routeAlpha,
            omitOverlappingPointKeys: omitOverlaps,
            overlapGroups,
            handledOverlapKeys,
            routeAlphaMap,
            isFocused,
          });
        });
        if (pinnedRoute && tooltip) {
          updateTooltipContent(pinnedRoute);
          tooltip.classList.add('visible');
          tooltip.classList.add('pinned');
          tooltip.setAttribute('aria-hidden', 'false');
          const updatedPosition = positionTooltip();
          if (updatedPosition) {
            pinnedPosition = updatedPosition;
          }
        }
      }

      function clamp(value, min, max) {
        if (!Number.isFinite(value)) {
          return min;
        }
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }

      function createNormalizedPointKey(x, y) {
        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          return null;
        }

        const clampedX = Math.min(Math.max(x, 0), 1);
        const clampedY = Math.min(Math.max(y, 0), 1);
        const scaledX = Math.round(clampedX * 10000);
        const scaledY = Math.round(clampedY * 10000);
        return `${scaledX}:${scaledY}`;
      }

      function buildNormalizedPointKeySet(points = []) {
        const keys = new Set();
        if (!Array.isArray(points) || !points.length) {
          return keys;
        }

        points.forEach((point) => {
          const x = Number(point?.x);
          const y = Number(point?.y);
          const key = createNormalizedPointKey(x, y);
          if (key) {
            keys.add(key);
          }
        });

        return keys;
      }

      function getRouteStrokeColor(route) {
        const rawColor = route?.strokeColor;
        if (typeof rawColor === 'string' && rawColor.trim()) {
          return rawColor;
        }
        return '#ffde59';
      }

      function getGradeColorForValue(value) {
        if (typeof value !== 'number' || !Number.isFinite(value)) {
          return null;
        }

        const rounded = Math.round(value);
        if (!Number.isFinite(rounded)) {
          return null;
        }

        const clamped = Math.min(Math.max(rounded, MIN_GRADE_VALUE), MAX_GRADE_VALUE);
        return GRADE_COLOR_MAP.get(clamped) ?? null;
      }

      function getRouteGradeColor(route) {
        if (!route) {
          return null;
        }

        let grade =
          typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)
            ? route.medianGrade
            : null;

        if (grade === null && typeof route.id === 'string') {
          const userGrade = getUserGradeForRoute(route.id);
          if (typeof userGrade === 'number' && Number.isFinite(userGrade)) {
            grade = userGrade;
          }
        }

        return getGradeColorForValue(grade);
      }

      function getRouteDisplayColor(route) {
        if (viewMode === VIEW_MODE_GRADE_COLORS) {
          return getRouteGradeColor(route) ?? getRouteStrokeColor(route);
        }
        return getRouteStrokeColor(route);
      }

      function createOverlapGroupKey(pathType, pointKey) {
        if (!pathType || !pointKey) {
          return null;
        }
        return `${pathType}::${pointKey}`;
      }

      function buildOverlappingShapeGroups(routeList = []) {
        const groups = new Map();

        if (!Array.isArray(routeList) || !routeList.length) {
          return groups;
        }

        routeList.forEach((route) => {
          if (!route) {
            return;
          }

          const pathType = normalizePathType(route.pathType);
          if (pathType !== PATH_TYPE_POINT && pathType !== PATH_TYPE_RECTANGLE) {
            return;
          }

          const points = Array.isArray(route.points) ? route.points : [];
          if (!points.length) {
            return;
          }

          const strokeColor = getRouteStrokeColor(route);
          const normalizedPointDiameter = normalizePointDiameter(route.pointDiameter);
          const normalizedRectangleWidth = normalizeRectangleSize(
            route.rectangleWidth,
            DEFAULT_RECTANGLE_WIDTH,
          );
          const normalizedRectangleHeight = normalizeRectangleSize(
            route.rectangleHeight,
            DEFAULT_RECTANGLE_HEIGHT,
          );

          points.forEach((point) => {
            const normalizedX = Number(point?.x);
            const normalizedY = Number(point?.y);
            const pointKey = createNormalizedPointKey(normalizedX, normalizedY);
            if (!pointKey) {
              return;
            }

            const groupKey = createOverlapGroupKey(pathType, pointKey);
            if (!groupKey) {
              return;
            }

            if (!groups.has(groupKey)) {
              groups.set(groupKey, {
                pathType,
                entries: [],
              });
            }

            const group = groups.get(groupKey);
            group.entries.push({
              routeId: route.id,
              color: strokeColor,
              pointDiameter: normalizedPointDiameter,
              rectangleWidth: normalizedRectangleWidth,
              rectangleHeight: normalizedRectangleHeight,
            });
          });
        });

        for (const [key, group] of groups) {
          if (!group || !Array.isArray(group.entries) || group.entries.length <= 1) {
            groups.delete(key);
          }
        }

        return groups;
      }

      function drawOverlappingPointGroup(ctx, center, entries) {
        if (!ctx || !center || !entries || entries.length <= 1) {
          return;
        }

        const total = entries.length;
        const radii = entries.map((entry) => Math.max(1, Number(entry.pointDiameter) / 2));
        const radius = Math.max(...radii, 4);
        const step = (Math.PI * 2) / total;
        const startAngle = -Math.PI / 2;

        ctx.save();
        ctx.setLineDash([]);
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';

        entries.forEach((entry, index) => {
          const strokeWidth = Math.max(2, Math.round(Number(entry.pointDiameter) / 10) || 2);
          const angleStart = startAngle + step * index;
          const angleEnd = angleStart + step;

          ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = entry.color || '#ffde59';
          ctx.beginPath();
          ctx.arc(center.x, center.y, radius, angleStart, angleEnd);
          ctx.stroke();
        });

        ctx.restore();
      }

      function drawOverlappingRectangleGroup(ctx, center, entries) {
        if (!ctx || !center || !entries || entries.length <= 1) {
          return;
        }

        const widths = entries.map((entry) => Math.max(1, Number(entry.rectangleWidth) || 0));
        const heights = entries.map((entry) => Math.max(1, Number(entry.rectangleHeight) || 0));
        const width = Math.max(...widths, 4);
        const height = Math.max(...heights, 4);
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const perimeter = 2 * (width + height);

        if (!Number.isFinite(perimeter) || perimeter <= 0) {
          return;
        }

        const segmentLength = perimeter / entries.length;
        const edges = [
          { length: width, startX: center.x - halfWidth, startY: center.y - halfHeight, dx: 1, dy: 0 },
          { length: height, startX: center.x + halfWidth, startY: center.y - halfHeight, dx: 0, dy: 1 },
          { length: width, startX: center.x + halfWidth, startY: center.y + halfHeight, dx: -1, dy: 0 },
          { length: height, startX: center.x - halfWidth, startY: center.y + halfHeight, dx: 0, dy: -1 },
        ];
        const edgeCount = edges.length;

        let offset = 0;

        entries.forEach((entry) => {
          let localOffset = offset % perimeter;
          if (localOffset < 0) {
            localOffset += perimeter;
          }

          let edgeIndex = 0;
          while (localOffset >= edges[edgeIndex].length && edgeIndex < edgeCount - 1) {
            localOffset -= edges[edgeIndex].length;
            edgeIndex += 1;
          }

          let currentX = edges[edgeIndex].startX + edges[edgeIndex].dx * localOffset;
          let currentY = edges[edgeIndex].startY + edges[edgeIndex].dy * localOffset;
          let remaining = segmentLength;

          ctx.save();
          ctx.setLineDash([]);
          ctx.lineCap = 'butt';
          ctx.lineJoin = 'miter';
          ctx.lineWidth = Math.max(
            2,
            Math.round(Math.max(Number(entry.rectangleWidth) || 0, Number(entry.rectangleHeight) || 0) / 10) || 2,
          );
          ctx.strokeStyle = entry.color || '#ffde59';
          ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;

          while (remaining > 0) {
            const edge = edges[edgeIndex];
            const available = edge.length - localOffset;
            const step = Math.min(remaining, available);
            const nextOffset = localOffset + step;
            const nextX = edge.startX + edge.dx * nextOffset;
            const nextY = edge.startY + edge.dy * nextOffset;

            ctx.beginPath();
            ctx.moveTo(currentX, currentY);
            ctx.lineTo(nextX, nextY);
            ctx.stroke();

            remaining -= step;
            currentX = nextX;
            currentY = nextY;
            localOffset = 0;
            edgeIndex = (edgeIndex + 1) % edgeCount;
          }

          ctx.restore();

          offset += segmentLength;
          if (offset >= perimeter) {
            offset -= perimeter;
          }
        });
      }

      function calculateRouteStrokeWidth(route) {
        const pathType = normalizePathType(route?.pathType);
        if (pathType === PATH_TYPE_POINT) {
          const diameter = normalizePointDiameter(route?.pointDiameter);
          return Math.max(2, Math.round(diameter / 10));
        }
        if (pathType === PATH_TYPE_RECTANGLE) {
          const width = normalizeRectangleSize(route?.rectangleWidth, DEFAULT_RECTANGLE_WIDTH);
          const height = normalizeRectangleSize(route?.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT);
          return Math.max(2, Math.round(Math.max(width, height) / 10));
        }
        return 10;
      }

      function drawRoute(route, options = {}) {
        const strokeColor = getRouteDisplayColor(route);
        const points = Array.isArray(route.points) ? route.points : [];

        const alphaValue = Number(options.alpha);
        const routeAlpha = Number.isFinite(alphaValue)
          ? Math.min(Math.max(alphaValue, 0), 1)
          : 1;

        const omitOverlapKeys =
          options?.omitOverlappingPointKeys instanceof Set ? options.omitOverlappingPointKeys : null;
        const overlapGroups =
          options?.overlapGroups instanceof Map ? options.overlapGroups : null;
        const handledOverlapKeys =
          options?.handledOverlapKeys instanceof Set ? options.handledOverlapKeys : null;
        const routeAlphaMap =
          options?.routeAlphaMap instanceof Map ? options.routeAlphaMap : null;
        const isFocusedRoute = Boolean(options?.isFocused);

        if (!points.length) {
          return;
        }

        const pathType = normalizePathType(route.pathType);
        const supportsOverlapPattern =
          pathType === PATH_TYPE_POINT || pathType === PATH_TYPE_RECTANGLE;
        const shouldFilterOverlaps =
          omitOverlapKeys && omitOverlapKeys.size > 0 && supportsOverlapPattern;

        const pathPoints = [];
        const visiblePoints = [];
        const interactionRegions = [];

        points.forEach((point) => {
          const normalizedX = Number(point?.x);
          const normalizedY = Number(point?.y);
          if (!Number.isFinite(normalizedX) || !Number.isFinite(normalizedY)) {
            return;
          }

          const scaledPoint = {
            x: normalizedX * canvas.width,
            y: normalizedY * canvas.height,
          };
          pathPoints.push(scaledPoint);

          const pointKey = supportsOverlapPattern
            ? createNormalizedPointKey(normalizedX, normalizedY)
            : null;

          if (shouldFilterOverlaps && pointKey && omitOverlapKeys.has(pointKey)) {
            return;
          }

          const overlapKey =
            pointKey && overlapGroups ? createOverlapGroupKey(pathType, pointKey) : null;
          const overlapGroup =
            overlapKey && overlapGroups ? overlapGroups.get(overlapKey) : null;

          if (
            overlapGroup &&
            Array.isArray(overlapGroup.entries) &&
            overlapGroup.entries.length > 1 &&
            !isFocusedRoute
          ) {
            if (handledOverlapKeys && handledOverlapKeys.has(overlapKey)) {
              return;
            }

            const entriesWithAlpha = overlapGroup.entries.map((entry) => {
              const mappedAlpha = routeAlphaMap?.get(entry.routeId);
              const entryAlpha = Number.isFinite(mappedAlpha) ? mappedAlpha : 1;
              return { ...entry, alpha: entryAlpha };
            });

            if (handledOverlapKeys) {
              handledOverlapKeys.add(overlapKey);
            }

            if (pathType === PATH_TYPE_POINT) {
              drawOverlappingPointGroup(ctx, scaledPoint, entriesWithAlpha);
            } else if (pathType === PATH_TYPE_RECTANGLE) {
              drawOverlappingRectangleGroup(ctx, scaledPoint, entriesWithAlpha);
            }
            return;
          }

          visiblePoints.push(scaledPoint);
        });

        if (!pathPoints.length) {
          return;
        }

        const pointDiameter = normalizePointDiameter(route.pointDiameter);
        const rectangleWidth = normalizeRectangleSize(route.rectangleWidth, DEFAULT_RECTANGLE_WIDTH);
        const rectangleHeight = normalizeRectangleSize(route.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT);

        ctx.save();
        ctx.globalAlpha = routeAlpha;
        if (pathType === PATH_TYPE_POINT) {
          const circleRadius = Math.max(1, pointDiameter / 2);
          const strokeWidth = Math.max(2, Math.round(pointDiameter / 10));
          if (visiblePoints.length) {
            const path = new Path2D();

            visiblePoints.forEach((point) => {
              path.moveTo(point.x + circleRadius, point.y);
              path.arc(point.x, point.y, circleRadius, 0, Math.PI * 2);
            });

            ctx.save();
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke(path);
            ctx.restore();

            const padding = Math.max(4, strokeWidth / 2);
            visiblePoints.forEach((point) => {
              interactionRegions.push({
                type: 'circle',
                cx: point.x,
                cy: point.y,
                r: circleRadius + padding,
              });
            });
          }
        } else if (pathType === PATH_TYPE_RECTANGLE) {
          const rectWidth = Math.max(1, rectangleWidth);
          const rectHeight = Math.max(1, rectangleHeight);
          const halfWidth = Math.max(1, rectWidth / 2);
          const halfHeight = Math.max(1, rectHeight / 2);
          const strokeWidth = Math.max(2, Math.round(Math.max(rectWidth, rectHeight) / 10));
          if (visiblePoints.length) {
            const path = new Path2D();

            visiblePoints.forEach((point) => {
              path.rect(point.x - halfWidth, point.y - halfHeight, rectWidth, rectHeight);
            });

            ctx.save();
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke(path);
            ctx.restore();

            const padding = Math.max(4, strokeWidth / 2);
            visiblePoints.forEach((point) => {
              interactionRegions.push({
                type: 'rect',
                left: point.x - halfWidth - padding,
                right: point.x + halfWidth + padding,
                top: point.y - halfHeight - padding,
                bottom: point.y + halfHeight + padding,
              });
            });
          }
        } else if (pathPoints.length >= 2) {
          const path = new Path2D();
          path.moveTo(pathPoints[0].x, pathPoints[0].y);

          for (let i = 0; i < pathPoints.length - 1; i++) {
            const p0 = i === 0 ? pathPoints[0] : pathPoints[i - 1];
            const p1 = pathPoints[i];
            const p2 = pathPoints[i + 1];
            const p3 = i + 2 < pathPoints.length ? pathPoints[i + 2] : pathPoints[i + 1];

            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;

            path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
          }

          ctx.save();
          const strokeWidth = Math.max(6, Math.round(calculateRouteStrokeWidth(route)) || 6);
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = strokeColor;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.stroke(path);
          ctx.restore();

          const padding = Math.max(6, strokeWidth / 2 + 4);
          for (let i = 0; i < pathPoints.length - 1; i += 1) {
            const start = pathPoints[i];
            const end = pathPoints[i + 1];
            if (!start || !end) {
              continue;
            }

            interactionRegions.push({
              type: 'segment',
              x1: start.x,
              y1: start.y,
              x2: end.x,
              y2: end.y,
              padding,
            });
          }
        }
        ctx.restore();

        if (interactionRegions.length) {
          interactionRegions.forEach((region) => {
            if (!region) {
              return;
            }
            routeInteractionEntries.push({
              ...region,
              route,
            });
          });
        }
      }

      function handlePointerMove(event) {
        if ('pointerType' in event) {
          const pointerType = event.pointerType;
          if (pointerType && pointerType !== 'mouse' && pointerType !== 'pen') {
            canvas.style.cursor = '';
            return;
          }
        }

        const entry = getRouteEntryAtClientPoint(event.clientX, event.clientY);

        if (entry && entry.route) {
          canvas.style.cursor = 'pointer';
        } else {
          canvas.style.cursor = '';
          if (!pinnedRouteId) {
            hideTooltip();
          }
        }
      }

      function handlePointerLeave() {
        canvas.style.cursor = '';
        if (!pinnedRouteId) {
          hideTooltip();
        }
      }

      function handleCanvasPointerDown(event) {
        const point = extractClientPoint(event);
        if (!point) {
          return;
        }

        const entry = getRouteEntryAtClientPoint(point.x, point.y);

        if (entry && entry.route) {
          showTooltip(entry.route, point.x, point.y, { pin: true });
        } else if (!pinnedRouteId) {
          hideTooltip({ force: true });
        }
      }

      function handleDocumentPointerDown(event) {
        if (!tooltip) {
          return;
        }

        if (event.target === canvas) {
          return;
        }

        if (tooltip.contains(event.target)) {
          return;
        }

        if (pinnedRouteId) {
          return;
        }

        hideTooltip({ force: true });
      }

      if ('PointerEvent' in window) {
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerleave', handlePointerLeave);
        canvas.addEventListener('pointerdown', handleCanvasPointerDown);
        document.addEventListener('pointerdown', handleDocumentPointerDown);
      } else {
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseleave', handlePointerLeave);
        canvas.addEventListener('mousedown', handleCanvasPointerDown);
        canvas.addEventListener('touchstart', handleCanvasPointerDown);
        document.addEventListener('mousedown', handleDocumentPointerDown);
        document.addEventListener('touchstart', handleDocumentPointerDown);
      }

      window.addEventListener('resize', resizeCanvas);

      if (backgroundImage.complete) {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      } else {
        resizeCanvas();
      }
    </script>
  </body>
</html>
