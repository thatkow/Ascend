<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ascend</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #000;
      --wall-background: url('./location/New Wall.jpg');
      background-image: var(--wall-background);
      background-position: center;
      background-size: 100% 100%;
      background-repeat: no-repeat;
      background-attachment: fixed;
      color: #fff;
      overflow: hidden;
    }

    .hidden {
      display: none !important;
    }

    .canvas-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .canvas-container.scrollable {
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
    }

    .tutorial-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      background-color: transparent;
      backdrop-filter: none;
      z-index: 30;
    }

    .tutorial-overlay.is-bottom-aligned {
      align-items: flex-end;
    }

    .tutorial-overlay.is-bottom-aligned .tutorial-card {
      margin-bottom: clamp(1.5rem, 8vh, 4rem);
    }

    .tutorial-card {
      width: min(520px, 100%);
      background: rgba(12, 18, 15, 0.95);
      border-radius: 1rem;
      padding: 1.75rem;
      display: flex;
      flex-direction: column;
      gap: 1.15rem;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(126, 217, 87, 0.2);
    }

    .tutorial-progress {
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(126, 217, 87, 0.8);
    }

    .tutorial-title {
      font-size: 1.35rem;
      font-weight: 700;
      line-height: 1.3;
    }

    .tutorial-description {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      color: rgba(248, 250, 252, 0.92);
      font-size: 0.98rem;
      line-height: 1.55;
    }

    .tutorial-description p {
      margin: 0;
    }

    .tutorial-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-end;
    }

    .tutorial-button {
      border-radius: 999px;
      border: none;
      padding: 0.65rem 1.4rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
        color 0.2s ease, border-color 0.2s ease;
    }

    .tutorial-primary {
      background: #7ed957;
      color: #0c1a07;
      box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
    }

    .tutorial-primary:hover,
    .tutorial-primary:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 18px 30px rgba(126, 217, 87, 0.35);
      outline: none;
    }

    .tutorial-secondary {
      background: rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 0.85);
    }

    .tutorial-secondary:hover,
    .tutorial-secondary:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 16px 34px rgba(0, 0, 0, 0.4);
      outline: none;
    }

    .tutorial-highlight {
      position: relative;
      z-index: 50;
      outline: 3px solid rgba(126, 217, 87, 0.9);
      border-radius: 1rem;
    }

    .tutorial-illuminated {
      animation: tutorial-illuminate 1.2s ease-in-out infinite;
    }

    .tutorial-pointer {
      position: fixed;
      width: 102px;
      height: 162px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 60;
      transform: translate(-50%, 0);
    }

    .tutorial-pointer.hidden {
      display: none;
    }

    .tutorial-pointer svg {
      width: 100%;
      height: 100%;
      filter: drop-shadow(0 10px 18px rgba(0, 0, 0, 0.45));
      animation: tutorial-pointer-bounce 1.05s ease-in-out infinite;
    }

    @media (max-width: 768px) {
      .tutorial-pointer {
        width: 51px;
        height: 81px;
      }
    }

    @keyframes tutorial-pointer-bounce {
      0%,
      100% {
        transform: translateY(4px);
      }
      50% {
        transform: translateY(-6px);
      }
    }

    @keyframes tutorial-illuminate {
      0%,
      100% {
        box-shadow: 0 0 0 6px rgba(126, 217, 87, 0.7), 0 0 28px rgba(126, 217, 87, 0.55);
      }
      50% {
        box-shadow: 0 0 0 10px rgba(255, 140, 66, 0.85), 0 0 42px rgba(255, 140, 66, 0.75);
      }
    }

    .sidebar-actions {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    .panel-icon-button {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(0, 0, 0, 0.55);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease,
        border-color 0.2s ease;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      padding: 0;
    }

    .panel-icon-button svg {
      width: 16px;
      height: 16px;
      display: block;
    }

    .panel-toggle-button {
      background: rgba(255, 255, 255, 0.25);
      color: #111;
      border-color: rgba(255, 255, 255, 0.55);
    }

    .panel-toggle-button:hover,
    .panel-toggle-button:focus-visible {
      background: rgba(255, 255, 255, 0.35);
      color: #0a0a0a;
    }

    .panel-toggle-icon {
      display: none;
      width: 16px;
      height: 16px;
    }

    .panel-toggle-icon svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .control-panel[data-expanded='true'] #panelToggle .panel-toggle-icon-close {
      display: block;
    }

    .control-panel[data-expanded='false'] #panelToggle .panel-toggle-icon-open {
      display: block;
    }

    .panel-icon-button:hover,
    .panel-icon-button:focus-visible {
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.18);
      border-color: rgba(255, 255, 255, 0.45);
      outline: none;
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.4);
    }

    .panel-icon-button:focus-visible {
      box-shadow: 0 0 0 4px rgba(126, 217, 87, 0.25), 0 12px 26px rgba(0, 0, 0, 0.4);
    }

    .panel-icon-button.info-button {
      border: 2px solid rgba(255, 255, 255, 0.35);
      background: linear-gradient(135deg, rgba(36, 36, 36, 0.9), rgba(92, 92, 92, 0.45));
      color: #f8fafc;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease,
        border-color 0.2s ease, color 0.2s ease;
    }

    .panel-icon-button.info-button:hover,
    .panel-icon-button.info-button:focus-visible {
      border-color: rgba(255, 255, 255, 0.55);
      background: linear-gradient(135deg, rgba(60, 60, 60, 0.95), rgba(120, 120, 120, 0.45));
    }

    .panel-icon-button.info-button.is-active {
      border-color: rgba(126, 217, 87, 0.6);
      background: #7ed957;
      color: #0c1905;
      box-shadow: 0 8px 22px rgba(126, 217, 87, 0.35);
    }

    .panel-icon-button.info-button.is-active:hover,
    .panel-icon-button.info-button.is-active:focus-visible {
      border-color: rgba(126, 217, 87, 0.9);
      background: #8ae064;
      color: #0c1905;
    }

    .panel-icon-button.drawing-toggle[aria-pressed='true'] {
      background: #15803d;
      border-color: rgba(255, 255, 255, 0.45);
      color: #0d1405;
      box-shadow: 0 16px 32px rgba(21, 128, 61, 0.35);
    }

    .panel-icon-button.drawing-toggle[aria-pressed='true']:hover,
    .panel-icon-button.drawing-toggle[aria-pressed='true']:focus-visible {
      background: #1c8f48;
      color: #031406;
    }

    .info-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .info-popover {
      position: absolute;
      top: 0;
      left: calc(100% + 0.75rem);
      transform: none;
      width: min(240px, 70vw);
      padding: 0.9rem 1rem;
      border-radius: 0.75rem;
      background: rgba(0, 0, 0, 0.85);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.8rem;
      line-height: 1.4;
      text-align: left;
      z-index: 20;
    }

    .info-popover p {
      color: rgba(255, 255, 255, 0.85);
    }

    .welcome-callout {
      position: fixed;
      z-index: 60;
      min-width: min(280px, 80vw);
      max-width: min(360px, 80vw);
      padding: 1rem 1.1rem;
      border-radius: 0.85rem;
      background: rgba(10, 16, 11, 0.94);
      border: 1px solid rgba(126, 217, 87, 0.55);
      box-shadow: 0 18px 42px rgba(0, 0, 0, 0.45);
      color: #f8fafc;
      line-height: 1.5;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      pointer-events: auto;
    }

    .welcome-callout::before {
      content: '';
      position: absolute;
      width: 0;
      height: 0;
      border: 10px solid transparent;
    }

    .welcome-callout[data-arrow='top']::before {
      top: -20px;
      left: var(--callout-arrow-offset, 28px);
      border-bottom-color: rgba(10, 16, 11, 0.94);
    }

    .welcome-callout[data-arrow='bottom']::before {
      bottom: -20px;
      left: var(--callout-arrow-offset, 28px);
      border-top-color: rgba(10, 16, 11, 0.94);
    }

    .welcome-callout strong {
      font-size: 0.95rem;
      letter-spacing: 0.01em;
    }

    .welcome-callout p {
      font-size: 0.85rem;
      color: rgba(248, 250, 252, 0.9);
    }

    .welcome-callout p + p {
      margin-top: 0.35rem;
    }

    canvas {
      display: block;
      height: 100%;
      width: auto;
      min-width: 100%;
      cursor: grab;
      transition: cursor 0.15s ease;
    }

    canvas[data-drawing-enabled='true'] {
      cursor: crosshair;
    }

    canvas[data-drawing-enabled='true'][data-pan-modifier='true'] {
      cursor: grab;
    }

    canvas.is-panning {
      cursor: grabbing;
    }

    .control-panel {
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      display: flex;
      align-items: stretch;
      gap: 0;
      z-index: 12;
      --toggle-visible-width: 36px;
      transition: transform 0.25s ease;
      transform: translateX(0);
    }

    .panel-sidebar {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.85rem;
      align-self: center;
      order: 1;
      padding: 1rem 0.5rem;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 0.85rem 0 0 0.85rem;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
    }

    .panel-tablist {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.6rem;
    }

    .panel-tab {
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .panel-tab:hover,
    .panel-tab:focus-visible {
      background: rgba(255, 255, 255, 0.22);
    }

    .panel-tab[aria-selected='true'] {
      background: rgba(255, 255, 255, 0.85);
      color: #111;
      border-color: rgba(255, 255, 255, 0.75);
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.4);
    }

    .panel-sidebar::after {
      content: '';
      display: block;
      width: 100%;
      height: 0.5rem;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: stretch;
      width: min(320px, 92vw);
      max-width: 360px;
      height: 100vh;
      padding: 2rem 1.25rem 4rem;
      background: rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(8px);
      border-radius: 1rem 0 0 1rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      overflow-y: auto;
      transition: box-shadow 0.25s ease, background 0.25s ease;
      order: 2;
    }

    .control-panel[data-expanded='false'] {
      transform: translateX(calc(100% - var(--toggle-visible-width)));
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .control-section {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .control-section-title {
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.75);
    }

    .control-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.85rem;
    }

    [data-help-text] {
      position: relative;
    }

    .help-tooltip {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 0.4rem;
      padding: 0.45rem 0.6rem;
      border-radius: 0.75rem;
      background: rgba(15, 15, 15, 0.94);
      border: 1px solid rgba(126, 217, 87, 0.45);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.72rem;
      line-height: 1.4;
      max-width: 260px;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      z-index: 30;
    }

    [data-help-text].showing-help > .help-tooltip {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .control-field span {
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .control-field input,
    .control-field select,
    .control-field textarea {
      border-radius: 0.65rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(0, 0, 0, 0.35);
      color: inherit;
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
    }

    .control-field textarea {
      min-height: 4.5rem;
      resize: vertical;
    }

    .control-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.65rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(0, 0, 0, 0.35);
      font-size: 0.85rem;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .control-toggle span {
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .control-toggle input[type='checkbox'] {
      width: 1.4rem;
      height: 1.4rem;
      flex-shrink: 0;
      accent-color: #7ed957;
    }

    .control-toggle.is-disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .control-toggle.is-disabled input[type='checkbox'] {
      pointer-events: none;
    }

    .tab-panels {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .tab-panel {
      display: none;
      flex-direction: column;
      gap: 1rem;
    }

    .tab-panel[aria-hidden='false'] {
      display: flex;
    }

    .control-row {
      display: flex;
      gap: 0.5rem;
      align-items: flex-end;
    }

    .control-row .control-field {
      flex: 1;
    }

    .controls input[type="color"] {
      width: 100%;
      min-height: 2.5rem;
      border: none;
      padding: 0.25rem;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 0.65rem;
    }

    .color-wheel-toggle {
      background: rgba(255, 255, 255, 0.2);
      color: #111;
      margin-top: 0.5rem;
    }

    .color-wheel-toggle:hover,
    .color-wheel-toggle:focus-visible {
      background: rgba(255, 255, 255, 0.35);
      outline: none;
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(255, 255, 255, 0.2);
    }

    .color-wheel {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-top: 0.75rem;
      padding: 0.75rem;
      border-radius: 0.75rem;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .color-wheel-canvas-wrapper {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #colorWheelCanvas {
      width: min(220px, 100%);
      height: auto;
      max-width: 100%;
      border-radius: 50%;
      touch-action: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
      cursor: crosshair;
    }

    #colorWheelCanvas:focus-visible {
      outline: 2px solid rgba(126, 217, 87, 0.65);
      outline-offset: 4px;
    }

    .color-wheel-marker {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid #fff;
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.4);
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    .color-lightness-control {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .color-lightness-control label {
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .color-lightness-control input[type='range'] {
      width: 100%;
      appearance: none;
      height: 0.65rem;
      border-radius: 999px;
      background: linear-gradient(90deg, #000, #fff);
      cursor: pointer;
    }

    .color-lightness-control input[type='range']::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid rgba(0, 0, 0, 0.6);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .color-lightness-control input[type='range']::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid rgba(0, 0, 0, 0.6);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .color-wheel-preview {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
    }

    .color-wheel-swatch {
      width: 1.8rem;
      height: 1.8rem;
      border-radius: 0.4rem;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: #ffde59;
    }

    .color-wheel-hint {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.7);
      line-height: 1.4;
    }

    .controls button {
      border: none;
      border-radius: 0.65rem;
      padding: 0.55rem 0.85rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
      color: #111;
      text-align: center;
    }

    .location-button {
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 0.85rem;
      padding: 0.65rem 1rem;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
      color: #fff;
      backdrop-filter: blur(6px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      width: 100%;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.45rem;
      margin-bottom: 0.75rem;
    }

    #createWallButton {
      background: #7ed957;
      color: #0d2600;
    }

    .delete-wall-button {
      background: rgba(255, 116, 116, 0.9);
      color: #1a0b0b;
    }

    .location-button:hover,
    .location-button:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
      outline: none;
    }

    .global-actions {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: stretch;
      justify-content: flex-start;
      width: 100%;
    }

    .global-action-button {
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 999px;
      padding: 0.6rem 1.25rem;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
      color: #fff;
      backdrop-filter: blur(6px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.45rem;
      width: 100%;
    }

    .button-icon {
      font-size: 1.05rem;
      line-height: 1;
    }

    .button-label {
      line-height: 1;
    }

    .global-action-button:hover,
    .global-action-button:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
      outline: none;
    }

    #climberViewButton {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    #personalDashboardButton {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    #signOutButton {
      background: rgba(255, 116, 116, 0.9);
      color: #111;
    }

    #locationButton {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .location-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(3px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1rem;
      z-index: 30;
    }

    .location-modal.hidden {
      display: none !important;
    }

    .location-modal-content {
      background: rgba(18, 18, 18, 0.95);
      border-radius: 1.25rem;
      width: min(720px, 92vw);
      max-height: 90vh;
      padding: 1.5rem;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .location-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .location-modal-title {
      font-size: 1.35rem;
      font-weight: 700;
    }

    .location-modal-close {
      border: none;
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.4rem;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    .location-modal-close:hover,
    .location-modal-close:focus-visible {
      transform: translateY(-1px);
      background: rgba(255, 255, 255, 0.25);
      outline: none;
    }

    .location-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
    }

    .location-option {
      border: none;
      border-radius: 1rem;
      padding: 0;
      background: rgba(255, 255, 255, 0.1);
      color: inherit;
      cursor: pointer;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      text-align: left;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .location-option:hover,
    .location-option:focus-visible {
      transform: translateY(-4px);
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.4);
      outline: none;
      background: rgba(255, 255, 255, 0.18);
    }

    .location-option[aria-current='true'] {
      box-shadow: 0 0 0 3px rgba(126, 217, 87, 0.75);
      background: rgba(126, 217, 87, 0.18);
    }

    .location-option-preview {
      position: relative;
      width: 100%;
      padding-top: 66%;
      background-size: cover;
      background-position: center;
    }

    .location-option-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.9rem 1rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .location-option-name {
      flex: 1;
    }

    .location-option-badge {
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      background: rgba(250, 204, 21, 0.2);
      color: #facc15;
      font-size: 0.65rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    #clearButton {
      background: rgba(255, 116, 116, 0.9);
      color: #111;
    }

    #saveButton {
      background: #7ed957;
    }

    .appearance-save-button {
      background: #7ed957;
    }

    #grantSetterButton {
      background: rgba(126, 217, 87, 0.85);
      color: #111;
    }

    #deleteButton {
      background: rgba(255, 116, 116, 0.8);
      color: #111;
    }

    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
    }

    .controls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .auth-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.75);
      padding: 1.5rem;
      backdrop-filter: blur(2px);
      z-index: 20;
    }

    .auth-card {
      background: rgba(18, 18, 18, 0.95);
      border-radius: 1rem;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: min(90vw, 360px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
    }

    .auth-card h1 {
      font-size: 1.4rem;
      text-align: center;
    }

    .auth-field {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.95rem;
    }

    .auth-field input {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.35);
      color: #fff;
      padding: 0.65rem 1rem;
      font-size: 1rem;
    }

    .auth-submit {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1rem;
      background: #7ed957;
      color: #111;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.45rem;
    }

    .auth-submit:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
    }

    .auth-switch {
      font-size: 0.9rem;
      text-align: center;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      justify-content: center;
      align-items: center;
    }

    .auth-switch button {
      background: none;
      border: none;
      color: #7ed957;
      font-weight: 600;
      cursor: pointer;
      text-decoration: underline;
    }

    .auth-error {
      min-height: 1.25rem;
      color: #ff7a7a;
      text-align: center;
      font-size: 0.85rem;
    }

    .unauthorized {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      z-index: 30;
      padding: 2rem;
      text-align: center;
    }

    .unauthorized a {
      color: #7ed957;
      font-weight: 600;
      text-decoration: underline;
    }

    .status-message {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.55);
      padding: 0.75rem 1rem;
      border-radius: 0.85rem;
      min-width: min(320px, 92vw);
      max-width: min(360px, 92vw);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(6px);
      font-size: 0.85rem;
      letter-spacing: 0.01em;
      color: #e1e1e1;
    }

    .status-message[data-variant='success'] {
      color: #7ed957;
    }

    .status-message[data-variant='error'] {
      color: #ff7a7a;
    }

    .status-message[data-variant='info'] {
      color: #f1f1f1;
    }

    .status-message[data-variant='warning'] {
      color: #facc15;
    }
  </style>
</head>
<body>
  <div id="authOverlay" class="auth-overlay" role="dialog" aria-modal="true" aria-labelledby="authTitle">
    <form id="authForm" class="auth-card">
      <h1 id="authTitle">Sign in to continue</h1>
      <label class="auth-field">
        <span>Username</span>
        <input id="authUsername" type="text" name="username" autocomplete="username" required />
      </label>
      <label class="auth-field">
        <span>Password</span>
        <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="6" required />
      </label>
      <p id="authError" class="auth-error" role="alert" aria-live="assertive"></p>
      <button type="submit" class="auth-submit">Sign In</button>
      <p class="auth-switch">
        <span id="authSwitchLabel">Don't have an account?</span>
        <button type="button" id="toggleAuthMode">Create one</button>
      </p>
    </form>
  </div>

  <div id="appContent" class="hidden">
    <div class="canvas-container">
      <canvas id="drawingCanvas"></canvas>
    </div>
    <div class="control-panel" data-expanded="true">
      <div id="panelSidebar" class="panel-sidebar">
        <div class="sidebar-actions">
          <button
            id="panelToggle"
            class="panel-icon-button panel-toggle-button"
            type="button"
            aria-pressed="false"
            aria-label="Hide menu"
            title="Hide menu"
          >
            <span class="panel-toggle-icon panel-toggle-icon-close" aria-hidden="true">
              <svg viewBox="0 0 24 24" focusable="false">
                <path
                  d="M6.34 6.34a1 1 0 0 1 1.32-.08l.1.08L12 10.59l4.24-4.25a1 1 0 0 1 1.5 1.32l-.08.1L13.41 12l4.25 4.24a1 1 0 0 1-1.32 1.5l-.1-.08L12 13.41l-4.24 4.25a1 1 0 0 1-1.5-1.32l.08-.1L10.59 12 6.34 7.76a1 1 0 0 1 0-1.42Z"
                  fill="currentColor"
                />
              </svg>
            </span>
            <span class="panel-toggle-icon panel-toggle-icon-open" aria-hidden="true">
              <svg viewBox="0 0 24 24" focusable="false">
                <path
                  d="M9.29 5.29a1 1 0 0 1 1.42 0l5 5a1 1 0 0 1 .08 1.32l-.08.1-5 5a1 1 0 0 1-1.5-1.32l.08-.1L13.59 12 9.3 7.7a1 1 0 0 1-.08-1.32Z"
                  fill="currentColor"
                />
              </svg>
            </span>
            <span class="sr-only">Hide menu</span>
          </button>
          <div class="info-wrapper">
            <button
              id="infoButton"
              class="panel-icon-button info-button"
              type="button"
              aria-label="Learn about setter tools"
              aria-haspopup="dialog"
              aria-pressed="false"
              aria-expanded="false"
              aria-controls="infoPopover"
              title="Learn about setter tools"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2" />
                <rect x="11" y="10" width="2" height="7" rx="1" />
                <circle cx="12" cy="7" r="1.5" />
              </svg>
              <span class="sr-only">Learn about setter tools</span>
            </button>
            <div
              id="infoPopover"
              class="info-popover hidden"
              role="dialog"
              aria-modal="false"
              aria-hidden="true"
              aria-label="About Ascend"
              tabindex="-1"
            >
              <p>Select any setter control to learn what it does.</p>
              <p>The next control you activate will show its tooltip and close this message.</p>
            </div>
          </div>
          <button
            id="drawingToggle"
            class="panel-icon-button drawing-toggle"
            type="button"
            aria-pressed="false"
            aria-label="Enable drawing"
            title="Enable drawing"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M4 15.75V20h4.25l11.1-11.1a1 1 0 0 0 0-1.42L17.52 5.65a1 1 0 0 0-1.41 0L4 17.66Z"
                fill="currentColor"
              />
              <path d="m16.08 4.22 3.7 3.7 1.41-1.41a1 1 0 0 0 0-1.42l-2.28-2.28a1 1 0 0 0-1.42 0l-1.41 1.41Z" fill="currentColor" />
            </svg>
            <span class="sr-only">Enable drawing</span>
          </button>
        </div>
        <div
          id="panelTablist"
          class="panel-tablist"
          role="tablist"
          aria-orientation="vertical"
          aria-label="Setter controls"
        >
          <button
            id="routesTabButton"
            class="panel-icon-button panel-tab"
            type="button"
            role="tab"
            aria-selected="true"
            aria-controls="routesTab"
            data-target="routesTab"
            aria-label="Routes"
            title="Routes"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M6 19a3 3 0 0 1 0-6h12a2 2 0 0 0 0-4H8a4 4 0 0 1 0-8h10v2H8a2 2 0 0 0 0 4h10a4 4 0 0 1 0 8H6a1 1 0 0 0 0 2h12v2H6a3 3 0 0 1-3-3Z"
                fill="currentColor"
              />
            </svg>
            <span class="sr-only">Routes</span>
          </button>
          <button
            id="wallsTabButton"
            class="panel-icon-button panel-tab"
            type="button"
            role="tab"
            aria-selected="false"
            aria-controls="wallsTab"
            data-target="wallsTab"
            aria-label="Walls"
            title="Walls"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M12 2a7 7 0 0 1 7 7c0 4.42-4.56 9.52-6.38 11.34a0.88 0.88 0 0 1-1.24 0C9.56 18.52 5 13.42 5 9a7 7 0 0 1 7-7Zm0 4a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z"
                fill="currentColor"
              />
            </svg>
            <span class="sr-only">Walls</span>
          </button>
          <button
            id="configurationTabButton"
            class="panel-icon-button panel-tab"
            type="button"
            role="tab"
            aria-selected="false"
            aria-controls="configurationTab"
            data-target="configurationTab"
            aria-label="Configuration"
            title="Configuration"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M21.53 14.47 18 10.94V7.5a1 1 0 0 0-1-1h-3.44L11 3.94a2 2 0 0 0-2.83 0L7 5.12a1 1 0 0 0 0 1.41l2.83 2.83-6.72 6.72a2 2 0 0 0 0 2.83l1.41 1.41a2 2 0 0 0 2.83 0l6.72-6.72 2.83 2.83a1 1 0 0 0 1.41 0l1.18-1.18a2 2 0 0 0 .04-2.78Z"
                fill="currentColor"
              />
            </svg>
            <span class="sr-only">Configuration</span>
          </button>
        </div>
      </div>
      <div id="controlsPanel" class="controls">
        <div class="tab-panels">
          <div
            id="routesTab"
            class="tab-panel"
            role="tabpanel"
            aria-labelledby="routesTabButton"
            aria-hidden="false"
          >
            <div class="control-section">
              <label class="control-field" data-help-text="Select a saved route to edit or choose the new option to start fresh.">
                <span>Saved routes</span>
                <select id="routeSelector">
                  <option value="">Create new route‚Ä¶</option>
                </select>
              </label>
              <label class="control-field" data-help-text="Enter the setter name that should appear to climbers.">
                <span>Setter</span>
                <input id="routeSetterInput" type="text" placeholder="setter name" autocomplete="off" />
              </label>
              <label class="control-field" data-help-text="Provide a clear title that climbers will see in the list.">
                <span>Title</span>
                <input id="routeTitleInput" type="text" placeholder="Route title" autocomplete="off" />
              </label>
              <label class="control-field" data-help-text="Add beta notes or important information about the climb.">
                <span>Description</span>
                <textarea id="routeDescriptionInput" placeholder="Describe the climb"></textarea>
              </label>
              <label class="control-field" data-help-text="Record when the route was set to manage rotations.">
                <span>Date set</span>
                <input id="routeDateSetInput" type="datetime-local" />
              </label>
            </div>
            <div class="control-section">
              <label class="control-field" data-help-text="Choose the colour used to draw this route on the wall preview.">
                <span>Stroke colour</span>
                <input type="color" id="colorPicker" value="#ffde59" />
              </label>
              <label class="control-field" data-help-text="Switch between freeform lines, single points, or rectangles while drawing.">
                <span>Path</span>
                <select id="pathTypeSelect">
                  <option value="brezer">Brezer</option>
                  <option value="point">Point</option>
                  <option value="rectangle">Rectangle</option>
                </select>
              </label>
              <button
                id="advancedColorToggle"
                class="color-wheel-toggle"
                type="button"
                aria-expanded="false"
                aria-controls="advancedColorPicker"
                data-help-text="Open the colour wheel to fine tune hue, saturation, and brightness."
              >
                Open colour wheel
              </button>
              <div
                id="advancedColorPicker"
                class="color-wheel hidden"
                aria-hidden="true"
                data-help-text="Drag in the wheel or adjust the slider to refine the stroke colour."
              >
                <div class="color-wheel-canvas-wrapper">
                  <canvas
                    id="colorWheelCanvas"
                    width="220"
                    height="220"
                    tabindex="0"
                    role="application"
                    aria-label="Colour wheel selector"
                    aria-describedby="colorWheelHint"
                  ></canvas>
                  <div id="colorWheelMarker" class="color-wheel-marker" aria-hidden="true"></div>
                </div>
                <p id="colorWheelHint" class="color-wheel-hint">
                  Drag on the wheel or use the arrow keys to adjust hue and saturation.
                </p>
                <div class="color-lightness-control" data-help-text="Use the slider to brighten or darken the selected colour.">
                  <label for="colorLightnessSlider">Lightness</label>
                  <input id="colorLightnessSlider" type="range" min="0" max="100" value="50" />
                </div>
                <div class="color-wheel-preview" aria-live="polite">
                  <div id="colorWheelSwatch" class="color-wheel-swatch" aria-hidden="true"></div>
                  <code id="colorWheelValue">#FFDE59</code>
                </div>
              </div>
              <button id="saveButton" type="button" data-help-text="Save the current drawing and route details.">Save route</button>
              <button id="deleteButton" type="button" data-help-text="Delete the selected route permanently.">Delete route</button>
              <button id="clearButton" type="button" data-help-text="Remove every drawn shape from the canvas.">Clear drawing</button>
            </div>
          </div>
          <div
            id="configurationTab"
            class="tab-panel"
            role="tabpanel"
            aria-labelledby="configurationTabButton"
            aria-hidden="true"
          >
            <div class="control-section">
              <h3 class="control-section-title">Appearance</h3>
              <label
                id="pointDiameterField"
                class="control-field"
                data-help-text="Set the diameter for point holds drawn on this wall."
              >
                <span>
                  Point diameter
                  <span id="pointDiameterValue"></span>
                </span>
                <input
                  id="pointDiameterSlider"
                  type="range"
                  min="12"
                  max="160"
                  step="1"
                  value="48"
                />
              </label>
              <label
                id="rectangleWidthField"
                class="control-field"
                data-help-text="Adjust the width of rectangle holds when using the rectangle path."
              >
                <span>
                  Rectangle width
                  <span id="rectangleWidthValue"></span>
                </span>
                <input
                  id="rectangleWidthSlider"
                  type="range"
                  min="12"
                  max="200"
                  step="1"
                  value="80"
                />
              </label>
              <label
                id="rectangleHeightField"
                class="control-field"
                data-help-text="Adjust the height of rectangle holds when using the rectangle path."
              >
                <span>
                  Rectangle height
                  <span id="rectangleHeightValue"></span>
                </span>
                <input
                  id="rectangleHeightSlider"
                  type="range"
                  min="12"
                  max="200"
                  step="1"
                  value="60"
                />
              </label>
              <label
                id="unfocusedTransparencyField"
                class="control-field"
                data-help-text="Control how transparent inactive routes appear for climbers."
              >
                <span>Unfocused transparency</span>
                <input
                  id="unfocusedTransparencySlider"
                  type="range"
                  min="0"
                  max="100"
                  step="5"
                  value="25"
                />
              </label>
              <button
                id="saveAppearanceButton"
                class="appearance-save-button"
                type="button"
                data-help-text="Save these appearance defaults for the current wall."
              >
                Save Appearance
              </button>
            </div>
            <div class="control-section">
              <h3 class="control-section-title">Grant setter access</h3>
              <label class="control-field" data-help-text="Enter the username that should receive setter permissions.">
                <span>Username</span>
                <input id="roleUsernameInput" type="text" placeholder="username" autocomplete="off" />
              </label>
              <button id="grantSetterButton" type="button" data-help-text="Grant setter permissions to the username above.">
                Grant setter role
              </button>
              <p
                id="roleStatusMessage"
                class="status-message hidden"
                role="status"
                aria-live="polite"
              ></p>
            </div>
            <div class="control-section">
              <h3 class="control-section-title">Session actions</h3>
              <div class="global-actions">
                <button
                  id="climberViewButton"
                  class="global-action-button"
                  type="button"
                  data-help-text="Open the climber preview using the active wall."
                >
                  <span class="button-label">Climber View</span>
                </button>
                <button
                  id="personalDashboardButton"
                  class="global-action-button"
                  type="button"
                  data-help-text="Jump to your personal dashboard to review ascents and progress."
                >
                  <span class="button-label">Personal Dashboard</span>
                </button>
                <button
                  id="adminConsoleButton"
                  class="global-action-button"
                  type="button"
                  data-help-text="Open the admin console for database management."
                >
                  <span class="button-icon" aria-hidden="true">üõ°Ô∏è</span>
                  <span class="button-label">Admin</span>
                </button>
                <button
                  id="signOutButton"
                  class="global-action-button"
                  type="button"
                  data-help-text="Sign out of the setter tools."
                >
                  <span class="button-icon" aria-hidden="true">üö™</span>
                  <span class="button-label">Sign Out</span>
                </button>
              </div>
              <p
                id="adminConsoleStatus"
                class="status-message hidden"
                role="status"
                aria-live="polite"
              ></p>
            </div>
          </div>
          <div
            id="wallsTab"
            class="tab-panel"
            role="tabpanel"
            aria-labelledby="wallsTabButton"
            aria-hidden="true"
          >
            <div class="control-section">
              <h3 class="control-section-title">Select wall</h3>
              <div class="global-actions">
                <button
                  id="locationButton"
                  class="global-action-button"
                  type="button"
                  aria-haspopup="dialog"
                  aria-expanded="false"
                  data-help-text="Open the wall picker to switch backgrounds."
                >
                  <span class="button-icon" aria-hidden="true">üìç</span>
                  <span class="button-label">Select wall</span>
                </button>
              </div>
              <label
                id="wallVisibilityToggleWrapper"
                class="control-toggle"
                data-help-text="Hide this wall from climber-facing pages so only setters can access it."
              >
                <span>Hide wall from climbers</span>
                <input id="wallVisibilityToggle" type="checkbox" role="switch" aria-checked="false" />
              </label>
            </div>
            <div class="control-section">
              <h3 class="control-section-title">Create new wall</h3>
              <label class="control-field" data-help-text="Name shown in the wall selector for setters and climbers.">
                <span>Wall name</span>
                <input id="newWallNameInput" type="text" placeholder="e.g. Cave Wall" autocomplete="off" />
              </label>
              <label class="control-field" data-help-text="Provide an image path or URL for the wall background.">
                <span>Background image URL</span>
                <input
                  id="newWallImageInput"
                  type="text"
                  placeholder="./location/cave-wall.jpg"
                  autocomplete="off"
                />
              </label>
              <button
                id="createWallButton"
                class="location-button"
                type="button"
                data-help-text="Create a wall using the name and background above."
              >
                <span class="button-icon" aria-hidden="true">üìç</span>
                <span class="button-label">Create wall</span>
              </button>
              <button
                id="deleteWallButton"
                class="location-button delete-wall-button"
                type="button"
                data-help-text="Remove the currently selected wall."
              >
                Delete Wall
              </button>
              <p
                id="createWallStatus"
                class="status-message hidden"
                role="status"
                aria-live="polite"
              ></p>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div id="unauthorizedNotice" class="unauthorized hidden" role="alert">
    <p><strong>Access denied.</strong> Your account does not have permission to use the setter tools.</p>
    <p>You can return to the <a id="previewLink" href="index.html">preview page</a> or contact a setter for help.</p>
    <button id="unauthorizedSignOut" class="auth-submit" type="button">
      <span class="button-icon" aria-hidden="true">üö™</span>
      <span class="button-label">Sign Out</span>
    </button>
  </div>

  <p id="routeStatus" class="status-message hidden" role="status" aria-live="polite"></p>

  <div
    id="locationModal"
    class="location-modal hidden"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="locationModalTitle"
  >
    <div class="location-modal-content">
      <div class="location-modal-header">
        <h2 id="locationModalTitle" class="location-modal-title">Select a wall</h2>
        <button id="locationModalClose" class="location-modal-close" type="button" aria-label="Close wall selector">
          √ó
        </button>
      </div>
      <div id="locationOptions" class="location-options" role="listbox"></div>
    </div>
  </div>

  <div
    id="tutorialOverlay"
    class="tutorial-overlay hidden"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="tutorialTitle"
    aria-describedby="tutorialDescription"
    data-tutorial-exempt="true"
  >
    <div id="tutorialDialogCard" class="tutorial-card" role="document" tabindex="-1">
      <div id="tutorialProgress" class="tutorial-progress hidden" aria-live="polite"></div>
      <h2 id="tutorialTitle" class="tutorial-title"></h2>
      <div id="tutorialDescription" class="tutorial-description"></div>
      <div class="tutorial-actions">
        <button
          id="tutorialSecondaryAction"
          class="tutorial-button tutorial-secondary hidden"
          type="button"
          data-tutorial-exempt="true"
        >
          Back
        </button>
        <button
          id="tutorialPrimaryAction"
          class="tutorial-button tutorial-primary"
          type="button"
          data-tutorial-exempt="true"
        >
          Next
        </button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
    import {
      getAuth,
      onAuthStateChanged,
      signInWithEmailAndPassword,
      createUserWithEmailAndPassword,
      signOut,
      updateProfile,
      deleteUser,
    } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
    import {
      getFirestore,
      doc,
      getDoc,
      setDoc,
      serverTimestamp,
      collection,
      getDocs,
      query,
      limit,
      where,
      deleteDoc,
      deleteField,
      Timestamp,
    } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
    import { firebaseConfig } from './config.js';

    const firebaseApp = initializeApp(firebaseConfig);
    const auth = getAuth(firebaseApp);
    const db = getFirestore(firebaseApp);

    const authOverlay = document.getElementById('authOverlay');
    const appContent = document.getElementById('appContent');
    const canvasContainer = document.querySelector('.canvas-container');
    const canvas = document.getElementById('drawingCanvas');
    const authForm = document.getElementById('authForm');
    const authUsername = document.getElementById('authUsername');
    const authPassword = document.getElementById('authPassword');
    const authError = document.getElementById('authError');
    const authTitle = document.getElementById('authTitle');
    const authSwitchLabel = document.getElementById('authSwitchLabel');
    const toggleAuthModeButton = document.getElementById('toggleAuthMode');
    const signOutButton = document.getElementById('signOutButton');
    const unauthorizedSignOut = document.getElementById('unauthorizedSignOut');
    const unauthorizedNotice = document.getElementById('unauthorizedNotice');
    const routeSelector = document.getElementById('routeSelector');
    const routeSetterInput = document.getElementById('routeSetterInput');
    const routeTitleInput = document.getElementById('routeTitleInput');
    const routeDescriptionInput = document.getElementById('routeDescriptionInput');
    const routeDateSetInput = document.getElementById('routeDateSetInput');
    const deleteButton = document.getElementById('deleteButton');
    const routeStatus = document.getElementById('routeStatus');
    const controlPanel = document.querySelector('.control-panel');
    const drawingToggle = document.getElementById('drawingToggle');
    const panelSidebar = document.getElementById('panelSidebar');
    const panelToggleButton = document.getElementById('panelToggle');
    const infoButton = document.getElementById('infoButton');
    const infoPopover = document.getElementById('infoPopover');
    const climberViewButton = document.getElementById('climberViewButton');
    const personalDashboardButton = document.getElementById('personalDashboardButton');
    const adminConsoleButton = document.getElementById('adminConsoleButton');
    const adminConsoleStatus = document.getElementById('adminConsoleStatus');
    const previewLink = document.getElementById('previewLink');
    const previewLinkBaseHref = previewLink?.getAttribute('href') || 'index.html';
    const climberViewBaseHref = 'index.html';
    let climberViewTargetHref = climberViewBaseHref;

    async function signOutAndRedirectToIndex() {
      try {
        await signOut(auth);
      } catch (error) {
        console.error('Failed to sign out:', error);
        return false;
      }

      window.location.href = 'index.html';
      return true;
    }
    const roleUsernameInput = document.getElementById('roleUsernameInput');
    const grantSetterButton = document.getElementById('grantSetterButton');
    const roleStatusMessage = document.getElementById('roleStatusMessage');
    const locationButton = document.getElementById('locationButton');
    const locationButtonLabel = locationButton?.querySelector('.button-label');
    const locationModal = document.getElementById('locationModal');
    const locationOptions = document.getElementById('locationOptions');
    const locationModalClose = document.getElementById('locationModalClose');
    const routesTabButton = document.getElementById('routesTabButton');
    const wallsTabButton = document.getElementById('wallsTabButton');
    const configurationTabButton = document.getElementById('configurationTabButton');
    const tabButtons = [routesTabButton, wallsTabButton, configurationTabButton].filter(Boolean);
    const tabPanels = {
      routesTab: document.getElementById('routesTab'),
      wallsTab: document.getElementById('wallsTab'),
      configurationTab: document.getElementById('configurationTab'),
    };
    const newWallNameInput = document.getElementById('newWallNameInput');
    const newWallImageInput = document.getElementById('newWallImageInput');
    const createWallButton = document.getElementById('createWallButton');
    const deleteWallButton = document.getElementById('deleteWallButton');
    const createWallStatus = document.getElementById('createWallStatus');
    const wallVisibilityToggleWrapper = document.getElementById('wallVisibilityToggleWrapper');
    const wallVisibilityToggle = document.getElementById('wallVisibilityToggle');
    const tutorialOverlay = document.getElementById('tutorialOverlay');
    const tutorialDialogCard = document.getElementById('tutorialDialogCard');
    const tutorialTitle = document.getElementById('tutorialTitle');
    const tutorialDescription = document.getElementById('tutorialDescription');
    const tutorialPrimaryAction = document.getElementById('tutorialPrimaryAction');
    const tutorialSecondaryAction = document.getElementById('tutorialSecondaryAction');
    const tutorialProgress = document.getElementById('tutorialProgress');

    let isUpdatingWallVisibility = false;
    let tutorialPointer = null;
    let tutorialPointerTarget = null;
    let tutorialHighlightedElement = null;
    let tutorialHighlightedElementOptions = { illuminate: false };
    let tutorialPreviousFocus = null;
    let tutorialActive = false;
    let tutorialTransitionInProgress = false;
    let tutorialStepIndex = -1;
    let tutorialSteps = [];
    let tutorialPreviousTabId = null;
    let tutorialSecondaryActionMode = 'back';

    const LOCATIONS = [
      { key: 'new-wall', name: 'New Wall', image: './location/New Wall.jpg', hidden: false },
      { key: 'old-wall', name: 'Old Wall', image: './location/Old Wall.jpg', hidden: false },
    ];

    const LOCATION_STORAGE_KEY = 'ascend.selectedWall';
    const WALL_QUERY_PARAM = 'wall';

    const PATH_TYPE_BREZER = 'brezer';
    const PATH_TYPE_POINT = 'point';
    const PATH_TYPE_RECTANGLE = 'rectangle';
    const DEFAULT_PATH_TYPE = PATH_TYPE_BREZER;
    const BREZER_REMOVAL_RADIUS = 20;
    const MIN_POINT_DIAMETER = 12;
    const MAX_POINT_DIAMETER = 160;
    const DEFAULT_POINT_DIAMETER = 48;
    const MIN_RECTANGLE_SIZE = 12;
    const MAX_RECTANGLE_SIZE = 200;
    const DEFAULT_RECTANGLE_WIDTH = 80;
    const DEFAULT_RECTANGLE_HEIGHT = 60;
    const MIN_UNFOCUSED_TRANSPARENCY = 0;
    const MAX_UNFOCUSED_TRANSPARENCY = 1;
    const DEFAULT_UNFOCUSED_TRANSPARENCY = 0.25;
    const MIN_GRADE_VALUE = 5;
    const MAX_GRADE_VALUE = 30;
    const MIN_GRADE_BAR_BASE_HEIGHT = 0;
    const MAX_GRADE_BAR_HEIGHT = 1000;
    const DEFAULT_GRADE_BAR_BASE_HEIGHT = 40;
    const DEFAULT_GRADE_BAR_MAX_HEIGHT = 220;
    const MIN_GRADE_BAR_WIDTH = 4;
    const MAX_GRADE_BAR_WIDTH = 160;
    const DEFAULT_GRADE_BAR_WIDTH = 24;
    const DEFAULT_GRADE_BAR_TRANSPARENCY = 0.85;
    const WALL_COLLECTION = 'walls';

    const normalizeLocationName = (value) => {
      if (typeof value !== 'string') {
        return '';
      }
      return value.trim().toLowerCase();
    };

    const normalizeWallKey = (value) => normalizeLocationName(value);

    const BUILTIN_LOCATION_KEYS = new Set(
      LOCATIONS.map((location) => normalizeWallKey(location?.key || location?.name)).filter(Boolean),
    );

    const findLocationByKey = (key) => LOCATIONS.find((location) => location.key === key);

    const findLocationByName = (name) => {
      const normalized = normalizeLocationName(name);
      return (
        LOCATIONS.find((location) => normalizeLocationName(location.name) === normalized) || null
      );
    };

    function buildWallAwareHref(baseHref, wallKey) {
      const normalizedKey = normalizeWallKey(wallKey);
      if (typeof baseHref !== 'string' || !baseHref) {
        return '';
      }

      try {
        const url = new URL(baseHref, window.location.origin);
        if (normalizedKey) {
          url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
        } else {
          url.searchParams.delete(WALL_QUERY_PARAM);
        }
        url.hash = '';
        const relativePath = `${url.pathname.replace(/^\//, '')}${url.search}`;
        return relativePath || baseHref;
      } catch (error) {
        if (!normalizedKey) {
          return baseHref;
        }

        const separator = baseHref.includes('?') ? '&' : '?';
        return `${baseHref}${separator}${encodeURIComponent(WALL_QUERY_PARAM)}=${encodeURIComponent(normalizedKey)}`;
      }
    }

    function getWallKeyFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search);
        const raw = params.get(WALL_QUERY_PARAM);
        return normalizeWallKey(raw);
      } catch (error) {
        console.warn('Unable to read wall from query string:', error);
        return '';
      }
    }

    function updateWallQueryParam(wallKey) {
      try {
        const normalizedKey = normalizeWallKey(wallKey);
        const url = new URL(window.location.href);
        if (normalizedKey) {
          url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
        } else {
          url.searchParams.delete(WALL_QUERY_PARAM);
        }
        url.hash = '';
        const next = url.toString();
        if (next !== window.location.href) {
          window.history.replaceState({}, '', next);
        }
      } catch (error) {
        console.warn('Unable to update wall query parameter:', error);
      }
    }

    function persistSelectedWall(wallKey) {
      const normalizedKey = normalizeWallKey(wallKey);
      try {
        if (normalizedKey) {
          window.localStorage?.setItem(LOCATION_STORAGE_KEY, normalizedKey);
        } else {
          window.localStorage?.removeItem(LOCATION_STORAGE_KEY);
        }
      } catch (error) {
        console.warn('Unable to persist setter location preference:', error);
      }
    }

    function updateWallNavigationTargets(wallKey) {
      const normalizedKey = normalizeWallKey(wallKey);
      if (previewLink) {
        previewLink.href = buildWallAwareHref(previewLinkBaseHref, normalizedKey);
      }

      const computedClimberHref = buildWallAwareHref(climberViewBaseHref, normalizedKey);
      climberViewTargetHref = computedClimberHref;
      if (climberViewButton) {
        climberViewButton.setAttribute('data-target-href', computedClimberHref);
      }
    }

    function upsertLocation({
      key = '',
      name = '',
      image = '',
      fallbackName = '',
      hidden = false,
    } = {}) {
      const trimmedName = typeof name === 'string' && name.trim() ? name.trim() : '';
      const fallback =
        trimmedName || (typeof fallbackName === 'string' && fallbackName.trim() ? fallbackName.trim() : '');
      const keySource = typeof key === 'string' && key.trim() ? key.trim() : fallback;
      const normalizedKey = normalizeWallKey(keySource);
      const displayName = fallback;
      if (!normalizedKey || !displayName) {
        return { entry: null, changed: false };
      }

      const normalizedImage = typeof image === 'string' ? image.trim() : '';
      const normalizedHidden = Boolean(hidden);
      const existingIndex = LOCATIONS.findIndex((location) => {
        if (!location) {
          return false;
        }
        if (location.key === normalizedKey) {
          return true;
        }
        return normalizeLocationName(location.name) === normalizeLocationName(displayName);
      });

      if (existingIndex >= 0) {
        const existing = LOCATIONS[existingIndex];
        const needsUpdate =
          existing.key !== normalizedKey ||
          existing.name !== displayName ||
          existing.image !== normalizedImage ||
          Boolean(existing.hidden) !== normalizedHidden;

        if (!needsUpdate) {
          return { entry: existing, changed: false };
        }

        const updated = {
          ...existing,
          key: normalizedKey,
          name: displayName,
          image: normalizedImage,
          hidden: normalizedHidden,
        };
        LOCATIONS[existingIndex] = updated;
        return { entry: updated, changed: true };
      }

      const created = {
        key: normalizedKey,
        name: displayName,
        image: normalizedImage,
        hidden: normalizedHidden,
      };
      LOCATIONS.push(created);
      return { entry: created, changed: true };
    }

    function synchronizeCurrentLocationReference() {
      if (!currentLocation) {
        return;
      }

      const normalizedKey = normalizeWallKey(currentLocation.key || currentLocation.name);
      const refreshed =
        (normalizedKey && findLocationByKey(normalizedKey)) ||
        findLocationByName(currentLocation.name);

      if (refreshed && refreshed !== currentLocation) {
        currentLocation = refreshed;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();
        const activeKey = getCurrentLocationKey();
        updateWallNavigationTargets(activeKey);
        updateWallQueryParam(activeKey);
        persistSelectedWall(activeKey);
      }

      updateWallVisibilityControls();
    }

    const DEFAULT_LOCATION = LOCATIONS[0];

    let currentLocation = DEFAULT_LOCATION;
    let backgroundImageSource = '';
    let backgroundReady = false;

    const wallSettingsCache = new Map();
    const wallDocumentIdMap = new Map();

    const backgroundImage = new Image();

    const updateLocationButtonLabel = () => {
      const baseName = currentLocation?.name || 'Select wall';
      const suffix = currentLocation?.hidden ? ' (Hidden)' : '';
      const labelText = `${baseName}${suffix}`;
      if (locationButtonLabel) {
        locationButtonLabel.textContent = labelText;
      }
      if (locationButton) {
        locationButton.setAttribute('aria-label', `Select wall: ${labelText}`);
        locationButton.setAttribute('title', labelText);
      }
    };

    const updateLocationOptionsState = () => {
      if (!locationOptions) {
        return;
      }

      const buttons = locationOptions.querySelectorAll('[data-location-key]');
      buttons.forEach((button) => {
        const key = button?.dataset?.locationKey;
        if (key && currentLocation && key === currentLocation.key) {
          button.setAttribute('aria-current', 'true');
        } else {
          button.removeAttribute('aria-current');
        }
      });
    };

    const updateDeleteWallButtonState = () => {
      if (!deleteWallButton) {
        return;
      }

      if (isDeletingWall) {
        deleteWallButton.disabled = true;
        return;
      }

      const activeKey = getCurrentLocationKey();
      const normalizedActiveKey = normalizeWallKey(activeKey);
      const hasAlternativeWall = LOCATIONS.some((location) => {
        if (!location) {
          return false;
        }
        const candidateKey = normalizeWallKey(location.key || location.name);
        return candidateKey && candidateKey !== normalizedActiveKey;
      });

      deleteWallButton.disabled = !normalizedActiveKey || !hasAlternativeWall;
    };

    function updateLocationHiddenFlag(locationKey, hidden) {
      const normalizedKey = normalizeWallKey(locationKey);
      if (!normalizedKey) {
        return;
      }

      LOCATIONS.forEach((location) => {
        if (!location) {
          return;
        }
        const candidateKey = normalizeWallKey(location.key || location.name);
        if (candidateKey === normalizedKey) {
          location.hidden = hidden;
        }
      });

      if (currentLocation) {
        const currentKey = normalizeWallKey(currentLocation.key || currentLocation.name);
        if (currentKey === normalizedKey) {
          currentLocation.hidden = hidden;
        }
      }
    }

    const updateWallVisibilityControls = () => {
      if (!wallVisibilityToggle) {
        return;
      }

      const isHidden = Boolean(currentLocation?.hidden);
      wallVisibilityToggle.checked = isHidden;
      wallVisibilityToggle.setAttribute('aria-checked', isHidden ? 'true' : 'false');

      const disabled = !currentLocation || isUpdatingWallVisibility;
      wallVisibilityToggle.disabled = disabled;
      wallVisibilityToggle.setAttribute('aria-disabled', disabled ? 'true' : 'false');

      if (wallVisibilityToggleWrapper) {
        wallVisibilityToggleWrapper.classList.toggle('is-disabled', disabled);
      }
    };

    async function applyWallVisibilityChange(nextHidden) {
      const locationKey = getCurrentLocationKey();
      if (!locationKey || !currentLocation) {
        updateWallVisibilityControls();
        return;
      }

      const normalizedNext = Boolean(nextHidden);
      const previousHidden = Boolean(currentLocation.hidden);
      if (normalizedNext === previousHidden) {
        updateWallVisibilityControls();
        return;
      }

      isUpdatingWallVisibility = true;
      updateWallVisibilityControls();

      updateLocationHiddenFlag(locationKey, normalizedNext);
      updateLocationButtonLabel();
      renderLocationOptions();
      updateLocationOptionsState();
      updateWallVisibilityControls();

      try {
        const locationDetails =
          findLocationByKey(locationKey) ||
          findLocationByName(currentLocation.name) ||
          currentLocation;

        const wallPayload = {
          hidden: normalizedNext,
          updatedAt: serverTimestamp(),
          key: locationKey,
        };

        if (locationDetails?.name) {
          wallPayload.name = locationDetails.name;
        }

        if (locationDetails?.image) {
          wallPayload.background_url = locationDetails.image;
        }

        const docId = wallDocumentIdMap.get(locationKey) || locationKey;
        await setDoc(doc(db, WALL_COLLECTION, docId), wallPayload, { merge: true });

        setStatus(
          normalizedNext ? 'Wall hidden from climbers.' : 'Wall visible to climbers.',
          'success',
        );
      } catch (error) {
        console.error('Failed to update wall visibility:', error);
        setStatus('Failed to update wall visibility. Please try again.', 'error');

        updateLocationHiddenFlag(locationKey, previousHidden);
        if (wallVisibilityToggle) {
          wallVisibilityToggle.checked = previousHidden;
          wallVisibilityToggle.setAttribute('aria-checked', previousHidden ? 'true' : 'false');
        }
        updateLocationButtonLabel();
        renderLocationOptions();
        updateLocationOptionsState();
      } finally {
        isUpdatingWallVisibility = false;
        updateWallVisibilityControls();
      }
    }

    const applyBodyBackground = (imagePath) => {
      if (!document.body) {
        return;
      }

      if (imagePath) {
        document.body.style.setProperty('--wall-background', `url('${imagePath}')`);
      } else {
        document.body.style.removeProperty('--wall-background');
      }
    };

    function activateTab(targetId) {
      if (!targetId) {
        return;
      }

      tabButtons.forEach((button) => {
        if (!button) {
          return;
        }
        const isActive = button.dataset?.target === targetId;
        button.setAttribute('aria-selected', String(isActive));
        button.tabIndex = isActive ? 0 : -1;
      });

      Object.values(tabPanels).forEach((panel) => {
        if (!panel) {
          return;
        }
        const isActive = panel.id === targetId;
        panel.setAttribute('aria-hidden', isActive ? 'false' : 'true');
      });

      updateHelpTooltips();
    }

    const updateBackgroundForCurrentLocation = () => {
      const imagePath = currentLocation?.image || '';
      applyBodyBackground(imagePath);

      if (imagePath && imagePath !== backgroundImageSource) {
        backgroundImageSource = imagePath;
        backgroundReady = false;
        backgroundImage.src = imagePath;
      } else if (!imagePath) {
        backgroundImageSource = '';
        backgroundReady = false;
      }
    };

    const closeLocationModal = () => {
      if (!locationModal) {
        return;
      }

      if (!locationModal.classList.contains('hidden')) {
        locationModal.classList.add('hidden');
        locationModal.setAttribute('aria-hidden', 'true');
        locationButton?.setAttribute('aria-expanded', 'false');
        updateHelpTooltips();
      }
    };

    const openLocationModal = () => {
      if (!locationModal) {
        return;
      }

      locationModal.classList.remove('hidden');
      locationModal.setAttribute('aria-hidden', 'false');
      locationButton?.setAttribute('aria-expanded', 'true');
      registerHelpTargets(locationModal);
      updateHelpTooltips();
      updateLocationOptionsState();
    };

    const setLocation = (
      location,
      { persist = true, refreshRoutes = true, wallFallback = null } = {},
    ) => {
      const targetLocation = location || DEFAULT_LOCATION;
      if (!targetLocation) {
        return;
      }

      const { entry: canonicalLocation, changed: locationEntryChanged } = upsertLocation({
        key: typeof targetLocation?.key === 'string' ? targetLocation.key : '',
        name: typeof targetLocation?.name === 'string' ? targetLocation.name : '',
        image: typeof targetLocation?.image === 'string' ? targetLocation.image : '',
        fallbackName: typeof targetLocation?.name === 'string' ? targetLocation.name : '',
        hidden: Boolean(targetLocation?.hidden),
      });

      if (!canonicalLocation) {
        return;
      }

      if (locationEntryChanged) {
        renderLocationOptions();
      }

      const previousKey = getCurrentLocationKey();
      const nextKey = normalizeWallKey(canonicalLocation.key || canonicalLocation.name);
      const changed = previousKey !== nextKey;

      currentLocation = canonicalLocation;
      updateWallVisibilityControls();
      updateLocationButtonLabel();
      updateLocationOptionsState();
      updateBackgroundForCurrentLocation();
      updateDeleteWallButtonState();

      if (locationEntryChanged) {
        synchronizeCurrentLocationReference();
      }

      applyWallSettingsToStateForLocationKey(nextKey, wallFallback);
      redraw();

      updateWallNavigationTargets(nextKey);
      updateWallQueryParam(nextKey);

      if (persist) {
        persistSelectedWall(nextKey);
      }

      if (changed) {
        ensureWallSettings(nextKey)
          .then(() => {
            if (getCurrentLocationKey() !== nextKey) {
              return;
            }
            const wallSettings = getWallSettingsForLocation(nextKey);
            updateRoutesForWall(nextKey, wallSettings);
            pointDiameter = wallSettings.pointDiameter;
            unfocusedTransparency = wallSettings.unfocusedTransparency;
            gradeBarBaseHeight = wallSettings.gradeBarBaseHeight;
            gradeBarMaxHeight = wallSettings.gradeBarMaxHeight;
            gradeBarWidth = wallSettings.gradeBarWidth;
            gradeBarTransparency = wallSettings.gradeBarTransparency;
            updatePathControls();
            updateAppearanceControls();
            redraw();
          })
          .catch((error) => {
            console.warn('Failed to load wall settings:', error);
          });
      }

      if (changed && refreshRoutes) {
        prepareNewRoute();
        loadRoutesList('').catch((error) => {
          console.error('Failed to refresh routes for the selected location:', error);
        });
      }
    };

    const handleLocationSelection = (locationKey) => {
      const nextLocation = findLocationByKey(locationKey);
      if (!nextLocation) {
        return;
      }

      setLocation(nextLocation);
      closeLocationModal();
    };

    const renderLocationOptions = () => {
      if (!locationOptions) {
        return;
      }

      locationOptions.replaceChildren();

      LOCATIONS.forEach((location) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'location-option';
        button.dataset.locationKey = location.key;
        button.setAttribute('role', 'option');
        button.dataset.helpText = `Switch to ${location.name}`;

        const preview = document.createElement('div');
        preview.className = 'location-option-preview';
        preview.style.backgroundImage = `url('${location.image}')`;
        button.appendChild(preview);

        const label = document.createElement('span');
        label.className = 'location-option-label';
        const name = document.createElement('span');
        name.className = 'location-option-name';
        name.textContent = location.name;
        label.appendChild(name);

        if (location.hidden) {
          const badge = document.createElement('span');
          badge.className = 'location-option-badge';
          badge.textContent = 'Hidden';
          label.appendChild(badge);
        }
        button.appendChild(label);

        button.addEventListener('click', () => {
          handleLocationSelection(location.key);
        });

        locationOptions.appendChild(button);
      });

      registerHelpTargets(locationOptions);
      updateHelpTooltips();

      updateLocationOptionsState();
      updateDeleteWallButtonState();
    };

    function resetLocationsToBuiltins() {
      for (let index = LOCATIONS.length - 1; index >= 0; index -= 1) {
        const entry = LOCATIONS[index];
        if (!entry) {
          continue;
        }

        const normalizedKey = normalizeWallKey(entry.key || entry.name);
        if (!BUILTIN_LOCATION_KEYS.has(normalizedKey)) {
          LOCATIONS.splice(index, 1);
        }
      }

      renderLocationOptions();

      const currentKey = normalizeWallKey(currentLocation?.key || currentLocation?.name);
      if (!currentKey || !BUILTIN_LOCATION_KEYS.has(currentKey)) {
        setLocation(DEFAULT_LOCATION, { persist: true, refreshRoutes: false });
      } else {
        synchronizeCurrentLocationReference();
        updateLocationOptionsState();
      }

      updateDeleteWallButtonState();
    }

    backgroundImage.onload = () => {
      backgroundReady = true;
      if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
        const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
        if (Number.isFinite(ratio) && ratio > 0) {
          canvasAspectRatio = ratio;
        }
      }
      resizeCanvas();
    };

    backgroundImage.onerror = () => {
      backgroundReady = false;
      resizeCanvas();
    };

    const updatePanelMeasurements = () => {
      if (!controlPanel || !panelSidebar) {
        return;
      }

      const { width } = panelSidebar.getBoundingClientRect();
      if (Number.isFinite(width) && width > 0) {
        controlPanel.style.setProperty('--toggle-visible-width', `${Math.ceil(width)}px`);
      }

      let panelOffset = 0;
      if (controlPanel) {
        const panelRect = controlPanel.getBoundingClientRect();
        if (Number.isFinite(panelRect.width) && panelRect.width > 0) {
          panelOffset = Math.ceil(panelRect.width);
        }

        const isExpanded = controlPanel.getAttribute('data-expanded') !== 'false';
        if (!isExpanded) {
          const storedToggleWidth =
            controlPanel.style.getPropertyValue('--toggle-visible-width') ||
            window.getComputedStyle(controlPanel).getPropertyValue('--toggle-visible-width');
          const parsedToggleWidth = storedToggleWidth ? parseFloat(storedToggleWidth) : NaN;
          if (Number.isFinite(parsedToggleWidth) && parsedToggleWidth > 0) {
            panelOffset = Math.ceil(parsedToggleWidth);
          }
        }
      }

    };

    const updateDrawingToggle = () => {
      if (!drawingToggle) {
        return;
      }

      const label = isDrawingEnabled ? 'Disable drawing' : 'Enable drawing';
      drawingToggle.setAttribute('aria-pressed', String(isDrawingEnabled));
      const labelTarget = drawingToggle.querySelector('.sr-only');
      if (labelTarget) {
        labelTarget.textContent = label;
      }
      drawingToggle.setAttribute('aria-label', label);
      drawingToggle.setAttribute('title', label);

      if (canvas) {
        canvas.setAttribute('data-drawing-enabled', String(isDrawingEnabled));
      }
    };

    function setDrawingEnabled(value) {
      const next = Boolean(value);
      if (isDrawingEnabled === next) {
        return;
      }
      isDrawingEnabled = next;
      updateDrawingToggle();
    }

    function registerHelpTargets(root = document) {
      if (!root || typeof root.querySelectorAll !== 'function') {
        return;
      }

      const directMatch =
        root instanceof Element && root.matches('[data-help-text]') ? [root] : [];
      const candidates = [...directMatch, ...root.querySelectorAll('[data-help-text]')];
      candidates.forEach((element) => {
        if (helpTargets.has(element)) {
          return;
        }
        if (infoButton && infoButton.contains(element)) {
          return;
        }
        const text = element.dataset?.helpText;
        if (!text) {
          return;
        }
        const tooltip = document.createElement('span');
        tooltip.className = 'help-tooltip';
        tooltip.textContent = text;
        tooltip.setAttribute('role', 'note');
        tooltip.hidden = true;
        element.appendChild(tooltip);
        helpTargets.set(element, tooltip);
      });
    }

    function isElementVisible(element) {
      if (!element || !element.isConnected) {
        return false;
      }
      if (element.closest('.hidden')) {
        return false;
      }
      const rect = element.getBoundingClientRect();
      return rect.width > 0 && rect.height > 0;
    }

    function setTutorialDescriptionContent(content = []) {
      if (!tutorialDescription) {
        return;
      }

      tutorialDescription.innerHTML = '';

      const fragment = document.createDocumentFragment();
      const items = Array.isArray(content) ? content : [content];

      items.forEach((item) => {
        if (typeof item === 'string') {
          const paragraph = document.createElement('p');
          paragraph.textContent = item;
          fragment.appendChild(paragraph);
          return;
        }

        if (typeof item === 'function') {
          try {
            const result = item();
            if (result instanceof Node) {
              fragment.appendChild(result);
              return;
            }

            if (typeof result === 'string') {
              const paragraph = document.createElement('p');
              paragraph.textContent = result;
              fragment.appendChild(paragraph);
            }
          } catch (error) {
            console.warn('Unable to render tutorial content item:', error);
          }
          return;
        }

        if (item instanceof Node) {
          fragment.appendChild(item);
        }
      });

      tutorialDescription.appendChild(fragment);
    }

    function ensureTutorialPointer() {
      if (tutorialPointer) {
        return tutorialPointer;
      }

      tutorialPointer = document.createElement('div');
      tutorialPointer.className = 'tutorial-pointer hidden';
      tutorialPointer.setAttribute('aria-hidden', 'true');
      tutorialPointer.innerHTML =
        '<svg viewBox="0 0 64 96" role="presentation" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><path fill="#27b4db" d="M32 0l32 36H44v56H20V36H0z"/></svg>';
      document.body.appendChild(tutorialPointer);

      return tutorialPointer;
    }

    function updateTutorialPointerPosition() {
      if (!tutorialPointer || tutorialPointer.classList.contains('hidden')) {
        return;
      }

      if (!tutorialPointerTarget || !isElementVisible(tutorialPointerTarget)) {
        hideTutorialPointer();
        return;
      }

      const rect = tutorialPointerTarget.getBoundingClientRect();
      const verticalOffset = 12;

      tutorialPointer.style.left = `${rect.left + rect.width / 2}px`;
      tutorialPointer.style.top = `${rect.bottom + verticalOffset}px`;
    }

    function showTutorialPointerFor(element) {
      if (!(element instanceof HTMLElement) || !isElementVisible(element)) {
        hideTutorialPointer();
        return;
      }

      ensureTutorialPointer();

      tutorialPointerTarget = element;
      tutorialPointer.classList.remove('hidden');
      tutorialPointer.setAttribute('aria-hidden', 'false');
      updateTutorialPointerPosition();
    }

    function hideTutorialPointer() {
      if (!tutorialPointer) {
        tutorialPointerTarget = null;
        return;
      }

      tutorialPointerTarget = null;
      tutorialPointer.classList.add('hidden');
      tutorialPointer.setAttribute('aria-hidden', 'true');
    }

    window.addEventListener('resize', updateTutorialPointerPosition);
    window.addEventListener('scroll', updateTutorialPointerPosition, true);

    function highlightTutorialElement(element, options = {}) {
      const shouldIlluminate = options?.illuminate === true;

      if (tutorialHighlightedElement) {
        if (tutorialHighlightedElement !== element || !element) {
          tutorialHighlightedElement.classList.remove('tutorial-highlight');
          tutorialHighlightedElement.classList.remove('tutorial-illuminated');
          tutorialHighlightedElementOptions = { illuminate: false };
        } else if (tutorialHighlightedElementOptions.illuminate !== shouldIlluminate) {
          tutorialHighlightedElement.classList.toggle('tutorial-illuminated', shouldIlluminate);
          tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
          return;
        } else {
          return;
        }
      }

      if (element instanceof HTMLElement) {
        element.classList.add('tutorial-highlight');
        element.classList.toggle('tutorial-illuminated', shouldIlluminate);
        tutorialHighlightedElement = element;
        tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
      } else {
        tutorialHighlightedElement = null;
        tutorialHighlightedElementOptions = { illuminate: false };
      }
    }

    function setTutorialOverlayAlignment(alignment = 'center') {
      if (!tutorialOverlay) {
        return;
      }

      const shouldAlignBottom = alignment === 'bottom';
      tutorialOverlay.classList.toggle('is-bottom-aligned', shouldAlignBottom);
    }

    function openTutorialOverlay() {
      if (!tutorialOverlay) {
        return;
      }

      tutorialPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;

      tutorialOverlay.classList.remove('hidden');
      tutorialOverlay.setAttribute('aria-hidden', 'false');

      if (tutorialDialogCard && typeof tutorialDialogCard.focus === 'function') {
        tutorialDialogCard.focus();
      }
    }

    function closeTutorialOverlay() {
      if (!tutorialOverlay) {
        return;
      }

      tutorialOverlay.classList.add('hidden');
      tutorialOverlay.setAttribute('aria-hidden', 'true');

      if (tutorialPreviousFocus && typeof tutorialPreviousFocus.focus === 'function') {
        tutorialPreviousFocus.focus();
      }

      tutorialPreviousFocus = null;
    }

    function attachTutorialKeydown() {
      document.addEventListener('keydown', handleTutorialKeydown, true);
    }

    function detachTutorialKeydown() {
      document.removeEventListener('keydown', handleTutorialKeydown, true);
    }

    function renderTutorialStep() {
      if (!tutorialActive) {
        return;
      }

      const step = tutorialSteps[tutorialStepIndex];
      if (!step) {
        return;
      }

      if (tutorialTitle) {
        tutorialTitle.textContent = step.title || '';
      }

      setTutorialDescriptionContent(step.body || []);

      if (tutorialProgress) {
        tutorialProgress.textContent = `Step ${tutorialStepIndex + 1} of ${tutorialSteps.length}`;
        tutorialProgress.classList.toggle('hidden', tutorialSteps.length <= 1);
      }

      if (tutorialPrimaryAction) {
        tutorialPrimaryAction.textContent =
          tutorialStepIndex === tutorialSteps.length - 1 ? 'Finish' : 'Next';
      }

      if (tutorialSecondaryAction) {
        const secondaryConfig = step.secondaryAction || null;
        let secondaryLabel = 'Back';
        let shouldShowSecondary = tutorialStepIndex > 0;
        tutorialSecondaryActionMode = 'back';

        if (secondaryConfig && (secondaryConfig.mode === 'skip' || secondaryConfig.mode === 'close')) {
          tutorialSecondaryActionMode = 'skip';
          secondaryLabel =
            typeof secondaryConfig.label === 'string' && secondaryConfig.label.trim().length
              ? secondaryConfig.label
              : 'Skip';
          shouldShowSecondary = true;
        }

        tutorialSecondaryAction.textContent = secondaryLabel;
        tutorialSecondaryAction.dataset.mode = tutorialSecondaryActionMode;
        tutorialSecondaryAction.classList.toggle('hidden', !shouldShowSecondary);
      }
    }

    function buildSetterTutorialSteps() {
      const steps = [
        {
          title: 'Welcome to the setter workspace',
          body: [
            'Design, update, and publish climbs from here. The wall preview on the left responds instantly as you draw or tweak route details.',
            'Use the sidebar tabs to switch between saved routes, manage walls, and adjust how problems appear to climbers.',
          ],
          secondaryAction: { mode: 'skip', label: 'Skip' },
          onEnter: () => {
            setTutorialOverlayAlignment('center');
            highlightTutorialElement(null);
            hideTutorialPointer();
            deactivateInfoMode({ clearTooltip: true });
          },
          onExit: () => {
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Routes panel',
          body: [
            'Select existing problems or start fresh, then fill in setter info, descriptions, and notes for climbers.',
            'Pick colours, change path types, and save or clear drawings while you iterate on new ideas.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            activateTab('routesTab');
            if (routesTabButton && isElementVisible(routesTabButton)) {
              highlightTutorialElement(routesTabButton, { illuminate: true });
              showTutorialPointerFor(routesTabButton);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Walls panel',
          body: [
            'Switch the active wall, create new backgrounds, or temporarily hide a wall from climbers.',
            'Use it to manage rotations and keep your wall list tidy as sets change over time.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            activateTab('wallsTab');
            if (wallsTabButton && isElementVisible(wallsTabButton)) {
              highlightTutorialElement(wallsTabButton, { illuminate: true });
              showTutorialPointerFor(wallsTabButton);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Configuration panel',
          body: [
            'Tune how holds render by adjusting point sizes, rectangle dimensions, and transparency defaults.',
            'Save appearance settings so climbers see consistent visuals across every wall you manage.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            activateTab('configurationTab');
            if (configurationTabButton && isElementVisible(configurationTabButton)) {
              highlightTutorialElement(configurationTabButton, { illuminate: true });
              showTutorialPointerFor(configurationTabButton);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Enable drawing',
          body: [
            'Toggle drawing mode when you want to sketch new holds or edit existing shapes directly on the wall.',
            'Switch it off to pan around freely or inspect details without leaving stray marks behind.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            if (drawingToggle && isElementVisible(drawingToggle)) {
              highlightTutorialElement(drawingToggle, { illuminate: true });
              showTutorialPointerFor(drawingToggle);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Info mode',
          body: [
            'Tap the info button any time for quick tooltips explaining each control in the sidebar.',
            'Info mode stays active until you toggle it off, so you can explore every setting at your own pace.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            deactivateInfoMode({ clearTooltip: true });
            if (infoButton && isElementVisible(infoButton)) {
              highlightTutorialElement(infoButton, { illuminate: true });
              showTutorialPointerFor(infoButton);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
      ];

      return steps;
    }

    async function goToTutorialStep(index) {
      if (!tutorialActive || tutorialTransitionInProgress) {
        return;
      }

      if (index < 0 || index >= tutorialSteps.length) {
        return;
      }

      tutorialTransitionInProgress = true;

      if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
        const currentStep = tutorialSteps[tutorialStepIndex];
        if (currentStep && typeof currentStep.onExit === 'function') {
          try {
            await currentStep.onExit();
          } catch (error) {
            console.warn('Tutorial step cleanup failed:', error);
          }
        }
      }

      tutorialStepIndex = index;
      renderTutorialStep();

      const nextStep = tutorialSteps[tutorialStepIndex];
      if (nextStep && typeof nextStep.onEnter === 'function') {
        try {
          await nextStep.onEnter();
        } catch (error) {
          console.warn('Tutorial step setup failed:', error);
        }
      }

      tutorialTransitionInProgress = false;

      if (tutorialPrimaryAction) {
        tutorialPrimaryAction.focus();
      }
    }

    async function startTutorial() {
      if (tutorialActive) {
        return;
      }

      tutorialSteps = buildSetterTutorialSteps();
      if (!Array.isArray(tutorialSteps) || tutorialSteps.length === 0) {
        return;
      }

      const activeTabButton = tabButtons.find((button) => button?.getAttribute('aria-selected') === 'true');
      tutorialPreviousTabId = activeTabButton?.dataset?.target || null;

      tutorialActive = true;
      tutorialStepIndex = -1;
      tutorialTransitionInProgress = false;
      tutorialSecondaryActionMode = 'back';

      if (tutorialProgress) {
        tutorialProgress.classList.remove('hidden');
      }

      setTutorialOverlayAlignment('center');
      openTutorialOverlay();
      attachTutorialKeydown();

      await goToTutorialStep(0);
    }

    async function finishTutorial() {
      if (!tutorialActive && !tutorialTransitionInProgress) {
        tutorialPreviousTabId = null;
        tutorialSecondaryActionMode = 'back';
        return;
      }

      tutorialTransitionInProgress = true;

      if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
        const finalStep = tutorialSteps[tutorialStepIndex];
        if (finalStep && typeof finalStep.onExit === 'function') {
          try {
            await finalStep.onExit();
          } catch (error) {
            console.warn('Tutorial completion cleanup failed:', error);
          }
        }
      }

      tutorialActive = false;
      tutorialStepIndex = -1;
      tutorialTransitionInProgress = false;
      tutorialSteps = [];
      tutorialSecondaryActionMode = 'back';

      highlightTutorialElement(null);
      hideTutorialPointer();
      setTutorialOverlayAlignment('center');

      if (tutorialProgress) {
        tutorialProgress.classList.add('hidden');
      }

      closeTutorialOverlay();
      detachTutorialKeydown();

      if (tutorialPreviousTabId) {
        activateTab(tutorialPreviousTabId);
      } else {
        activateTab('routesTab');
      }

      tutorialPreviousTabId = null;
    }

    function handleTutorialKeydown(event) {
      if (!tutorialActive) {
        return;
      }

      if (event.key === 'Escape') {
        event.preventDefault();
        void finishTutorial();
        return;
      }

      if (event.key === 'ArrowRight') {
        event.preventDefault();
        if (tutorialStepIndex >= tutorialSteps.length - 1) {
          void finishTutorial();
        } else {
          void goToTutorialStep(tutorialStepIndex + 1);
        }
        return;
      }

      if (event.key === 'ArrowLeft') {
        event.preventDefault();
        if (tutorialStepIndex > 0) {
          void goToTutorialStep(tutorialStepIndex - 1);
        }
      }
    }

    function updateHelpTooltips() {
      if (!activeHelpEntry) {
        return;
      }

      const { element } = activeHelpEntry;
      if (!element || !element.isConnected) {
        clearActiveHelpTooltip();
        return;
      }

      if (!helpTargets.has(element)) {
        registerHelpTargets(element);
      }

      const tooltip = helpTargets.get(element);
      if (!tooltip) {
        clearActiveHelpTooltip();
        return;
      }

      activeHelpEntry.tooltip = tooltip;

      const activePanel = document.querySelector('.tab-panel[aria-hidden="false"]');
      const panelCollapsed = controlPanel?.getAttribute('data-expanded') === 'false';
      const modalAncestor = element.closest('.location-modal');
      const inVisibleModal = Boolean(
        modalAncestor && !modalAncestor.classList.contains('hidden'),
      );
      const insideControlPanel = controlPanel ? controlPanel.contains(element) : false;
      const inActivePanel = activePanel ? activePanel.contains(element) : true;
      const visible = isElementVisible(element);
      const shouldShow =
        visible &&
        (!panelCollapsed || !insideControlPanel) &&
        (inActivePanel || inVisibleModal || (!activePanel && visible));

      element.classList.toggle('showing-help', shouldShow);
      tooltip.hidden = !shouldShow;
    }

    function setInfoButtonActiveState(active) {
      if (!infoButton) {
        return;
      }

      const label = active ? 'Hide setter help' : 'Learn about setter tools';
      infoButton.setAttribute('aria-label', label);
      infoButton.setAttribute('title', label);
      infoButton.setAttribute('aria-pressed', active ? 'true' : 'false');
      infoButton.setAttribute('aria-expanded', active ? 'true' : 'false');
      infoButton.classList.toggle('is-active', active);

      const srTarget = infoButton.querySelector('.sr-only');
      if (srTarget) {
        srTarget.textContent = label;
      }
    }

    function showInfoPopover() {
      if (!infoPopover) {
        return;
      }

      infoPopover.classList.remove('hidden');
      infoPopover.setAttribute('aria-hidden', 'false');
      if (typeof infoPopover.focus === 'function') {
        infoPopover.focus({ preventScroll: true });
      }
    }

    function hideInfoPopover() {
      if (!infoPopover) {
        return;
      }

      infoPopover.classList.add('hidden');
      infoPopover.setAttribute('aria-hidden', 'true');
    }

    function clearActiveHelpTooltip() {
      if (!activeHelpEntry) {
        return;
      }

      const { element, tooltip } = activeHelpEntry;
      if (element) {
        element.classList.remove('showing-help');
      }
      if (tooltip) {
        tooltip.hidden = true;
      }
      activeHelpEntry = null;
    }

    function showHelpTooltipForElement(element) {
      if (!element) {
        return null;
      }

      registerHelpTargets(element);
      const tooltip = helpTargets.get(element);
      if (!tooltip) {
        return null;
      }

      if (activeHelpEntry && activeHelpEntry.element !== element) {
        clearActiveHelpTooltip();
      }

      activeHelpEntry = { element, tooltip };
      updateHelpTooltips();
      return activeHelpEntry;
    }

    function activateInfoMode() {
      if (infoModeActive) {
        return;
      }

      infoModeActive = true;
      awaitingHelpTargetSelection = true;
      clearActiveHelpTooltip();
      setInfoButtonActiveState(true);
      showInfoPopover();
    }

    function deactivateInfoMode({ clearTooltip = false } = {}) {
      awaitingHelpTargetSelection = false;

      if (infoModeActive) {
        infoModeActive = false;
      }

      setInfoButtonActiveState(false);
      hideInfoPopover();

      if (clearTooltip) {
        clearActiveHelpTooltip();
      }
    }

    const isInteractiveElement = (element) => {
      if (!element) {
        return false;
      }

      const candidate = element instanceof Element ? element : element.parentElement;
      if (!candidate) {
        return false;
      }

      if (candidate.isContentEditable) {
        return true;
      }

      if (typeof candidate.closest === 'function') {
        if (candidate.closest('[contenteditable="true"]')) {
          return true;
        }

        if (candidate.closest('input, textarea, select, button, a')) {
          return true;
        }
      }

      const tagName = typeof candidate.tagName === 'string' ? candidate.tagName.toLowerCase() : '';
      return (
        tagName === 'input' ||
        tagName === 'textarea' ||
        tagName === 'select' ||
        tagName === 'button' ||
        tagName === 'a'
      );
    };

    const updatePanModifierState = (active) => {
      isPanModifierActive = Boolean(active);

      if (!canvas) {
        return;
      }

      if (isPanModifierActive) {
        canvas.setAttribute('data-pan-modifier', 'true');
      } else {
        canvas.removeAttribute('data-pan-modifier');
      }
    };

    const hasScrollableCanvasArea = () => {
      if (!canvasContainer) {
        return false;
      }

      if (isCanvasScrollable) {
        return true;
      }

      return (
        canvasContainer.scrollWidth > canvasContainer.clientWidth ||
        canvasContainer.scrollHeight > canvasContainer.clientHeight
      );
    };

    const beginCanvasPan = (event) => {
      if (!canvasContainer || !canvas || !hasScrollableCanvasArea()) {
        return false;
      }

      isPointerPanning = true;
      panPointerId = event.pointerId;
      panPointerButton = event.button;
      panStartScrollLeft = canvasContainer.scrollLeft;
      panStartScrollTop = canvasContainer.scrollTop;
      panOriginX = event.clientX;
      panOriginY = event.clientY;
      shouldIgnoreNextClick = event.button === 0;

      canvas.classList.add('is-panning');

      if (typeof canvas.setPointerCapture === 'function') {
        try {
          canvas.setPointerCapture(event.pointerId);
        } catch (error) {
          // Ignore pointer capture errors (e.g., unsupported platforms).
        }
      }

      if (typeof event.preventDefault === 'function') {
        event.preventDefault();
      }

      return true;
    };

    const moveCanvasPan = (event) => {
      if (!isPointerPanning || event.pointerId !== panPointerId || !canvasContainer) {
        return;
      }

      const deltaX = event.clientX - panOriginX;
      const deltaY = event.clientY - panOriginY;

      canvasContainer.scrollLeft = panStartScrollLeft - deltaX;
      canvasContainer.scrollTop = panStartScrollTop - deltaY;
    };

    const endCanvasPan = () => {
      if (!isPointerPanning) {
        return;
      }

      if (
        canvas &&
        panPointerId !== null &&
        typeof canvas.hasPointerCapture === 'function' &&
        canvas.hasPointerCapture(panPointerId)
      ) {
        try {
          canvas.releasePointerCapture(panPointerId);
        } catch (error) {
          // Ignore pointer capture release errors.
        }
      }

      canvas?.classList.remove('is-panning');

      if (panPointerButton !== 0) {
        shouldIgnoreNextClick = false;
      }

      isPointerPanning = false;
      panPointerId = null;
      panPointerButton = 0;
    };

    const handleCanvasPointerDown = (event) => {
      const isPrimaryButton = event.button === 0;
      const isMiddleButton = event.button === 1;
      const panWithPrimary = isPrimaryButton && (!isDrawingEnabled || isPanModifierActive);

      if (isMiddleButton || panWithPrimary) {
        if (beginCanvasPan(event)) {
          return;
        }
      }

      shouldIgnoreNextClick = false;
    };

    const handleCanvasPointerMove = (event) => {
      moveCanvasPan(event);
    };

    const handleCanvasPointerEnd = (event) => {
      if (!isPointerPanning || event.pointerId !== panPointerId) {
        return;
      }

      endCanvasPan();
    };

    deleteButton.disabled = true;
    routeSelector.disabled = true;
    if (grantSetterButton) {
      grantSetterButton.disabled = true;
    }
    if (roleUsernameInput) {
      roleUsernameInput.disabled = true;
    }

    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('colorPicker');
    const pathTypeSelect = document.getElementById('pathTypeSelect');
    const pointDiameterField = document.getElementById('pointDiameterField');
    const pointDiameterSlider = document.getElementById('pointDiameterSlider');
    const pointDiameterValue = document.getElementById('pointDiameterValue');
    const rectangleWidthField = document.getElementById('rectangleWidthField');
    const rectangleWidthSlider = document.getElementById('rectangleWidthSlider');
    const rectangleWidthValue = document.getElementById('rectangleWidthValue');
    const rectangleHeightField = document.getElementById('rectangleHeightField');
    const rectangleHeightSlider = document.getElementById('rectangleHeightSlider');
    const rectangleHeightValue = document.getElementById('rectangleHeightValue');
    const unfocusedTransparencyField = document.getElementById('unfocusedTransparencyField');
    const unfocusedTransparencySlider = document.getElementById('unfocusedTransparencySlider');
    const appearancePointDiameterInput = document.getElementById('appearancePointDiameterInput');
    const gradeBarBaseHeightInput = document.getElementById('gradeBarBaseHeightInput');
    const gradeBarMaxHeightInput = document.getElementById('gradeBarMaxHeightInput');
    const gradeBarWidthInput = document.getElementById('gradeBarWidthInput');
    const gradeBarTransparencyInput = document.getElementById('gradeBarTransparencyInput');
    const saveAppearanceButton = document.getElementById('saveAppearanceButton');
    const advancedColorToggle = document.getElementById('advancedColorToggle');
    const advancedColorPicker = document.getElementById('advancedColorPicker');
    const colorWheelCanvas = document.getElementById('colorWheelCanvas');
    const colorWheelMarker = document.getElementById('colorWheelMarker');
    const colorLightnessSlider = document.getElementById('colorLightnessSlider');
    const colorWheelValue = document.getElementById('colorWheelValue');
    const colorWheelSwatch = document.getElementById('colorWheelSwatch');
    const clearButton = document.getElementById('clearButton');
    const saveButton = document.getElementById('saveButton');
    const cancelRouteButton = document.getElementById('cancelRouteButton');

    const SYNTHETIC_EMAIL_DOMAIN = 'users.anuascend.local';
    const USERNAME_PATTERN = /^[a-z0-9_]{3,20}$/;
    const SETTER_NAME_PATTERN = /^[a-z0-9_ ]{3,40}$/;

    const normalizeUsername = (value) => {
      if (typeof value !== 'string') {
        return '';
      }
      return value.trim().toLowerCase();
    };

    const normalizeSetterName = (value) => {
      if (typeof value !== 'string') {
        return '';
      }
      return value
        .trim()
        .toLowerCase()
        .replace(/\s+/g, ' ');
    };

    function normalizePathType(value) {
      if (typeof value === 'string') {
        const normalized = value.trim().toLowerCase();
        if (normalized === PATH_TYPE_POINT) {
          return PATH_TYPE_POINT;
        }
        if (normalized === PATH_TYPE_RECTANGLE) {
          return PATH_TYPE_RECTANGLE;
        }
      }
      return DEFAULT_PATH_TYPE;
    }

    function normalizePointDiameter(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_POINT_DIAMETER;
      }
      const clamped = Math.min(Math.max(Math.round(numeric), MIN_POINT_DIAMETER), MAX_POINT_DIAMETER);
      return clamped;
    }

    function normalizeRectangleSize(value, fallback = DEFAULT_RECTANGLE_WIDTH) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return fallback;
      }
      const clamped = Math.min(
        Math.max(Math.round(numeric), MIN_RECTANGLE_SIZE),
        MAX_RECTANGLE_SIZE,
      );
      return clamped;
    }

    function normalizeGradeBarHeight(value, fallback) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return fallback;
      }
      const clamped = Math.min(
        Math.max(numeric, MIN_GRADE_BAR_BASE_HEIGHT),
        MAX_GRADE_BAR_HEIGHT,
      );
      return Math.round(clamped);
    }

    function normalizeGradeBarWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_GRADE_BAR_WIDTH;
      }
      const clamped = Math.min(
        Math.max(Math.round(numeric), MIN_GRADE_BAR_WIDTH),
        MAX_GRADE_BAR_WIDTH,
      );
      return clamped;
    }

    function normalizeGradeBarTransparency(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_GRADE_BAR_TRANSPARENCY;
      }
      const clamped = Math.min(Math.max(numeric, 0), 1);
      return Math.round(clamped * 1000) / 1000;
    }

    function normalizeGradeValue(value) {
      if (value === null || value === undefined) {
        return null;
      }

      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }

      if (!Number.isInteger(numeric)) {
        return null;
      }

      if (numeric < MIN_GRADE_VALUE || numeric > MAX_GRADE_VALUE) {
        return null;
      }

      return numeric;
    }

    function normalizeUnfocusedTransparency(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_UNFOCUSED_TRANSPARENCY;
      }
      const clamped = Math.min(
        Math.max(numeric, MIN_UNFOCUSED_TRANSPARENCY),
        MAX_UNFOCUSED_TRANSPARENCY,
      );
      return Math.round(clamped * 1000) / 1000;
    }

    function convertUnfocusedTransparencyToSliderValue(value) {
      return Math.round(normalizeUnfocusedTransparency(value) * 100);
    }

    function sliderValueToUnfocusedTransparency(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_UNFOCUSED_TRANSPARENCY;
      }
      return normalizeUnfocusedTransparency(numeric / 100);
    }

    function createDefaultWallSettings() {
      return {
        pointDiameter: DEFAULT_POINT_DIAMETER,
        rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
        rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
        unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
        gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
        gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
        gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
        gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
      };
    }

    function normalizeWallSettings(raw = {}) {
      if (!raw || typeof raw !== 'object') {
        return createDefaultWallSettings();
      }

      const pointDiameter = normalizePointDiameter(raw.pointDiameter);
      const rectangleWidth = normalizeRectangleSize(
        raw.rectangleWidth,
        DEFAULT_RECTANGLE_WIDTH,
      );
      const rectangleHeight = normalizeRectangleSize(
        raw.rectangleHeight,
        DEFAULT_RECTANGLE_HEIGHT,
      );
      const gradeBarBaseHeight = normalizeGradeBarHeight(
        raw.gradeBarBaseHeight,
        DEFAULT_GRADE_BAR_BASE_HEIGHT,
      );
      const gradeBarMaxHeight = Math.max(
        gradeBarBaseHeight,
        normalizeGradeBarHeight(raw.gradeBarMaxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
      );
      const gradeBarWidth = normalizeGradeBarWidth(raw.gradeBarWidth);
      const gradeBarTransparency = normalizeGradeBarTransparency(
        raw.gradeBarTransparency ?? raw.transparency,
      );
      return {
        pointDiameter,
        rectangleWidth,
        rectangleHeight,
        unfocusedTransparency: normalizeUnfocusedTransparency(raw.unfocusedTransparency),
        gradeBarBaseHeight,
        gradeBarMaxHeight,
        gradeBarWidth,
        gradeBarTransparency,
      };
    }

    function getWallSettingsWithFallback(locationKey, fallback = null) {
      const key = normalizeWallKey(locationKey);
      if (key) {
        const cached = wallSettingsCache.get(key);
        if (cached) {
          return { ...cached };
        }
      }

      if (fallback) {
        const normalized = normalizeWallSettings(fallback);
        if (key) {
          wallSettingsCache.set(key, normalized);
        }
        return normalized;
      }

      return createDefaultWallSettings();
    }

    function getWallSettingsForLocation(locationKey) {
      return getWallSettingsWithFallback(locationKey);
    }

    function applyWallSettingsToStateForLocationKey(locationKey, fallback = null) {
      const settings = getWallSettingsWithFallback(locationKey, fallback);
      pointDiameter = settings.pointDiameter;
      rectangleWidth = settings.rectangleWidth;
      rectangleHeight = settings.rectangleHeight;
      unfocusedTransparency = settings.unfocusedTransparency;
      gradeBarBaseHeight = settings.gradeBarBaseHeight;
      gradeBarMaxHeight = settings.gradeBarMaxHeight;
      gradeBarWidth = settings.gradeBarWidth;
      gradeBarTransparency = settings.gradeBarTransparency;
      updatePathControls();
      updateAppearanceControls();
    }

    function getCurrentLocationKey() {
      if (currentLocation?.key) {
        return normalizeWallKey(currentLocation.key);
      }
      return normalizeLocationName(currentLocation?.name);
    }

    async function ensureWallSettings(locationKey) {
      const key = normalizeWallKey(locationKey);
      if (!key) {
        return createDefaultWallSettings();
      }

      if (wallSettingsCache.has(key)) {
        return { ...wallSettingsCache.get(key) };
      }

      try {
        const docId = wallDocumentIdMap.get(key) || key;
        const wallRef = doc(db, WALL_COLLECTION, docId);
        const snap = await getDoc(wallRef);
        if (snap.exists()) {
          const data = snap.data();
          const settings = normalizeWallSettings(data);
          const normalizedId = normalizeWallKey(snap.id);
          const normalizedName = normalizeWallKey(data?.name);

          if (normalizedId) {
            wallSettingsCache.set(normalizedId, settings);
            wallDocumentIdMap.set(normalizedId, snap.id);
          }

          if (normalizedName) {
            wallDocumentIdMap.set(normalizedName, snap.id);
            if (!wallSettingsCache.has(normalizedName)) {
              wallSettingsCache.set(normalizedName, settings);
            }
          }

          if (data?.key) {
            const normalizedLocationKey = normalizeWallKey(data.key);
            if (normalizedLocationKey) {
              wallDocumentIdMap.set(normalizedLocationKey, snap.id);
              if (!wallSettingsCache.has(normalizedLocationKey)) {
                wallSettingsCache.set(normalizedLocationKey, settings);
              }
            }
          }

          const { changed: locationChanged } = upsertLocation({
            key: typeof data?.key === 'string' ? data.key : snap.id,
            name: typeof data?.name === 'string' ? data.name : '',
            image: typeof data?.background_url === 'string' ? data.background_url : '',
            fallbackName: typeof data?.name === 'string' && data.name ? data.name : snap.id,
            hidden: Boolean(data?.hidden),
          });

          if (locationChanged) {
            renderLocationOptions();
            synchronizeCurrentLocationReference();
          }

          return { ...settings };
        }
      } catch (error) {
        console.warn(`Failed to load wall settings for ${locationKey}:`, error);
      }

      return createDefaultWallSettings();
    }

    async function refreshWallSettingsCache() {
      try {
        const snapshot = await getDocs(collection(db, WALL_COLLECTION));
        const fetchedKeys = new Set();
        wallDocumentIdMap.clear();
        let locationsChanged = false;
        snapshot.forEach((docSnap) => {
          const data = docSnap.data();
          const settings = normalizeWallSettings(data);
          const normalizedId = normalizeWallKey(docSnap.id);
          const normalizedName = normalizeWallKey(data?.name);

          if (normalizedId) {
            wallSettingsCache.set(normalizedId, settings);
            wallDocumentIdMap.set(normalizedId, docSnap.id);
            fetchedKeys.add(normalizedId);
          }

          if (normalizedName) {
            wallDocumentIdMap.set(normalizedName, docSnap.id);
            wallSettingsCache.set(normalizedName, settings);
            fetchedKeys.add(normalizedName);
          }

          if (data?.key) {
            const normalizedLocationKey = normalizeWallKey(data.key);
            if (normalizedLocationKey) {
              wallDocumentIdMap.set(normalizedLocationKey, docSnap.id);
              wallSettingsCache.set(normalizedLocationKey, settings);
              fetchedKeys.add(normalizedLocationKey);
            }
          }

          const { changed } = upsertLocation({
            key: typeof data?.key === 'string' ? data.key : docSnap.id,
            name: typeof data?.name === 'string' ? data.name : '',
            image: typeof data?.background_url === 'string' ? data.background_url : '',
            fallbackName: typeof data?.name === 'string' && data.name ? data.name : docSnap.id,
            hidden: Boolean(data?.hidden),
          });

          if (changed) {
            locationsChanged = true;
          }
        });

        wallSettingsCache.forEach((value, key) => {
          if (!fetchedKeys.has(key)) {
            wallSettingsCache.delete(key);
          }
        });

        if (locationsChanged) {
          renderLocationOptions();
          synchronizeCurrentLocationReference();
        }
      } catch (error) {
        console.warn('Failed to refresh wall settings:', error);
      }
    }

    function updateRoutesForWall(locationKey, settings) {
      const normalizedKey = normalizeWallKey(locationKey);
      if (!normalizedKey || !settings) {
        return;
      }

      routesCache.forEach((data, routeKey) => {
        const routeLocationKey = normalizeWallKey(
          typeof data?.locationKey === 'string'
            ? data.locationKey
            : normalizeLocationName(data?.location),
        );
        if (routeLocationKey === normalizedKey) {
          routesCache.set(routeKey, {
            ...data,
            pointDiameter: settings.pointDiameter,
            rectangleWidth: settings.rectangleWidth,
            rectangleHeight: settings.rectangleHeight,
            gradeBarBaseHeight: settings.gradeBarBaseHeight,
            gradeBarMaxHeight: settings.gradeBarMaxHeight,
            gradeBarWidth: settings.gradeBarWidth,
            gradeBarTransparency: settings.gradeBarTransparency,
          });
        }
      });
    }

    function updateRoutesForAllWalls() {
      routesCache.forEach((data, key) => {
        const routeLocationKey = normalizeWallKey(
          typeof data?.locationKey === 'string'
            ? data.locationKey
            : normalizeLocationName(data?.location),
        );
        const settings = getWallSettingsForLocation(routeLocationKey);
        routesCache.set(key, {
          ...data,
          pointDiameter: settings.pointDiameter,
          rectangleWidth: settings.rectangleWidth,
          rectangleHeight: settings.rectangleHeight,
          gradeBarBaseHeight: settings.gradeBarBaseHeight,
          gradeBarMaxHeight: settings.gradeBarMaxHeight,
          gradeBarWidth: settings.gradeBarWidth,
          gradeBarTransparency: settings.gradeBarTransparency,
        });
      });
    }

    async function persistWallSettings(locationKey, updates = {}) {
      const normalizedKey = normalizeWallKey(locationKey);
      if (!normalizedKey) {
        return;
      }

      const merged = normalizeWallSettings({
        ...getWallSettingsForLocation(normalizedKey),
        ...updates,
      });

      wallSettingsCache.set(normalizedKey, merged);
      updateRoutesForWall(normalizedKey, merged);

      if (getCurrentLocationKey() === normalizedKey) {
        pointDiameter = merged.pointDiameter;
        unfocusedTransparency = merged.unfocusedTransparency;
        gradeBarBaseHeight = merged.gradeBarBaseHeight;
        gradeBarMaxHeight = merged.gradeBarMaxHeight;
        gradeBarWidth = merged.gradeBarWidth;
        gradeBarTransparency = merged.gradeBarTransparency;
        updatePathControls();
        updateAppearanceControls();
        redraw();
      } else {
        redraw();
      }

      try {
        const locationDetails =
          (currentLocation && normalizeWallKey(currentLocation.name) === normalizedKey
            ? currentLocation
            : null) ||
          findLocationByName(normalizedKey) ||
          null;

        const wallPayload = {
          pointDiameter: merged.pointDiameter,
          rectangleWidth: merged.rectangleWidth,
          rectangleHeight: merged.rectangleHeight,
          unfocusedTransparency: merged.unfocusedTransparency,
          gradeBarBaseHeight: merged.gradeBarBaseHeight,
          gradeBarMaxHeight: merged.gradeBarMaxHeight,
          gradeBarWidth: merged.gradeBarWidth,
          transparency: merged.gradeBarTransparency,
          updatedAt: serverTimestamp(),
          key: normalizedKey,
        };

        if (locationDetails) {
          const { name, image } = locationDetails;
          if (typeof name === 'string' && name.trim()) {
            wallPayload.name = name.trim();
          }

          if (typeof image === 'string' && image.trim()) {
            wallPayload.background_url = image.trim();
          }
        }

        const docId = wallDocumentIdMap.get(normalizedKey) || normalizedKey;
        await setDoc(doc(db, WALL_COLLECTION, docId), wallPayload, { merge: true });
        wallDocumentIdMap.set(normalizedKey, docId);

        if (typeof wallPayload.name === 'string' && wallPayload.name) {
          const normalizedName = normalizeWallKey(wallPayload.name);
          if (normalizedName) {
            wallDocumentIdMap.set(normalizedName, docId);
            if (!wallSettingsCache.has(normalizedName)) {
              wallSettingsCache.set(normalizedName, merged);
            }
          }
        }

        if (locationDetails?.key) {
          const normalizedLocationKey = normalizeWallKey(locationDetails.key);
          if (normalizedLocationKey) {
            wallDocumentIdMap.set(normalizedLocationKey, docId);
            if (!wallSettingsCache.has(normalizedLocationKey)) {
              wallSettingsCache.set(normalizedLocationKey, merged);
            }
          }
        }
      } catch (error) {
        console.error('Failed to save wall settings:', error);
        setStatus('Failed to save wall settings. Please try again.', 'error');
        throw error;
      }
    }

    async function handleCreateWall() {
      if (isCreatingWall) {
        return;
      }

      clearCreateWallStatusMessage();

      const rawName = newWallNameInput?.value ?? '';
      const trimmedName = rawName.trim();
      if (!trimmedName) {
        setCreateWallStatusMessage('Enter a wall name.', 'error');
        newWallNameInput?.focus();
        return;
      }

      const rawImage = newWallImageInput?.value ?? '';
      const trimmedImage = rawImage.trim();
      if (!trimmedImage) {
        setCreateWallStatusMessage('Enter a background image URL.', 'error');
        newWallImageInput?.focus();
        return;
      }

      const normalizedKey = normalizeWallKey(trimmedName);
      if (!normalizedKey) {
        setCreateWallStatusMessage('Enter a valid wall name.', 'error');
        newWallNameInput?.focus();
        return;
      }

      if (findLocationByKey(normalizedKey) || findLocationByName(trimmedName)) {
        setCreateWallStatusMessage('A wall with this name already exists.', 'error');
        return;
      }

      if (wallDocumentIdMap.has(normalizedKey)) {
        setCreateWallStatusMessage('A wall with this key already exists.', 'error');
        return;
      }

      isCreatingWall = true;
      if (createWallButton) {
        createWallButton.disabled = true;
      }

      setCreateWallStatusMessage('Creating wall‚Ä¶');

      try {
        const wallSettings = createDefaultWallSettings();
        const payload = {
          name: trimmedName,
          background_url: trimmedImage,
          pointDiameter: wallSettings.pointDiameter,
          rectangleWidth: wallSettings.rectangleWidth,
          rectangleHeight: wallSettings.rectangleHeight,
          unfocusedTransparency: wallSettings.unfocusedTransparency,
          gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
          gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
          gradeBarWidth: wallSettings.gradeBarWidth,
          transparency: wallSettings.gradeBarTransparency,
          key: normalizedKey,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        };

        const docId = normalizedKey;
        await setDoc(doc(db, WALL_COLLECTION, docId), payload, { merge: true });

        wallDocumentIdMap.set(normalizedKey, docId);
        wallSettingsCache.set(normalizedKey, wallSettings);

        const { entry: locationEntry, changed } = upsertLocation({
          key: normalizedKey,
          name: trimmedName,
          image: trimmedImage,
          fallbackName: trimmedName,
          hidden: false,
        });

        if (changed) {
          renderLocationOptions();
        }

        synchronizeCurrentLocationReference();

        if (newWallNameInput) {
          newWallNameInput.value = '';
        }
        if (newWallImageInput) {
          newWallImageInput.value = '';
        }

        const targetLocation =
          locationEntry ||
          findLocationByKey(normalizedKey) ||
          { key: normalizedKey, name: trimmedName, image: trimmedImage };

        setLocation(targetLocation, {
          persist: true,
          refreshRoutes: true,
          wallFallback: wallSettings,
        });

        setCreateWallStatusMessage(`Created wall ‚Äú${trimmedName}‚Äù.`, 'success');
      } catch (error) {
        console.error('Failed to create wall:', error);
        setCreateWallStatusMessage('Failed to create wall. Please try again.', 'error');
      } finally {
        isCreatingWall = false;
        if (createWallButton) {
          createWallButton.disabled = false;
        }
      }
    }

    async function handleDeleteWall() {
      if (isDeletingWall) {
        return;
      }

      clearCreateWallStatusMessage();

      const activeLocation = currentLocation || null;
      const locationKey = getCurrentLocationKey();
      const locationName = activeLocation?.name || '';

      if (!locationKey) {
        setCreateWallStatusMessage('Select a wall before deleting it.', 'error');
        return;
      }

      if (LOCATIONS.length <= 1) {
        setCreateWallStatusMessage(
          'At least one wall must remain. Create another wall before deleting this one.',
          'error',
        );
        return;
      }

      const confirmationLabel = locationName || locationKey;
      const confirmed = window.confirm(
        `Delete wall ‚Äú${confirmationLabel}‚Äù? This will remove all associated routes.`,
      );

      if (!confirmed) {
        return;
      }

      const normalizedCurrentKey = normalizeWallKey(locationKey);
      const docId = wallDocumentIdMap.get(normalizedCurrentKey) || locationKey;
      const wallRef = doc(db, WALL_COLLECTION, docId);

      isDeletingWall = true;
      if (deleteWallButton) {
        deleteWallButton.disabled = true;
      }

      setCreateWallStatusMessage('Deleting wall‚Ä¶');
      updateDeleteWallButtonState();

      try {
        let wallSnapshot = null;
        try {
          wallSnapshot = await getDoc(wallRef);
        } catch (snapshotError) {
          console.warn('Unable to load wall before deletion:', snapshotError);
        }

        const wallData = wallSnapshot?.exists?.() ? wallSnapshot.data() : null;

        const normalizedTargets = new Set(
          [
            normalizedCurrentKey,
            normalizeWallKey(docId),
            normalizeWallKey(wallData?.key),
            normalizeLocationName(wallData?.name),
            normalizeLocationName(locationName),
          ].filter(Boolean),
        );

        const routesSnapshot = await getDocs(collection(db, 'routes'));
        const routeIdsToDelete = [];
        routesSnapshot.forEach((routeSnap) => {
          const data = routeSnap.data();
          const normalizedRouteLocation = normalizeWallKey(
            typeof data?.locationKey === 'string' && data.locationKey
              ? data.locationKey
              : normalizeLocationName(data?.location),
          );
          if (normalizedRouteLocation && normalizedTargets.has(normalizedRouteLocation)) {
            routeIdsToDelete.push(routeSnap.id);
          }
        });

        for (const routeId of routeIdsToDelete) {
          await deleteDoc(doc(db, 'routes', routeId));
          routesCache.delete(routeId);
        }

        await deleteDoc(wallRef);

        const keysToRemove = new Set(normalizedTargets);

        for (const [key, value] of [...wallDocumentIdMap.entries()]) {
          if (keysToRemove.has(key) || value === docId) {
            wallDocumentIdMap.delete(key);
          }
        }

        for (const key of keysToRemove) {
          wallSettingsCache.delete(key);
        }

        for (let index = LOCATIONS.length - 1; index >= 0; index -= 1) {
          const entry = LOCATIONS[index];
          if (!entry) {
            continue;
          }
          const entryKey = normalizeWallKey(entry.key);
          const entryName = normalizeLocationName(entry.name);
          if (keysToRemove.has(entryKey) || keysToRemove.has(entryName)) {
            LOCATIONS.splice(index, 1);
          }
        }

        renderLocationOptions();

        const fallbackLocation = LOCATIONS.find((location) => {
          const entryKey = normalizeWallKey(location?.key || location?.name);
          return entryKey && !keysToRemove.has(entryKey);
        });

        if (fallbackLocation) {
          setLocation(fallbackLocation, { persist: true, refreshRoutes: false });
        } else {
          currentLocation = null;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          applyBodyBackground('');
        }

        updateDeleteWallButtonState();

        const cacheRouteKeysToDelete = [];
        routesCache.forEach((data, routeKey) => {
          const normalizedRouteLocation = normalizeWallKey(
            typeof data?.locationKey === 'string' && data.locationKey
              ? data.locationKey
              : normalizeLocationName(data?.location),
          );
          if (normalizedRouteLocation && keysToRemove.has(normalizedRouteLocation)) {
            cacheRouteKeysToDelete.push(routeKey);
          }
        });

        cacheRouteKeysToDelete.forEach((routeKey) => {
          routesCache.delete(routeKey);
        });

        await loadRoutesList('');
        prepareNewRoute('Wall deleted. You can select another wall.');

        setCreateWallStatusMessage(`Deleted wall ‚Äú${confirmationLabel}‚Äù.`, 'success');
      } catch (error) {
        console.error('Failed to delete wall:', error);
        setCreateWallStatusMessage('Failed to delete wall. Please try again.', 'error');
      } finally {
        isDeletingWall = false;
        if (deleteWallButton) {
          deleteWallButton.disabled = false;
        }
        updateDeleteWallButtonState();
      }
    }

    const isValidUsername = (value) => USERNAME_PATTERN.test(normalizeUsername(value));
    const isValidSetterName = (value) => SETTER_NAME_PATTERN.test(normalizeSetterName(value));

    const buildSyntheticEmail = (username) => {
      const normalized = normalizeUsername(username);
      return normalized ? `${normalized}@${SYNTHETIC_EMAIL_DOMAIN}` : '';
    };

    const points = [];
    let strokeColor = sanitizeColor(colorPicker.value || '#ffde59');
    let pathType = DEFAULT_PATH_TYPE;
    let isDrawingEnabled = false;
    let pointDiameter = DEFAULT_POINT_DIAMETER;
    let rectangleWidth = DEFAULT_RECTANGLE_WIDTH;
    let rectangleHeight = DEFAULT_RECTANGLE_HEIGHT;
    let unfocusedTransparency = DEFAULT_UNFOCUSED_TRANSPARENCY;
    let gradeBarBaseHeight = DEFAULT_GRADE_BAR_BASE_HEIGHT;
    let gradeBarMaxHeight = DEFAULT_GRADE_BAR_MAX_HEIGHT;
    let gradeBarWidth = DEFAULT_GRADE_BAR_WIDTH;
    let gradeBarTransparency = DEFAULT_GRADE_BAR_TRANSPARENCY;
    let currentRouteMedianGrade = null;
    let wheelHue = 48;
    let wheelSaturation = 1;
    let wheelLightness = 0.5;
    let isWheelPointerActive = false;
    let loadedNormalizedPoints = null;
    let currentRouteKey = '';
    let hasUnsavedChanges = false;
    let isSaving = false;
    let currentUsername = '';
    let currentUserId = null;
    let isCanvasScrollable = false;
    let isCreatingWall = false;
    let isDeletingWall = false;
    let isPointerPanning = false;
    let panPointerId = null;
    let panPointerButton = 0;
    let panStartScrollLeft = 0;
    let panStartScrollTop = 0;
    let panOriginX = 0;
    let panOriginY = 0;
    let shouldIgnoreNextClick = false;
    let isPanModifierActive = false;
    const helpTargets = new Map();
    let infoModeActive = false;
    let awaitingHelpTargetSelection = false;
    let activeHelpEntry = null;

    registerHelpTargets(document);
    setInfoButtonActiveState(false);
    updateHelpTooltips();

    if (drawingToggle) {
      updateDrawingToggle();
      drawingToggle.addEventListener('click', () => {
        setDrawingEnabled(!isDrawingEnabled);
      });
    }

    if (tutorialPrimaryAction) {
      tutorialPrimaryAction.addEventListener('click', () => {
        if (!tutorialActive) {
          return;
        }

        if (tutorialStepIndex >= tutorialSteps.length - 1) {
          void finishTutorial();
        } else {
          void goToTutorialStep(tutorialStepIndex + 1);
        }
      });
    }

    if (tutorialSecondaryAction) {
      tutorialSecondaryAction.addEventListener('click', () => {
        if (!tutorialActive) {
          return;
        }

        const mode = tutorialSecondaryAction.dataset.mode || tutorialSecondaryActionMode;
        if (mode === 'skip' || mode === 'close') {
          void finishTutorial();
          return;
        }

        if (tutorialStepIndex <= 0) {
          return;
        }

        void goToTutorialStep(tutorialStepIndex - 1);
      });
    }

    if (tutorialOverlay) {
      tutorialOverlay.addEventListener('click', (event) => {
        if (event.target === tutorialOverlay) {
          void finishTutorial();
        }
      });
    }

    window.addEventListener('keydown', (event) => {
      if (event.code !== 'Space') {
        return;
      }

      if (event.repeat) {
        event.preventDefault();
        return;
      }

      if (isInteractiveElement(event.target)) {
        return;
      }

      event.preventDefault();
      updatePanModifierState(true);
    });

    window.addEventListener('keyup', (event) => {
      if (event.code !== 'Space') {
        return;
      }

      updatePanModifierState(false);
    });

    window.addEventListener('blur', () => {
      updatePanModifierState(false);
    });

    if (canvas) {
      canvas.addEventListener('pointerdown', handleCanvasPointerDown);
      canvas.addEventListener('pointermove', handleCanvasPointerMove);
      canvas.addEventListener('pointerup', handleCanvasPointerEnd);
      canvas.addEventListener('pointercancel', handleCanvasPointerEnd);
      canvas.addEventListener('pointerleave', handleCanvasPointerEnd);
    }

    const routesCache = new Map();
    let routeMedianGrades = new Map();
    let queuedGradeBarOverlays = [];

    const updatePanelToggleState = () => {
      if (!panelToggleButton || !controlPanel) {
        return;
      }

      const expanded = controlPanel.getAttribute('data-expanded') !== 'false';
      const label = expanded ? 'Hide menu' : 'Show menu';
      const pressed = !expanded;
      panelToggleButton.setAttribute('aria-label', label);
      panelToggleButton.setAttribute('title', label);
      panelToggleButton.setAttribute('aria-pressed', String(pressed));
      const srTarget = panelToggleButton.querySelector('.sr-only');
      if (srTarget) {
        srTarget.textContent = label;
      }
    };

    const setPanelExpanded = (value) => {
      if (!controlPanel) {
        return;
      }

      const expanded = Boolean(value);
      controlPanel.setAttribute('data-expanded', String(expanded));
      updatePanelToggleState();
      updateHelpTooltips();
    };

    if (controlPanel) {
      const initialExpanded = controlPanel.getAttribute('data-expanded') !== 'false';
      setPanelExpanded(initialExpanded);
      updatePanelMeasurements();

      window.addEventListener('resize', updatePanelMeasurements);

      if ('ResizeObserver' in window && panelSidebar) {
        const resizeObserver = new ResizeObserver(updatePanelMeasurements);
        resizeObserver.observe(panelSidebar);
      }
    }

    if (panelToggleButton) {
      panelToggleButton.addEventListener('click', () => {
        const isExpanded = controlPanel?.getAttribute('data-expanded') !== 'false';
        setPanelExpanded(!isExpanded);
        requestAnimationFrame(updatePanelMeasurements);
      });
    }

    if (infoButton && infoPopover) {
      infoButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (infoModeActive) {
          deactivateInfoMode({ clearTooltip: true });
        } else {
          activateInfoMode();
        }
      });

      infoPopover.addEventListener('click', (event) => {
        event.stopPropagation();
      });
    }

    document.addEventListener(
      'click',
      (event) => {
        if (!infoModeActive || !awaitingHelpTargetSelection) {
          return;
        }

        const target = event.target instanceof Element ? event.target : null;
        if (!target) {
          deactivateInfoMode({ clearTooltip: true });
          return;
        }

        if ((infoButton && infoButton.contains(target)) || (infoPopover && infoPopover.contains(target))) {
          return;
        }

        const helpElement = target.closest('[data-help-text]');
        if (helpElement) {
          event.preventDefault();
          event.stopPropagation();
          const entry = showHelpTooltipForElement(helpElement);
          deactivateInfoMode({ clearTooltip: !entry });
        } else {
          deactivateInfoMode({ clearTooltip: true });
        }
      },
      true,
    );

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        if (infoModeActive) {
          deactivateInfoMode({ clearTooltip: true });
          if (infoButton) {
            infoButton.focus();
          }
        } else if (activeHelpEntry) {
          clearActiveHelpTooltip();
          if (infoButton) {
            infoButton.focus();
          }
        }
      }
    });

    renderLocationOptions();
    updateWallVisibilityControls();

    if (tabButtons.length) {
      tabButtons.forEach((button) => {
        if (!button) {
          return;
        }
        button.addEventListener('click', () => {
          const targetId = button.dataset?.target;
          const expanded = controlPanel
            ? controlPanel.getAttribute('data-expanded') !== 'false'
            : false;
          const isActive = button.getAttribute('aria-selected') === 'true';

          if (isActive && expanded) {
            setPanelExpanded(false);
            requestAnimationFrame(updatePanelMeasurements);
            return;
          }

          if (!expanded) {
            setPanelExpanded(true);
            requestAnimationFrame(updatePanelMeasurements);
          }

          if (targetId) {
            activateTab(targetId);
          }
        });
      });
    }

    activateTab('routesTab');

    const wallKeyFromQuery = getWallKeyFromQuery();
    let initialLocation = wallKeyFromQuery
      ? findLocationByKey(wallKeyFromQuery) || findLocationByName(wallKeyFromQuery)
      : null;

    let storedLocationKey = null;
    if (!initialLocation) {
      try {
        storedLocationKey = window.localStorage?.getItem(LOCATION_STORAGE_KEY) || null;
      } catch (error) {
        console.warn('Unable to read setter location preference:', error);
      }

      if (storedLocationKey) {
        const normalizedStoredKey = normalizeWallKey(storedLocationKey);
        initialLocation =
          findLocationByKey(normalizedStoredKey) || findLocationByName(normalizedStoredKey);
      }
    }

    if (!initialLocation) {
      initialLocation = DEFAULT_LOCATION;
    }

    setLocation(initialLocation, { persist: true, refreshRoutes: false });

    if (locationButton) {
      locationButton.setAttribute('aria-expanded', 'false');
    }

    if (locationButton) {
      locationButton.addEventListener('click', (event) => {
        event.preventDefault();
        openLocationModal();
      });
    }

    if (wallVisibilityToggle) {
      wallVisibilityToggle.addEventListener('change', (event) => {
        applyWallVisibilityChange(event.target.checked).catch((error) => {
          console.error('Failed to update wall visibility:', error);
        });
      });
    }

    if (locationModalClose) {
      locationModalClose.addEventListener('click', (event) => {
        event.preventDefault();
        closeLocationModal();
      });
    }

    if (locationModal) {
      locationModal.addEventListener('click', (event) => {
        if (event.target === locationModal) {
          closeLocationModal();
        }
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        closeLocationModal();
      }
    });

    const wheelCtx = colorWheelCanvas ? colorWheelCanvas.getContext('2d') : null;

    if (colorWheelCanvas) {
      const baseSize = 220;
      const ratio = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      colorWheelCanvas.width = Math.round(baseSize * ratio);
      colorWheelCanvas.height = Math.round(baseSize * ratio);
    }

    function hslToRgb(h, s, l) {
      let r;
      let g;
      let b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hueToRgb = (p, q, t) => {
          let temp = t;
          if (temp < 0) temp += 1;
          if (temp > 1) temp -= 1;
          if (temp < 1 / 6) return p + (q - p) * 6 * temp;
          if (temp < 1 / 2) return q;
          if (temp < 2 / 3) return p + (q - p) * (2 / 3 - temp) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function hslToHex(h, s, l) {
      const [r, g, b] = hslToRgb((h % 360 + 360) % 360 / 360, s, l);
      return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    function rgbToHsl(r, g, b) {
      const red = r / 255;
      const green = g / 255;
      const blue = b / 255;
      const max = Math.max(red, green, blue);
      const min = Math.min(red, green, blue);
      let h = 0;
      let s = 0;
      const l = (max + min) / 2;

      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case red:
            h = (green - blue) / d + (green < blue ? 6 : 0);
            break;
          case green:
            h = (blue - red) / d + 2;
            break;
          default:
            h = (red - green) / d + 4;
            break;
        }
        h /= 6;
      }

      return { h: h * 360, s, l };
    }

    function hexToHsl(value) {
      if (typeof value !== 'string') {
        return { h: wheelHue, s: wheelSaturation, l: wheelLightness };
      }

      const match = value.trim().match(/^#?([0-9a-f]{6})$/i);
      if (!match) {
        return { h: wheelHue, s: wheelSaturation, l: wheelLightness };
      }

      const hex = match[1];
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      return rgbToHsl(r, g, b);
    }

    function drawColorWheel(lightness = wheelLightness) {
      if (!wheelCtx || !colorWheelCanvas) {
        return;
      }

      const { width, height } = colorWheelCanvas;
      const imageData = wheelCtx.createImageData(width, height);
      const { data } = imageData;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(centerX, centerY);

      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const index = (y * width + x) * 4;

          if (distance <= radius) {
            const hue = (Math.atan2(dy, dx) * 180) / Math.PI;
            const saturation = Math.min(1, distance / radius);
            const [r, g, b] = hslToRgb(((hue % 360) + 360) % 360 / 360, saturation, lightness);
            data[index] = r;
            data[index + 1] = g;
            data[index + 2] = b;
            data[index + 3] = 255;
          } else {
            data[index] = 0;
            data[index + 1] = 0;
            data[index + 2] = 0;
            data[index + 3] = 0;
          }
        }
      }

      wheelCtx.putImageData(imageData, 0, 0);
    }

    function updateColorWheelMarker() {
      if (!colorWheelMarker || !colorWheelCanvas) {
        return;
      }

      const radius = Math.min(colorWheelCanvas.width, colorWheelCanvas.height) / 2;
      const angle = (wheelHue * Math.PI) / 180;
      const markerRadius = wheelSaturation * radius;
      const x = radius + Math.cos(angle) * markerRadius;
      const y = radius + Math.sin(angle) * markerRadius;
      colorWheelMarker.style.left = `${x}px`;
      colorWheelMarker.style.top = `${y}px`;
    }

    function updateLightnessSliderGradient() {
      if (!colorLightnessSlider) {
        return;
      }

      const dark = hslToHex(wheelHue, wheelSaturation, 0);
      const mid = hslToHex(wheelHue, wheelSaturation, 0.5);
      const light = hslToHex(wheelHue, wheelSaturation, 1);
      colorLightnessSlider.style.background = `linear-gradient(90deg, ${dark}, ${mid}, ${light})`;
    }

    function updateAdvancedPreview(hex) {
      if (colorWheelValue) {
        colorWheelValue.textContent = hex.toUpperCase();
      }
      if (colorWheelSwatch) {
        colorWheelSwatch.style.background = hex;
      }
    }

    function setStrokeColorFromWheel(nextHue, nextSaturation, nextLightness, { quiet = false } = {}) {
      wheelHue = ((nextHue % 360) + 360) % 360;
      wheelSaturation = Math.min(Math.max(nextSaturation, 0), 1);
      wheelLightness = Math.min(Math.max(nextLightness, 0), 1);

      if (colorLightnessSlider) {
        const sliderValue = Math.round(wheelLightness * 100);
        if (Number.isFinite(sliderValue)) {
          colorLightnessSlider.value = String(sliderValue);
        }
      }

      updateColorWheelMarker();
      updateLightnessSliderGradient();

      const hex = sanitizeColor(hslToHex(wheelHue, wheelSaturation, wheelLightness));
      if (colorPicker && colorPicker.value !== hex) {
        colorPicker.value = hex;
      }
      updateAdvancedPreview(hex);

      if (strokeColor !== hex && !quiet) {
        strokeColor = hex;
        loadedNormalizedPoints = null;
        redraw();
        markUnsavedChange();
      } else if (strokeColor !== hex) {
        strokeColor = hex;
      }
    }

    function syncAdvancedColorPicker(color) {
      if (!colorWheelCanvas) {
        return;
      }

      const sanitized = sanitizeColor(color);
      const { h, s, l } = hexToHsl(sanitized);
      wheelHue = Number.isFinite(h) ? h : wheelHue;
      wheelSaturation = Number.isFinite(s) ? s : wheelSaturation;
      wheelLightness = Number.isFinite(l) ? l : wheelLightness;

      drawColorWheel(wheelLightness);
      updateColorWheelMarker();
      updateLightnessSliderGradient();

      if (colorLightnessSlider) {
        colorLightnessSlider.value = String(Math.round(wheelLightness * 100));
      }

      updateAdvancedPreview(sanitized);
    }

    function handleWheelSelection(clientX, clientY) {
      if (!colorWheelCanvas) {
        return;
      }

      const rect = colorWheelCanvas.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        return;
      }

      const scaleX = colorWheelCanvas.width / rect.width;
      const scaleY = colorWheelCanvas.height / rect.height;
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      const centerX = colorWheelCanvas.width / 2;
      const centerY = colorWheelCanvas.height / 2;
      let dx = x - centerX;
      let dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const radius = Math.min(centerX, centerY);

      if (distance > radius) {
        const ratio = radius / distance;
        dx *= ratio;
        dy *= ratio;
      }

      const hue = ((Math.atan2(dy, dx) * 180) / Math.PI + 360) % 360;
      const saturation = Math.min(1, Math.sqrt(dx * dx + dy * dy) / radius);
      setStrokeColorFromWheel(hue, saturation, wheelLightness);
    }

    if (advancedColorToggle && advancedColorPicker) {
      advancedColorToggle.addEventListener('click', () => {
        if (!advancedColorPicker) {
          return;
        }

        const isHidden = advancedColorPicker.classList.toggle('hidden');
        const expanded = !isHidden;
        advancedColorToggle.setAttribute('aria-expanded', String(expanded));
        advancedColorPicker.setAttribute('aria-hidden', String(!expanded));
        advancedColorToggle.textContent = expanded ? 'Hide colour wheel' : 'Open colour wheel';

        if (expanded) {
          drawColorWheel(wheelLightness);
          updateColorWheelMarker();
          updateLightnessSliderGradient();
        }

        updateHelpTooltips();
      });
    }

    if (colorWheelCanvas) {
      const normalizeEvent = (event) => {
        event.preventDefault();
        handleWheelSelection(event.clientX, event.clientY);
      };

      colorWheelCanvas.addEventListener('pointerdown', (event) => {
        isWheelPointerActive = true;
        if (typeof colorWheelCanvas.setPointerCapture === 'function') {
          colorWheelCanvas.setPointerCapture(event.pointerId);
        }
        if (document.activeElement !== colorWheelCanvas) {
          colorWheelCanvas.focus();
        }
        normalizeEvent(event);
      });

      colorWheelCanvas.addEventListener('pointermove', (event) => {
        if (!isWheelPointerActive) {
          return;
        }
        normalizeEvent(event);
      });

      const stopPointer = (event) => {
        if (
          typeof colorWheelCanvas.releasePointerCapture === 'function' &&
          colorWheelCanvas.hasPointerCapture(event.pointerId)
        ) {
          colorWheelCanvas.releasePointerCapture(event.pointerId);
        }
        isWheelPointerActive = false;
      };

      colorWheelCanvas.addEventListener('pointerup', stopPointer);
      colorWheelCanvas.addEventListener('pointercancel', stopPointer);
      colorWheelCanvas.addEventListener('pointerleave', () => {
        isWheelPointerActive = false;
      });

      colorWheelCanvas.addEventListener('keydown', (event) => {
        const hueStep = event.shiftKey ? 10 : 3;
        const satStep = event.shiftKey ? 0.05 : 0.02;
        let handled = true;

        switch (event.key) {
          case 'ArrowLeft':
            setStrokeColorFromWheel(wheelHue - hueStep, wheelSaturation, wheelLightness);
            break;
          case 'ArrowRight':
            setStrokeColorFromWheel(wheelHue + hueStep, wheelSaturation, wheelLightness);
            break;
          case 'ArrowUp':
            setStrokeColorFromWheel(wheelHue, Math.min(1, wheelSaturation + satStep), wheelLightness);
            break;
          case 'ArrowDown':
            setStrokeColorFromWheel(wheelHue, Math.max(0, wheelSaturation - satStep), wheelLightness);
            break;
          default:
            handled = false;
            break;
        }

        if (handled) {
          event.preventDefault();
        }
      });
    }

    if (colorLightnessSlider) {
      colorLightnessSlider.addEventListener('input', (event) => {
        const value = Number(event.target.value);
        if (!Number.isFinite(value)) {
          return;
        }

        const normalized = Math.min(Math.max(value, 0), 100) / 100;
        setStrokeColorFromWheel(wheelHue, wheelSaturation, normalized);
        drawColorWheel(wheelLightness);
      });
    }

    syncAdvancedColorPicker(strokeColor);

    if (climberViewButton) {
      climberViewButton.addEventListener('click', () => {
        const activeKey = getCurrentLocationKey();
        const targetHref = buildWallAwareHref(climberViewBaseHref, activeKey);
        const destination = targetHref || climberViewTargetHref || climberViewBaseHref;
        window.location.href = destination;
      });
    }

    if (personalDashboardButton) {
      personalDashboardButton.addEventListener('click', () => {
        window.location.href = 'personal.html';
      });
    }

    const ADMIN_CONSOLE_PATH = 'admin.html';

    if (adminConsoleButton) {
      adminConsoleButton.addEventListener('click', () => {
        if (adminConsoleButton.disabled) {
          return;
        }

        window.location.href = ADMIN_CONSOLE_PATH;
      });
    }

    function updateAdminConsoleAccess(role) {
      const normalized = typeof role === 'string' ? role.trim().toLowerCase() : '';
      const isAdmin = normalized === 'admin';

      if (adminConsoleButton) {
        adminConsoleButton.classList.toggle('hidden', !isAdmin);
        adminConsoleButton.disabled = !isAdmin;
      }

      if (!adminConsoleStatus) {
        return;
      }

      if (!normalized) {
        adminConsoleStatus.textContent = '';
        adminConsoleStatus.classList.add('hidden');
        delete adminConsoleStatus.dataset.variant;
        return;
      }

      adminConsoleStatus.classList.remove('hidden');

      if (isAdmin) {
        adminConsoleStatus.textContent = 'Open the admin console to manage database operations.';
        adminConsoleStatus.dataset.variant = 'info';
      } else {
        adminConsoleStatus.textContent = 'Admin access is required to manage the database.';
        adminConsoleStatus.dataset.variant = 'warning';
      }
    }

    updateAdminConsoleAccess('');

    

    

    

    function setRoleControlsEnabled(enabled) {
      const allow = Boolean(enabled);
      if (grantSetterButton) {
        grantSetterButton.disabled = !allow;
      }
      if (roleUsernameInput) {
        roleUsernameInput.disabled = !allow;
      }
    }

    function resetRoleManagementUI(message = '') {
      if (roleUsernameInput) {
        roleUsernameInput.value = '';
      }

      if (message) {
        setRoleStatus(message, 'info');
      } else {
        clearRoleStatus();
      }
    }

    const isLikelyUsername = (value) => isValidUsername(value);

    if (grantSetterButton && roleUsernameInput) {
      grantSetterButton.addEventListener('click', async () => {
        const rawUsername = roleUsernameInput.value;
        const trimmedUsername = typeof rawUsername === 'string' ? rawUsername.trim() : '';

        if (!trimmedUsername) {
          setRoleStatus('Enter the user\'s username.', 'info');
          return;
        }

        if (!isLikelyUsername(trimmedUsername)) {
          setRoleStatus('Enter a valid username (letters, numbers, underscores).', 'error');
          return;
        }

        const normalizedUsername = normalizeUsername(trimmedUsername);

        try {
          setRoleControlsEnabled(false);
          setRoleStatus(`Granting setter role to ${trimmedUsername}‚Ä¶`, 'info');

          const usernameRef = doc(db, 'usernames', normalizedUsername);
          const usernameSnap = await getDoc(usernameRef);

          if (!usernameSnap.exists()) {
            setRoleStatus('No user found with that username.', 'error');
            return;
          }

          const usernameData = usernameSnap.data() || {};
          const targetUid = typeof usernameData.uid === 'string' ? usernameData.uid.trim() : '';

          if (!targetUid) {
            setRoleStatus('Unable to resolve that username to a user account.', 'error');
            return;
          }

          const roleRef = doc(db, 'roles', targetUid);
          const roleSnap = await getDoc(roleRef);
          const existingData = roleSnap.exists() ? roleSnap.data() || {} : {};
          const existingRole = typeof existingData.role === 'string' ? existingData.role.trim() : '';
          const existingLowerRaw =
            typeof existingData.usernameLower === 'string'
              ? existingData.usernameLower
              : typeof existingData.username === 'string'
              ? existingData.username
              : '';
          const existingLower = normalizeUsername(existingLowerRaw);

          if (existingRole === 'setter' && existingLower === normalizedUsername) {
            setRoleStatus(`${trimmedUsername} is already a setter.`, 'success');
            if (roleUsernameInput) {
              roleUsernameInput.value = '';
            }
            return;
          }

          const payload = {
            role: 'setter',
            username: normalizedUsername,
            usernameLower: normalizedUsername,
            updatedAt: serverTimestamp(),
          };

          if (!existingData.createdAt) {
            payload.createdAt = serverTimestamp();
          }

          await setDoc(roleRef, payload, { merge: true });

          setRoleStatus(`Setter role granted to ${trimmedUsername}.`, 'success');
          if (roleUsernameInput) {
            roleUsernameInput.value = '';
          }
        } catch (error) {
          console.error('Failed to grant setter role:', error);
          setRoleStatus('Unable to grant setter role. Please try again.', 'error');
        } finally {
          setRoleControlsEnabled(true);
          if (roleUsernameInput) {
            roleUsernameInput.focus();
          }
        }
      });
    }

    resetRoleManagementUI('Enter the username of the user you want to promote.');

    function normalizeDateValue(value) {
      if (!value) {
        return null;
      }

      if (typeof value === 'string') {
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date.toISOString();
      }

      if (value instanceof Date) {
        return Number.isNaN(value.getTime()) ? null : value.toISOString();
      }

      if (typeof value?.toDate === 'function') {
        const date = value.toDate();
        if (date instanceof Date && !Number.isNaN(date.getTime())) {
          return date.toISOString();
        }
        return null;
      }

      return null;
    }

    function isoStringToInputValue(isoString) {
      if (!isoString) {
        return '';
      }

      const date = new Date(isoString);
      if (Number.isNaN(date.getTime())) {
        return '';
      }

      const offset = date.getTimezoneOffset();
      const local = new Date(date.getTime() - offset * 60000);
      return local.toISOString().slice(0, 16);
    }

    function inputValueToIsoString(inputValue) {
      if (!inputValue) {
        return null;
      }

      const date = new Date(inputValue);
      if (Number.isNaN(date.getTime())) {
        return null;
      }

      return date.toISOString();
    }

    function getNowInputValue() {
      const now = new Date();
      const offset = now.getTimezoneOffset();
      const local = new Date(now.getTime() - offset * 60000);
      return local.toISOString().slice(0, 16);
    }

    function normalizeRouteData(raw = {}) {
      const rawId = typeof raw?.id === 'string' ? raw.id : '';
      const { date_removed: _unusedDateRemoved, ...rest } = raw || {};
      const rawLocation = typeof rest.location === 'string' ? rest.location.trim() : '';
      const locationName = rawLocation || DEFAULT_LOCATION?.name || '';
      const locationKey = normalizeLocationName(locationName);
      const normalizedPathType = normalizePathType(rest.pathType);
      const fallbackPointDiameter = normalizePointDiameter(rest.pointDiameter);
      const fallbackRectangleWidth = normalizeRectangleSize(
        rest.rectangleWidth,
        DEFAULT_RECTANGLE_WIDTH,
      );
      const fallbackRectangleHeight = normalizeRectangleSize(
        rest.rectangleHeight,
        DEFAULT_RECTANGLE_HEIGHT,
      );
      const gradeBarBaseHeight = normalizeGradeBarHeight(
        rest.gradeBarBaseHeight,
        DEFAULT_GRADE_BAR_BASE_HEIGHT,
      );
      const gradeBarMaxHeight = Math.max(
        gradeBarBaseHeight,
        normalizeGradeBarHeight(rest.gradeBarMaxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
      );
      const gradeBarWidth = normalizeGradeBarWidth(rest.gradeBarWidth);
      const gradeBarTransparency = normalizeGradeBarTransparency(
        rest.gradeBarTransparency ?? rest.transparency,
      );
      const wallSettings = getWallSettingsWithFallback(locationKey, {
        pointDiameter: fallbackPointDiameter,
        rectangleWidth: fallbackRectangleWidth,
        rectangleHeight: fallbackRectangleHeight,
        gradeBarBaseHeight,
        gradeBarMaxHeight,
        gradeBarWidth,
        gradeBarTransparency,
      });
      const medianFromCache = rawId ? routeMedianGrades.get(rawId) : undefined;
      const rawMedianGrade =
        typeof rest.medianGrade === 'number' && Number.isFinite(rest.medianGrade)
          ? rest.medianGrade
          : medianFromCache;
      const medianGrade =
        typeof rawMedianGrade === 'number' && Number.isFinite(rawMedianGrade)
          ? Math.min(Math.max(rawMedianGrade, MIN_GRADE_VALUE), MAX_GRADE_VALUE)
          : null;
      return {
        id: rawId,
        ...rest,
        setter: normalizeSetterName(rest.setter),
        title: typeof rest.title === 'string' ? rest.title.trim() : '',
        description: typeof rest.description === 'string' ? rest.description.trim() : '',
        strokeColor: sanitizeColor(rest.strokeColor),
        pathType: normalizedPathType,
        pointDiameter: wallSettings.pointDiameter,
        rectangleWidth: wallSettings.rectangleWidth,
        rectangleHeight: wallSettings.rectangleHeight,
        gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
        gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
        gradeBarWidth: wallSettings.gradeBarWidth,
        gradeBarTransparency: wallSettings.gradeBarTransparency,
        points: Array.isArray(rest.points) ? rest.points : [],
        date_set: normalizeDateValue(rest.date_set),
        location: locationName,
        locationKey,
        medianGrade,
      };
    }

    function calculateMedian(values = []) {
      if (!Array.isArray(values) || !values.length) {
        return null;
      }

      const sorted = values
        .filter((value) => typeof value === 'number' && Number.isFinite(value))
        .sort((a, b) => a - b);

      if (!sorted.length) {
        return null;
      }

      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
      }
      return sorted[mid];
    }

    async function fetchMedianGrades() {
      const medianMap = new Map();

      try {
        const snapshot = await getDocs(collection(db, 'ascents'));
        const gradeBuckets = new Map();

        snapshot.forEach((docSnap) => {
          const data = docSnap.data() ?? {};
          const routesData = data.routes;

          if (!routesData || typeof routesData !== 'object') {
            return;
          }

          Object.entries(routesData).forEach(([routeId, details]) => {
            if (!routeId || !details) {
              return;
            }

            const grade = normalizeGradeValue(details.grade);
            if (grade === null) {
              return;
            }

            if (!gradeBuckets.has(routeId)) {
              gradeBuckets.set(routeId, []);
            }

            gradeBuckets.get(routeId).push(grade);
          });
        });

        gradeBuckets.forEach((grades, routeId) => {
          const median = calculateMedian(grades);
          if (median !== null) {
            medianMap.set(routeId, median);
          }
        });
      } catch (error) {
        console.warn('Failed to load median grades:', error);
      }

      return medianMap;
    }

    function createRouteKeyFromTitle(title) {
      if (typeof title !== 'string') {
        return '';
      }

      const trimmed = title.trim();
      if (!trimmed) {
        return '';
      }

      return trimmed.replace(/\//g, '-');
    }

    function findConflictingRouteKey(title, excludeKey = '') {
      if (typeof title !== 'string') {
        return null;
      }

      const target = title.trim().toLowerCase();
      if (!target) {
        return null;
      }

      for (const [key, data] of routesCache.entries()) {
        if (key === excludeKey) {
          continue;
        }

        const existingTitle = (data?.title || key).trim().toLowerCase();
        if (existingTitle === target) {
          return key;
        }
      }

      return null;
    }

    function setStatus(message, variant = 'info') {
      if (!routeStatus) {
        return;
      }
      if (!message) {
        clearStatus();
        return;
      }
      routeStatus.textContent = message;
      routeStatus.classList.remove('hidden');
      if (variant) {
        routeStatus.dataset.variant = variant;
      } else {
        delete routeStatus.dataset.variant;
      }
    }

    function clearStatus() {
      if (!routeStatus) {
        return;
      }
      routeStatus.textContent = '';
      routeStatus.classList.add('hidden');
      delete routeStatus.dataset.variant;
    }

    function setCreateWallStatusMessage(message, variant = 'info') {
      if (!createWallStatus) {
        return;
      }
      if (!message) {
        clearCreateWallStatusMessage();
        return;
      }
      createWallStatus.textContent = message;
      createWallStatus.classList.remove('hidden');
      if (variant) {
        createWallStatus.dataset.variant = variant;
      } else {
        delete createWallStatus.dataset.variant;
      }
    }

    function clearCreateWallStatusMessage() {
      if (!createWallStatus) {
        return;
      }
      createWallStatus.textContent = '';
      createWallStatus.classList.add('hidden');
      delete createWallStatus.dataset.variant;
    }

    function setRoleStatus(message, variant = 'info') {
      if (!roleStatusMessage) {
        return;
      }
      if (!message) {
        clearRoleStatus();
        return;
      }
      roleStatusMessage.textContent = message;
      roleStatusMessage.classList.remove('hidden');
      if (variant) {
        roleStatusMessage.dataset.variant = variant;
      } else {
        delete roleStatusMessage.dataset.variant;
      }
    }

    function clearRoleStatus() {
      if (!roleStatusMessage) {
        return;
      }
      roleStatusMessage.textContent = '';
      roleStatusMessage.classList.add('hidden');
      delete roleStatusMessage.dataset.variant;
    }

    

    

    

    

    

    

    

    

    function markUnsavedChange() {
      if (!hasUnsavedChanges) {
        hasUnsavedChanges = true;
        setStatus('Unsaved changes ‚Äì remember to save.', 'info');
      }
    }

    function resetUnsavedState() {
      hasUnsavedChanges = false;
    }

    function updatePathControls() {
      if (pathTypeSelect) {
        pathTypeSelect.value = pathType;
      }
      if (pointDiameterSlider) {
        pointDiameterSlider.value = String(pointDiameter);
      }
      if (pointDiameterValue) {
        pointDiameterValue.textContent = `${pointDiameter}px`;
      }
      if (rectangleWidthSlider) {
        rectangleWidthSlider.value = String(rectangleWidth);
      }
      if (rectangleWidthValue) {
        rectangleWidthValue.textContent = `${rectangleWidth}px`;
      }
      if (rectangleHeightSlider) {
        rectangleHeightSlider.value = String(rectangleHeight);
      }
      if (rectangleHeightValue) {
        rectangleHeightValue.textContent = `${rectangleHeight}px`;
      }
      if (unfocusedTransparencySlider) {
        unfocusedTransparencySlider.value = String(
          convertUnfocusedTransparencyToSliderValue(unfocusedTransparency),
        );
      }
    }

    function updateAppearanceControls() {
      if (appearancePointDiameterInput) {
        appearancePointDiameterInput.value = String(pointDiameter);
      }
      if (gradeBarBaseHeightInput) {
        gradeBarBaseHeightInput.value = String(gradeBarBaseHeight);
      }
      if (gradeBarMaxHeightInput) {
        gradeBarMaxHeightInput.value = String(gradeBarMaxHeight);
      }
      if (gradeBarWidthInput) {
        gradeBarWidthInput.value = String(gradeBarWidth);
      }
      if (gradeBarTransparencyInput) {
        gradeBarTransparencyInput.value = String(gradeBarTransparency);
      }
    }

    const DEFAULT_CANVAS_ASPECT_RATIO = 1536 / 1024;
    let canvasAspectRatio = DEFAULT_CANVAS_ASPECT_RATIO;

    function computeCanvasDimensions() {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const aspectRatio = Number.isFinite(canvasAspectRatio) && canvasAspectRatio > 0
        ? canvasAspectRatio
        : DEFAULT_CANVAS_ASPECT_RATIO;
      const enableScroll = viewportWidth <= 768 && viewportHeight > viewportWidth;

      if (enableScroll) {
        const height = viewportHeight;
        const width = Math.max(viewportWidth, Math.round(height * aspectRatio));
        return { width, height, enableScroll };
      }

      return {
        width: viewportWidth,
        height: viewportHeight,
        enableScroll: false,
      };
    }

    function resizeCanvas() {
      const previousWidth = canvas.width || 0;
      const previousHeight = canvas.height || 0;
      const { width, height, enableScroll } = computeCanvasDimensions();

      if (canvasContainer) {
        canvasContainer.classList.toggle('scrollable', enableScroll);
      }

      canvas.width = width;
      canvas.height = height;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;

      if (canvasContainer) {
        if (enableScroll) {
          const maxScrollLeft = Math.max(0, width - window.innerWidth);
          if (!isCanvasScrollable) {
            canvasContainer.scrollLeft = Math.max(0, maxScrollLeft / 2);
          } else if (canvasContainer.scrollLeft > maxScrollLeft) {
            canvasContainer.scrollLeft = maxScrollLeft;
          }
        } else if (isCanvasScrollable) {
          canvasContainer.scrollLeft = 0;
        }
      }

      const safePreviousWidth = previousWidth || width;
      const safePreviousHeight = previousHeight || height;

      if (loadedNormalizedPoints) {
        points.length = 0;
        loadedNormalizedPoints.forEach(({ x, y }) => {
          if (Number.isFinite(x) && Number.isFinite(y)) {
            points.push({ x: x * canvas.width, y: y * canvas.height });
          }
        });
      } else if (points.length && safePreviousWidth && safePreviousHeight) {
        const scaledPoints = points.map(({ x, y }) => ({
          x: (x / safePreviousWidth) * canvas.width,
          y: (y / safePreviousHeight) * canvas.height,
        }));
        points.length = 0;
        points.push(...scaledPoints);
      }

      isCanvasScrollable = enableScroll;
      redraw();
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (backgroundReady && backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      queuedGradeBarOverlays = [];
      drawExistingRoutesOverlay();
      drawRouteFromCanvasPoints(
        points,
        strokeColor,
        1,
        pathType,
        pointDiameter,
        rectangleWidth,
        rectangleHeight,
      );
      if (points.length) {
        queueGradeBarOverlay({
          routePoints: points,
          color: strokeColor,
          alpha: 1,
          medianGrade: currentRouteMedianGrade,
          baseHeight: gradeBarBaseHeight,
          maxHeight: gradeBarMaxHeight,
          width: gradeBarWidth,
          transparency: gradeBarTransparency,
          isAscended: false,
        });
      }
      renderQueuedGradeBarOverlays();
    }

    function clamp(value, min, max) {
      if (!Number.isFinite(value)) {
        return min;
      }
      if (value < min) {
        return min;
      }
      if (value > max) {
        return max;
      }
      return value;
    }

    function calculateAverageXFromCanvasPoints(routePoints = []) {
      if (!Array.isArray(routePoints) || !routePoints.length) {
        return null;
      }

      const valid = routePoints
        .map((point) => Number(point?.x))
        .filter((x) => Number.isFinite(x));

      if (!valid.length) {
        return null;
      }

      const sum = valid.reduce((total, x) => total + x, 0);
      return sum / valid.length;
    }

    function queueGradeBarOverlay() {
      queuedGradeBarOverlays = [];
    }

    function renderQueuedGradeBarOverlays() {
      queuedGradeBarOverlays = [];
    }

    function drawRouteFromCanvasPoints(
      routePoints = [],
      color = '#ffde59',
      alpha = 1,
      routePathType = DEFAULT_PATH_TYPE,
      routePointDiameter = DEFAULT_POINT_DIAMETER,
      routeRectangleWidth = DEFAULT_RECTANGLE_WIDTH,
      routeRectangleHeight = DEFAULT_RECTANGLE_HEIGHT,
    ) {
      if (!Array.isArray(routePoints) || !routePoints.length) {
        return;
      }

      ctx.save();
      ctx.globalAlpha = alpha;

      const effectivePathType = normalizePathType(routePathType);
      const effectivePointDiameter = normalizePointDiameter(routePointDiameter);
      const effectiveRectangleWidth = normalizeRectangleSize(
        routeRectangleWidth,
        DEFAULT_RECTANGLE_WIDTH,
      );
      const effectiveRectangleHeight = normalizeRectangleSize(
        routeRectangleHeight,
        DEFAULT_RECTANGLE_HEIGHT,
      );

      if (effectivePathType === PATH_TYPE_BREZER && routePoints.length >= 2) {
        ctx.lineWidth = 10;
        ctx.strokeStyle = color;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(routePoints[0].x, routePoints[0].y);

        for (let i = 0; i < routePoints.length - 1; i++) {
          const p0 = i === 0 ? routePoints[0] : routePoints[i - 1];
          const p1 = routePoints[i];
          const p2 = routePoints[i + 1];
          const p3 = i + 2 < routePoints.length ? routePoints[i + 2] : routePoints[i + 1];

          const cp1x = p1.x + (p2.x - p0.x) / 6;
          const cp1y = p1.y + (p2.y - p0.y) / 6;
          const cp2x = p2.x - (p3.x - p1.x) / 6;
          const cp2y = p2.y - (p3.y - p1.y) / 6;

          ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }

        ctx.stroke();
      }

      if (effectivePathType === PATH_TYPE_POINT) {
        const radius = Math.max(1, effectivePointDiameter / 2);
        const strokeWidth = Math.max(2, Math.round(effectivePointDiameter / 10));
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = color;
        routePoints.forEach((point) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
          ctx.stroke();
        });
      } else if (effectivePathType === PATH_TYPE_RECTANGLE) {
        const halfWidth = Math.max(1, effectiveRectangleWidth / 2);
        const halfHeight = Math.max(1, effectiveRectangleHeight / 2);
        const strokeWidth = Math.max(
          2,
          Math.round(Math.max(effectiveRectangleWidth, effectiveRectangleHeight) / 10),
        );
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = color;
        routePoints.forEach((point) => {
          ctx.strokeRect(
            point.x - halfWidth,
            point.y - halfHeight,
            effectiveRectangleWidth,
            effectiveRectangleHeight,
          );
        });
      } else {
        ctx.fillStyle = color;
        routePoints.forEach((point) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      ctx.restore();
    }

    function createNormalizedPointKey(x, y) {
      if (!Number.isFinite(x) || !Number.isFinite(y)) {
        return null;
      }

      const clampedX = Math.min(Math.max(x, 0), 1);
      const clampedY = Math.min(Math.max(y, 0), 1);
      const scaledX = Math.round(clampedX * 10000);
      const scaledY = Math.round(clampedY * 10000);
      return `${scaledX}:${scaledY}`;
    }

    function buildNormalizedPointKeySetFromCanvasPoints(canvasPoints = []) {
      const keys = new Set();
      if (!Array.isArray(canvasPoints) || !canvasPoints.length || !canvas.width || !canvas.height) {
        return keys;
      }

      const width = canvas.width;
      const height = canvas.height;

      canvasPoints.forEach((point) => {
        if (!point) {
          return;
        }

        const normalizedX = Number(point.x) / width;
        const normalizedY = Number(point.y) / height;
        const key = createNormalizedPointKey(normalizedX, normalizedY);
        if (key) {
          keys.add(key);
        }
      });

      return keys;
    }

    function convertNormalizedToCanvasPoints(normalizedPoints = []) {
      if (!Array.isArray(normalizedPoints) || !canvas.width || !canvas.height) {
        return [];
      }

      return normalizedPoints
        .map((point) => {
          const x = Number(point?.x);
          const y = Number(point?.y);
          if (Number.isFinite(x) && Number.isFinite(y)) {
            return { x: x * canvas.width, y: y * canvas.height };
          }
          return null;
        })
        .filter(Boolean);
    }

    function createOverlapGroupKey(pathTypeValue, pointKey) {
      if (!pathTypeValue || !pointKey) {
        return null;
      }
      return `${pathTypeValue}::${pointKey}`;
    }

    function buildOverlayOverlapGroups(routeEntries = []) {
      const groups = new Map();

      routeEntries.forEach((entry) => {
        if (!entry) {
          return;
        }

        const { pathType: pathTypeValue, normalizedPoints } = entry;
        if (
          (pathTypeValue !== PATH_TYPE_POINT && pathTypeValue !== PATH_TYPE_RECTANGLE) ||
          !Array.isArray(normalizedPoints) ||
          !normalizedPoints.length
        ) {
          return;
        }

        normalizedPoints.forEach((point) => {
          const normalizedX = Number(point?.x);
          const normalizedY = Number(point?.y);
          const key = createNormalizedPointKey(normalizedX, normalizedY);
          if (!key) {
            return;
          }

          const groupKey = createOverlapGroupKey(pathTypeValue, key);
          if (!groupKey) {
            return;
          }

          if (!groups.has(groupKey)) {
            groups.set(groupKey, {
              pathType: pathTypeValue,
              entries: [],
            });
          }

          const group = groups.get(groupKey);
          group.entries.push({
            routeId: entry.id,
            color: entry.color,
            pointDiameter: entry.pointDiameter,
            rectangleWidth: entry.rectangleWidth,
            rectangleHeight: entry.rectangleHeight,
            alpha: entry.alpha,
          });
        });
      });

      for (const [key, group] of groups) {
        if (!group || !Array.isArray(group.entries) || group.entries.length <= 1) {
          groups.delete(key);
        }
      }

      return groups;
    }

    function drawOverlayPointGroup(center, entries) {
      if (!center || !Array.isArray(entries) || entries.length <= 1) {
        return;
      }

      const total = entries.length;
      const radii = entries.map((entry) => Math.max(1, Number(entry.pointDiameter) / 2));
      const radius = Math.max(...radii, 4);
      const step = (Math.PI * 2) / total;
      const startAngle = -Math.PI / 2;

      ctx.save();
      ctx.setLineDash([]);
      ctx.lineCap = 'butt';
      ctx.lineJoin = 'miter';

      entries.forEach((entry, index) => {
        const strokeWidth = Math.max(2, Math.round(Number(entry.pointDiameter) / 10) || 2);
        const angleStart = startAngle + step * index;
        const angleEnd = angleStart + step;

        ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = entry.color || '#ffde59';
        ctx.beginPath();
        ctx.arc(center.x, center.y, radius, angleStart, angleEnd);
        ctx.stroke();
      });

      ctx.restore();
    }

    function drawOverlayRectangleGroup(center, width, height, entries) {
      if (!center || !Array.isArray(entries) || entries.length <= 1) {
        return;
      }

      const normalizedWidth = Math.max(...entries.map((entry) => Number(entry.rectangleWidth) || 0), width);
      const normalizedHeight = Math.max(
        ...entries.map((entry) => Number(entry.rectangleHeight) || 0),
        height,
      );
      const finalWidth = Math.max(1, normalizedWidth);
      const finalHeight = Math.max(1, normalizedHeight);
      const halfWidth = finalWidth / 2;
      const halfHeight = finalHeight / 2;
      const perimeter = 2 * (finalWidth + finalHeight);

      if (!Number.isFinite(perimeter) || perimeter <= 0) {
        return;
      }

      const segmentLength = perimeter / entries.length;
      const edges = [
        { length: finalWidth, startX: center.x - halfWidth, startY: center.y - halfHeight, dx: 1, dy: 0 },
        { length: finalHeight, startX: center.x + halfWidth, startY: center.y - halfHeight, dx: 0, dy: 1 },
        { length: finalWidth, startX: center.x + halfWidth, startY: center.y + halfHeight, dx: -1, dy: 0 },
        { length: finalHeight, startX: center.x - halfWidth, startY: center.y + halfHeight, dx: 0, dy: -1 },
      ];
      const edgeCount = edges.length;

      let offset = 0;

      entries.forEach((entry) => {
        let localOffset = offset % perimeter;
        if (localOffset < 0) {
          localOffset += perimeter;
        }

        let edgeIndex = 0;
        while (localOffset >= edges[edgeIndex].length && edgeIndex < edgeCount - 1) {
          localOffset -= edges[edgeIndex].length;
          edgeIndex += 1;
        }

        let currentX = edges[edgeIndex].startX + edges[edgeIndex].dx * localOffset;
        let currentY = edges[edgeIndex].startY + edges[edgeIndex].dy * localOffset;
        let remaining = segmentLength;

        ctx.save();
        ctx.setLineDash([]);
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.lineWidth = Math.max(
          2,
          Math.round(
            Math.max(Number(entry.rectangleWidth) || 0, Number(entry.rectangleHeight) || 0) / 10,
          ) || 2,
        );
        ctx.strokeStyle = entry.color || '#ffde59';
        ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;

        while (remaining > 0) {
          const edge = edges[edgeIndex];
          const available = edge.length - localOffset;
          const step = Math.min(remaining, available);
          const nextOffset = localOffset + step;
          const nextX = edge.startX + edge.dx * nextOffset;
          const nextY = edge.startY + edge.dy * nextOffset;

          ctx.beginPath();
          ctx.moveTo(currentX, currentY);
          ctx.lineTo(nextX, nextY);
          ctx.stroke();

          remaining -= step;
          currentX = nextX;
          currentY = nextY;
          localOffset = 0;
          edgeIndex = (edgeIndex + 1) % edgeCount;
        }

        ctx.restore();

        offset += segmentLength;
        if (offset >= perimeter) {
          offset -= perimeter;
        }
      });
    }

    function drawExistingRoutesOverlay() {
      if (!routesCache.size) {
        return;
      }

      const activeLocationKey = getCurrentLocationKey();
      const wallSettings = getWallSettingsForLocation(activeLocationKey);
      const overlayAlpha = normalizeUnfocusedTransparency(wallSettings.unfocusedTransparency);
      const focusPointKeys = points.length
        ? buildNormalizedPointKeySetFromCanvasPoints(points)
        : null;

      const overlayEntries = [];

      routesCache.forEach((data, key) => {
        if (!data || key === currentRouteKey) {
          return;
        }

        const routeLocationKey =
          typeof data?.locationKey === 'string'
            ? data.locationKey
            : normalizeLocationName(data?.location);
        if (activeLocationKey && routeLocationKey !== activeLocationKey) {
          return;
        }

        const normalizedPoints = Array.isArray(data.points) ? data.points : [];
        const canvasPoints = convertNormalizedToCanvasPoints(normalizedPoints);
        if (!canvasPoints.length) {
          return;
        }

        const color = sanitizeColor(data.strokeColor);
        overlayEntries.push({
          id: key,
          color,
          pathType: normalizePathType(data.pathType),
          canvasPoints,
          normalizedPoints,
          pointDiameter: normalizePointDiameter(data.pointDiameter),
          rectangleWidth: normalizeRectangleSize(data.rectangleWidth, DEFAULT_RECTANGLE_WIDTH),
          rectangleHeight: normalizeRectangleSize(data.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT),
          alpha: overlayAlpha,
          medianGrade: data.medianGrade,
          gradeBarBaseHeight: data.gradeBarBaseHeight,
          gradeBarMaxHeight: data.gradeBarMaxHeight,
          gradeBarWidth: data.gradeBarWidth,
          gradeBarTransparency: data.gradeBarTransparency,
        });
      });

      if (!overlayEntries.length) {
        return;
      }

      const overlapGroups = buildOverlayOverlapGroups(overlayEntries);
      const handledOverlapKeys = new Set();

      overlayEntries.forEach((entry) => {
        const {
          color,
          pathType: routePathType,
          canvasPoints,
          normalizedPoints,
          pointDiameter: entryPointDiameter,
          rectangleWidth: entryRectangleWidth,
          rectangleHeight: entryRectangleHeight,
          alpha,
          medianGrade,
          gradeBarBaseHeight,
          gradeBarMaxHeight,
          gradeBarWidth,
          gradeBarTransparency,
        } = entry;

        const supportsPattern =
          routePathType === PATH_TYPE_POINT || routePathType === PATH_TYPE_RECTANGLE;
        const visiblePoints = [];

        canvasPoints.forEach((point, index) => {
          const normalized = Array.isArray(normalizedPoints) ? normalizedPoints[index] : null;
          const normalizedX = Number(normalized?.x);
          const normalizedY = Number(normalized?.y);
          const pointKey =
            supportsPattern && Number.isFinite(normalizedX) && Number.isFinite(normalizedY)
              ? createNormalizedPointKey(normalizedX, normalizedY)
              : null;

          if (
            supportsPattern &&
            focusPointKeys &&
            focusPointKeys.size > 0 &&
            pointKey &&
            focusPointKeys.has(pointKey)
          ) {
            return;
          }

          const overlapKey =
            pointKey && overlapGroups ? createOverlapGroupKey(routePathType, pointKey) : null;
          const overlapGroup =
            overlapKey && overlapGroups ? overlapGroups.get(overlapKey) : null;

          if (
            overlapGroup &&
            Array.isArray(overlapGroup.entries) &&
            overlapGroup.entries.length > 1 &&
            !focusPointKeys
          ) {
            if (handledOverlapKeys.has(overlapKey)) {
              return;
            }

            handledOverlapKeys.add(overlapKey);

            if (routePathType === PATH_TYPE_POINT) {
              drawOverlayPointGroup(point, overlapGroup.entries);
            } else if (routePathType === PATH_TYPE_RECTANGLE) {
              drawOverlayRectangleGroup(point, entryRectangleWidth, entryRectangleHeight, overlapGroup.entries);
            }
            return;
          }

          visiblePoints.push(point);
        });

        if (visiblePoints.length) {
          drawRouteFromCanvasPoints(
            visiblePoints,
            color,
            alpha,
            routePathType,
            entryPointDiameter,
            entryRectangleWidth,
            entryRectangleHeight,
          );
        }

        queueGradeBarOverlay({
          routePoints: canvasPoints,
          color,
          alpha,
          medianGrade,
          baseHeight: gradeBarBaseHeight,
          maxHeight: gradeBarMaxHeight,
          width: gradeBarWidth,
          transparency: gradeBarTransparency,
          isAscended: false,
        });
      });
    }

    function applyNormalizedPoints(normalizedPoints = []) {
      if (!Array.isArray(normalizedPoints)) {
        loadedNormalizedPoints = null;
        points.length = 0;
        redraw();
        return;
      }

      const filtered = normalizedPoints
        .map((point) => {
          const x = Number(point?.x);
          const y = Number(point?.y);
          if (Number.isFinite(x) && Number.isFinite(y)) {
            return { x, y };
          }
          return null;
        })
        .filter(Boolean);

      loadedNormalizedPoints = filtered;
      points.length = 0;
      filtered.forEach(({ x, y }) => {
        points.push({ x: x * canvas.width, y: y * canvas.height });
      });

      redraw();
    }

    function convertPointsToNormalized() {
      if (!canvas.width || !canvas.height) {
        return [];
      }

      return points.map(({ x, y }) => ({
        x: Number((x / canvas.width).toFixed(6)),
        y: Number((y / canvas.height).toFixed(6)),
      }));
    }

    function getPointDetectionRadius(diameter) {
      const normalizedDiameter = normalizePointDiameter(diameter);
      return Math.max(6, normalizedDiameter / 2);
    }

    function getRectangleDetectionRadius(width, height) {
      const normalizedWidth = normalizeRectangleSize(width, DEFAULT_RECTANGLE_WIDTH);
      const normalizedHeight = normalizeRectangleSize(height, DEFAULT_RECTANGLE_HEIGHT);
      const halfWidth = Math.max(1, normalizedWidth / 2);
      const halfHeight = Math.max(1, normalizedHeight / 2);
      const diagonal = Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight);
      return Math.max(6, diagonal);
    }

    function findPointIndexNear(x, y, targetPoints = [], radius = 0) {
      if (!Array.isArray(targetPoints) || !targetPoints.length || radius <= 0) {
        return -1;
      }

      const radiusSq = radius * radius;
      for (let index = 0; index < targetPoints.length; index += 1) {
        const point = targetPoints[index];
        if (!point) {
          continue;
        }

        const dx = point.x - x;
        const dy = point.y - y;
        if (dx * dx + dy * dy <= radiusSq) {
          return index;
        }
      }

      return -1;
    }

    function findSharedPointNear(x, y) {
      if (!routesCache.size) {
        return null;
      }

      const activePathType = normalizePathType(pathType);
      if (activePathType !== PATH_TYPE_POINT && activePathType !== PATH_TYPE_RECTANGLE) {
        return null;
      }

      const activeLocationKey = getCurrentLocationKey();
      let closestPoint = null;
      let closestDistanceSq = Number.POSITIVE_INFINITY;
      const activeDetectionRadius =
        activePathType === PATH_TYPE_RECTANGLE
          ? getRectangleDetectionRadius(rectangleWidth, rectangleHeight)
          : getPointDetectionRadius(pointDiameter);

      routesCache.forEach((data, routeKey) => {
        if (!data || routeKey === currentRouteKey) {
          return;
        }

        const routeLocationKey = normalizeWallKey(
          typeof data?.locationKey === 'string'
            ? data.locationKey
            : normalizeLocationName(data?.location),
        );

        if (activeLocationKey && routeLocationKey !== activeLocationKey) {
          return;
        }

        if (normalizePathType(data.pathType) !== activePathType) {
          return;
        }

        let detectionRadius = activeDetectionRadius;

        if (activePathType === PATH_TYPE_POINT) {
          const routeDiameter = normalizePointDiameter(
            typeof data?.pointDiameter === 'number' ? data.pointDiameter : pointDiameter,
          );
          detectionRadius = Math.max(activeDetectionRadius, getPointDetectionRadius(routeDiameter));
        } else {
          const routeWidth = normalizeRectangleSize(
            typeof data?.rectangleWidth === 'number' ? data.rectangleWidth : rectangleWidth,
            DEFAULT_RECTANGLE_WIDTH,
          );
          const routeHeight = normalizeRectangleSize(
            typeof data?.rectangleHeight === 'number' ? data.rectangleHeight : rectangleHeight,
            DEFAULT_RECTANGLE_HEIGHT,
          );
          detectionRadius = Math.max(
            activeDetectionRadius,
            getRectangleDetectionRadius(routeWidth, routeHeight),
          );
        }

        const detectionRadiusSq = detectionRadius * detectionRadius;
        const routePoints = convertNormalizedToCanvasPoints(data.points);

        routePoints.forEach((point) => {
          if (!point) {
            return;
          }

          const dx = point.x - x;
          const dy = point.y - y;
          const distanceSq = dx * dx + dy * dy;
          if (distanceSq <= detectionRadiusSq && distanceSq < closestDistanceSq) {
            closestDistanceSq = distanceSq;
            closestPoint = { x: point.x, y: point.y };
          }
        });
      });

      if (!closestPoint) {
        return null;
      }

      const existingIndex = findPointIndexNear(closestPoint.x, closestPoint.y, points, activeDetectionRadius);
      if (existingIndex >= 0) {
        return null;
      }

      return closestPoint;
    }

    function addPoint(event) {
      if (shouldIgnoreNextClick) {
        shouldIgnoreNextClick = false;
        return;
      }

      if (!isDrawingEnabled) {
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const currentPathType = normalizePathType(pathType);
      if (currentPathType === PATH_TYPE_BREZER) {
        const removalIndex = findPointIndexNear(x, y, points, BREZER_REMOVAL_RADIUS);
        if (removalIndex >= 0) {
          points.splice(removalIndex, 1);
          loadedNormalizedPoints = null;
          redraw();
          markUnsavedChange();
          return;
        }
      }
      if (currentPathType === PATH_TYPE_POINT || currentPathType === PATH_TYPE_RECTANGLE) {
        const detectionRadius =
          currentPathType === PATH_TYPE_RECTANGLE
            ? getRectangleDetectionRadius(rectangleWidth, rectangleHeight)
            : getPointDetectionRadius(pointDiameter);
        const existingIndex = findPointIndexNear(x, y, points, detectionRadius);
        if (existingIndex >= 0) {
          points.splice(existingIndex, 1);
          loadedNormalizedPoints = null;
          redraw();
          markUnsavedChange();
          return;
        }

        const sharedPoint = findSharedPointNear(x, y);
        if (sharedPoint) {
          points.push(sharedPoint);
          loadedNormalizedPoints = null;
          redraw();
          markUnsavedChange();
          return;
        }
      }

      points.push({ x, y });
      loadedNormalizedPoints = null;
      redraw();
      markUnsavedChange();
    }

    function clearCanvas() {
      if (!points.length) {
        return;
      }
      points.length = 0;
      loadedNormalizedPoints = null;
      redraw();
      markUnsavedChange();
    }

    function sanitizeColor(value) {
      if (typeof value === 'string' && /^#([0-9a-f]{6})$/i.test(value)) {
        return value;
      }
      return '#ffde59';
    }

    function applyRouteToCanvas(routeKey, rawData = {}) {
      const data = normalizeRouteData(rawData);

      const targetLocation = findLocationByName(data.location) || DEFAULT_LOCATION;
      setLocation(targetLocation, {
        persist: false,
        refreshRoutes: false,
        wallFallback: {
          pointDiameter: data.pointDiameter,
          rectangleWidth: data.rectangleWidth,
          rectangleHeight: data.rectangleHeight,
          gradeBarBaseHeight: data.gradeBarBaseHeight,
          gradeBarMaxHeight: data.gradeBarMaxHeight,
          gradeBarWidth: data.gradeBarWidth,
          transparency: data.gradeBarTransparency,
        },
      });

      pathType = data.pathType || DEFAULT_PATH_TYPE;
      updatePathControls();

      currentRouteKey = routeKey;
      routeSelector.value = routeKey;
      routeSetterInput.value = data.setter || currentUsername || '';
      routeTitleInput.value = data.title;
      routeDescriptionInput.value = data.description;
      routeDateSetInput.value = isoStringToInputValue(data.date_set) || '';
      strokeColor = data.strokeColor;
      currentRouteMedianGrade = data.medianGrade ?? null;
      colorPicker.value = strokeColor;
      syncAdvancedColorPicker(strokeColor);
      applyNormalizedPoints(data.points);
      deleteButton.disabled = !routeKey;
      resetUnsavedState();

      if (routeKey) {
        routesCache.set(routeKey, data);
        const label = data.title || routeKey;
        setStatus(`Loaded route ‚Äú${label}‚Äù.`, 'success');
      }
    }

    function prepareNewRoute(statusMessage = '') {
      currentRouteKey = '';
      routeSelector.value = '';
      routeSetterInput.value = currentUsername || '';
      routeTitleInput.value = '';
      routeDescriptionInput.value = '';
      routeDateSetInput.value = getNowInputValue();
      strokeColor = '#ffde59';
      colorPicker.value = strokeColor;
      syncAdvancedColorPicker(strokeColor);
      setDrawingEnabled(false);
      const wallSettings = getWallSettingsForLocation(getCurrentLocationKey());
      pathType = DEFAULT_PATH_TYPE;
      pointDiameter = wallSettings.pointDiameter;
      rectangleWidth = wallSettings.rectangleWidth;
      rectangleHeight = wallSettings.rectangleHeight;
      unfocusedTransparency = wallSettings.unfocusedTransparency;
      gradeBarBaseHeight = wallSettings.gradeBarBaseHeight;
      gradeBarMaxHeight = wallSettings.gradeBarMaxHeight;
      gradeBarWidth = wallSettings.gradeBarWidth;
      gradeBarTransparency = wallSettings.gradeBarTransparency;
      currentRouteMedianGrade = null;
      updatePathControls();
      updateAppearanceControls();
      loadedNormalizedPoints = null;
      points.length = 0;
      redraw();
      deleteButton.disabled = true;
      resetUnsavedState();
      if (statusMessage) {
        setStatus(statusMessage, 'info');
      } else {
        clearStatus();
      }
    }

    async function loadRoutesList(selectedRouteKey = '') {
      try {
        routeSelector.disabled = true;
        const currentLocationKey = getCurrentLocationKey();
        const previousSettings = getWallSettingsForLocation(currentLocationKey);
        await refreshWallSettingsCache();
        const resolvedSettings = getWallSettingsForLocation(currentLocationKey);
        const pathSettingsChanged =
          resolvedSettings.pointDiameter !== previousSettings.pointDiameter ||
          resolvedSettings.rectangleWidth !== previousSettings.rectangleWidth ||
          resolvedSettings.rectangleHeight !== previousSettings.rectangleHeight ||
          resolvedSettings.unfocusedTransparency !== previousSettings.unfocusedTransparency;

        if (pathSettingsChanged) {
          pointDiameter = resolvedSettings.pointDiameter;
          rectangleWidth = resolvedSettings.rectangleWidth;
          rectangleHeight = resolvedSettings.rectangleHeight;
          unfocusedTransparency = resolvedSettings.unfocusedTransparency;
          updatePathControls();
        }

        const appearanceSettingsChanged =
          resolvedSettings.gradeBarBaseHeight !== previousSettings.gradeBarBaseHeight ||
          resolvedSettings.gradeBarMaxHeight !== previousSettings.gradeBarMaxHeight ||
          resolvedSettings.gradeBarWidth !== previousSettings.gradeBarWidth ||
          resolvedSettings.gradeBarTransparency !== previousSettings.gradeBarTransparency;

        if (appearanceSettingsChanged) {
          gradeBarBaseHeight = resolvedSettings.gradeBarBaseHeight;
          gradeBarMaxHeight = resolvedSettings.gradeBarMaxHeight;
          gradeBarWidth = resolvedSettings.gradeBarWidth;
          gradeBarTransparency = resolvedSettings.gradeBarTransparency;
          updateAppearanceControls();
        }

        const [routesSnapshot, medianMap] = await Promise.all([
          getDocs(collection(db, 'routes')),
          fetchMedianGrades(),
        ]);
        routeMedianGrades = medianMap instanceof Map ? medianMap : new Map();
        routesCache.clear();
        routesSnapshot.forEach((docSnap) => {
          routesCache.set(docSnap.id, normalizeRouteData({ id: docSnap.id, ...docSnap.data() }));
        });

        updateRoutesForAllWalls();

        const sortedEntries = [...routesCache.entries()].sort((a, b) => {
          const labelA = (a[1]?.title || a[0]).toLowerCase();
          const labelB = (b[1]?.title || b[0]).toLowerCase();
          return labelA.localeCompare(labelB);
        });

        const activeLocationKey = getCurrentLocationKey();
        const filteredEntries = sortedEntries.filter(([_, data]) => {
          const routeLocationKey =
            typeof data?.locationKey === 'string'
              ? data.locationKey
              : normalizeLocationName(data?.location);
          if (!activeLocationKey) {
            return true;
          }
          return routeLocationKey === activeLocationKey;
        });

        routeSelector.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Create new route‚Ä¶';
        routeSelector.appendChild(defaultOption);

        filteredEntries.forEach(([id, data]) => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = data?.title || id;
          routeSelector.appendChild(option);
        });

        if (selectedRouteKey && filteredEntries.some(([id]) => id === selectedRouteKey)) {
          routeSelector.value = selectedRouteKey;
        } else {
          routeSelector.value = '';
        }
      } catch (error) {
        console.error('Failed to load routes:', error);
        setStatus('Failed to load routes. Please try again.', 'error');
        throw error;
      } finally {
        routeSelector.disabled = false;
        redraw();
      }
    }

    async function saveRoute() {
      if (isSaving) {
        return;
      }

      const previousRouteKey = currentRouteKey;
      setDrawingEnabled(false);

      if (points.length < 2) {
        setStatus('Add at least two points to define the route.', 'error');
        return;
      }

      const normalizedPoints = convertPointsToNormalized();
      const setter = normalizeSetterName(routeSetterInput.value);
      routeSetterInput.value = setter;
      if (!setter) {
        setStatus('Setter name is required before saving.', 'error');
        routeSetterInput.focus();
        return;
      }

      if (!isValidSetterName(setter)) {
        setStatus('Setter name must use letters, numbers, underscores, or spaces.', 'error');
        routeSetterInput.focus();
        return;
      }

      const title = routeTitleInput.value.trim();
      routeTitleInput.value = title;
      if (!title) {
        setStatus('Route title is required before saving.', 'error');
        routeTitleInput.focus();
        return;
      }

      const routeKey = createRouteKeyFromTitle(title);
      if (!routeKey) {
        setStatus('Route title must include valid characters.', 'error');
        routeTitleInput.focus();
        return;
      }

      const conflictingKey = findConflictingRouteKey(title, previousRouteKey);
      if (conflictingKey && conflictingKey !== previousRouteKey) {
        setStatus('Another route already uses this title. Choose a different title.', 'error');
        routeTitleInput.focus();
        return;
      }

      if (routesCache.has(routeKey) && routeKey !== previousRouteKey) {
        setStatus('Another route already uses this title. Choose a different title.', 'error');
        routeTitleInput.focus();
        return;
      }

      const isRenaming = Boolean(previousRouteKey && previousRouteKey !== routeKey);

      const description = routeDescriptionInput.value.trim();
      routeDescriptionInput.value = description;
      const dateSetIso = inputValueToIsoString(routeDateSetInput.value);
      if (!dateSetIso) {
        setStatus('Enter a valid set date for the route.', 'error');
        routeDateSetInput.focus();
        return;
      }

      const currentLocationKey = getCurrentLocationKey();
      const wallSettings = getWallSettingsForLocation(currentLocationKey);
      const normalizedPathType = normalizePathType(pathType);
      const normalizedPointDiameter = wallSettings.pointDiameter;
      const normalizedRectangleWidth = wallSettings.rectangleWidth;
      const normalizedRectangleHeight = wallSettings.rectangleHeight;
      const normalizedUnfocusedTransparency = wallSettings.unfocusedTransparency;
      pathType = normalizedPathType;
      pointDiameter = normalizedPointDiameter;
      rectangleWidth = normalizedRectangleWidth;
      rectangleHeight = normalizedRectangleHeight;
      unfocusedTransparency = normalizedUnfocusedTransparency;
      updatePathControls();

      const payload = {
        setter,
        title,
        description: description || null,
        strokeColor,
        pathType: normalizedPathType,
        points: normalizedPoints,
        date_set: dateSetIso,
        date_removed: deleteField(),
        location: currentLocation?.name || DEFAULT_LOCATION?.name || null,
        updatedAt: serverTimestamp(),
      };

      const routeRef = doc(db, 'routes', routeKey);

      try {
        isSaving = true;
        saveButton.disabled = true;
        routeSelector.disabled = true;
        deleteButton.disabled = true;
        setStatus('Saving route‚Ä¶', 'info');

        const existingSnap = await getDoc(routeRef);
        if (!existingSnap.exists()) {
          payload.createdAt = serverTimestamp();
        }

        await setDoc(routeRef, payload, { merge: true });

        loadedNormalizedPoints = normalizedPoints;
        currentRouteKey = routeKey;
        routesCache.set(
          routeKey,
          normalizeRouteData({
            id: routeKey,
            ...payload,
            pointDiameter: normalizedPointDiameter,
            rectangleWidth: normalizedRectangleWidth,
            rectangleHeight: normalizedRectangleHeight,
          }),
        );

        if (isRenaming) {
          try {
            await deleteDoc(doc(db, 'routes', previousRouteKey));
            routesCache.delete(previousRouteKey);
          } catch (error) {
            console.warn('Failed to delete previous route entry:', error);
          }
        }

        resetUnsavedState();

        const label = title || routeKey;
        await loadRoutesList(routeKey);
        prepareNewRoute();
        setStatus(`Route ‚Äú${label}‚Äù saved successfully.`, 'success');
      } catch (error) {
        console.error('Failed to save route:', error);
        setStatus(error.message || 'Failed to save route.', 'error');
      } finally {
        isSaving = false;
        saveButton.disabled = false;
        routeSelector.disabled = false;
        deleteButton.disabled = !currentRouteKey;
      }
    }

    async function deleteCurrentRoute() {
      const targetKey = currentRouteKey;
      if (!targetKey) {
        setStatus('Select a saved route to delete.', 'error');
        return;
      }

      const cachedRoute = routesCache.get(targetKey);
      const routeLabel = cachedRoute?.title || targetKey;
      const confirmed = window.confirm(`Delete route ‚Äú${routeLabel}‚Äù? This cannot be undone.`);
      if (!confirmed) {
        return;
      }

      try {
        saveButton.disabled = true;
        deleteButton.disabled = true;
        routeSelector.disabled = true;
        setStatus('Deleting route‚Ä¶', 'info');

        await deleteDoc(doc(db, 'routes', targetKey));
        routesCache.delete(targetKey);

        await loadRoutesList();
        prepareNewRoute('Route deleted. You can create a new one.');
        setStatus(`Route ‚Äú${routeLabel}‚Äù deleted.`, 'success');
      } catch (error) {
        console.error('Failed to delete route:', error);
        setStatus(error.message || 'Failed to delete route.', 'error');
        deleteButton.disabled = false;
      } finally {
        saveButton.disabled = false;
        routeSelector.disabled = false;
      }
    }

    [routeSetterInput, routeTitleInput, routeDescriptionInput].forEach((element) => {
      if (element) {
        element.addEventListener('input', markUnsavedChange);
      }
    });

    if (routeDateSetInput) {
      routeDateSetInput.addEventListener('change', markUnsavedChange);
      routeDateSetInput.addEventListener('input', markUnsavedChange);
    }

    if (saveAppearanceButton) {
      saveAppearanceButton.addEventListener('click', async () => {
        const locationKey = getCurrentLocationKey();
        if (!locationKey) {
          setStatus('Select a wall before saving appearance.', 'error');
          return;
        }

        const nextPointDiameter = normalizePointDiameter(
          appearancePointDiameterInput?.value ?? pointDiameter,
        );
        const nextGradeBarBaseHeight = normalizeGradeBarHeight(
          gradeBarBaseHeightInput?.value,
          DEFAULT_GRADE_BAR_BASE_HEIGHT,
        );
        const nextGradeBarMaxHeight = Math.max(
          nextGradeBarBaseHeight,
          normalizeGradeBarHeight(gradeBarMaxHeightInput?.value, DEFAULT_GRADE_BAR_MAX_HEIGHT),
        );
        const nextGradeBarWidth = normalizeGradeBarWidth(
          gradeBarWidthInput?.value,
        );
        const nextGradeBarTransparency = normalizeGradeBarTransparency(
          gradeBarTransparencyInput?.value,
        );

        try {
          await persistWallSettings(locationKey, {
            pointDiameter: nextPointDiameter,
            gradeBarBaseHeight: nextGradeBarBaseHeight,
            gradeBarMaxHeight: nextGradeBarMaxHeight,
            gradeBarWidth: nextGradeBarWidth,
            transparency: nextGradeBarTransparency,
          });
          setStatus('Appearance saved.', 'success');
        } catch (error) {
          console.error('Failed to save appearance settings:', error);
          setStatus('Failed to save appearance. Please try again.', 'error');
        }
      });
    }

    canvas.addEventListener('click', addPoint);
    window.addEventListener('resize', resizeCanvas);

    clearButton.addEventListener('click', clearCanvas);
    saveButton.addEventListener('click', saveRoute);
    if (cancelRouteButton) {
      cancelRouteButton.addEventListener('click', () => {
        setDrawingEnabled(false);
      });
    }
    deleteButton.addEventListener('click', deleteCurrentRoute);
    routeSelector.addEventListener('change', async (event) => {
      const selectedKey = event.target.value;
      if (!selectedKey) {
        setDrawingEnabled(false);
        prepareNewRoute('Creating a new route.');
        return;
      }

      let data = routesCache.get(selectedKey);
      if (!data) {
        try {
          const snap = await getDoc(doc(db, 'routes', selectedKey));
          if (snap.exists()) {
            data = normalizeRouteData({ id: selectedKey, ...snap.data() });
            routesCache.set(selectedKey, data);
          }
        } catch (error) {
          console.error('Failed to fetch route:', error);
        }
      }

      if (!data) {
        setStatus('Unable to load the selected route.', 'error');
        return;
      }

      applyRouteToCanvas(selectedKey, data);
    });

    colorPicker.addEventListener('input', (event) => {
      strokeColor = sanitizeColor(event.target.value || '#ffde59');
      loadedNormalizedPoints = null;
      redraw();
      markUnsavedChange();
      syncAdvancedColorPicker(strokeColor);
    });

    if (pathTypeSelect) {
      pathTypeSelect.addEventListener('change', (event) => {
        const selectedType = normalizePathType(event.target.value);
        if (pathType === selectedType) {
          updatePathControls();
          return;
        }

        pathType = selectedType;
        updatePathControls();

        if (currentRouteKey && routesCache.has(currentRouteKey)) {
          const cached = routesCache.get(currentRouteKey);
          routesCache.set(currentRouteKey, { ...cached, pathType: selectedType });
        }

        redraw();
        markUnsavedChange();
      });
    }

    if (pointDiameterSlider) {
      pointDiameterSlider.addEventListener('input', (event) => {
        const nextValue = normalizePointDiameter(event.target.value);
        if (pointDiameter === nextValue) {
          updatePathControls();
          updateAppearanceControls();
          return;
        }

        pointDiameter = nextValue;
        updatePathControls();
        updateAppearanceControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter: nextValue,
            rectangleWidth,
            rectangleHeight,
            unfocusedTransparency,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      pointDiameterSlider.addEventListener('change', async (event) => {
        const nextValue = normalizePointDiameter(event.target.value);
        if (pointDiameter !== nextValue) {
          pointDiameter = nextValue;
          updatePathControls();
          updateAppearanceControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { pointDiameter: nextValue });
          } catch (error) {
            console.error('Failed to persist wall point diameter:', error);
          }
        }
      });
    }

    if (rectangleWidthSlider) {
      rectangleWidthSlider.addEventListener('input', (event) => {
        const nextValue = normalizeRectangleSize(event.target.value, DEFAULT_RECTANGLE_WIDTH);
        if (rectangleWidth === nextValue) {
          updatePathControls();
          return;
        }

        rectangleWidth = nextValue;
        updatePathControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter,
            rectangleWidth: nextValue,
            rectangleHeight,
            unfocusedTransparency,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      rectangleWidthSlider.addEventListener('change', async (event) => {
        const nextValue = normalizeRectangleSize(event.target.value, DEFAULT_RECTANGLE_WIDTH);
        if (rectangleWidth !== nextValue) {
          rectangleWidth = nextValue;
          updatePathControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { rectangleWidth: nextValue });
          } catch (error) {
            console.error('Failed to persist rectangle width:', error);
          }
        }
      });
    }

    if (rectangleHeightSlider) {
      rectangleHeightSlider.addEventListener('input', (event) => {
        const nextValue = normalizeRectangleSize(event.target.value, DEFAULT_RECTANGLE_HEIGHT);
        if (rectangleHeight === nextValue) {
          updatePathControls();
          return;
        }

        rectangleHeight = nextValue;
        updatePathControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter,
            rectangleWidth,
            rectangleHeight: nextValue,
            unfocusedTransparency,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      rectangleHeightSlider.addEventListener('change', async (event) => {
        const nextValue = normalizeRectangleSize(event.target.value, DEFAULT_RECTANGLE_HEIGHT);
        if (rectangleHeight !== nextValue) {
          rectangleHeight = nextValue;
          updatePathControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { rectangleHeight: nextValue });
          } catch (error) {
            console.error('Failed to persist rectangle height:', error);
          }
        }
      });
    }

    if (unfocusedTransparencySlider) {
      unfocusedTransparencySlider.addEventListener('input', (event) => {
        const nextValue = sliderValueToUnfocusedTransparency(event.target.value);
        if (unfocusedTransparency === nextValue) {
          updatePathControls();
          return;
        }

        unfocusedTransparency = nextValue;
        updatePathControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter,
            rectangleWidth,
            rectangleHeight,
            unfocusedTransparency: nextValue,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      unfocusedTransparencySlider.addEventListener('change', async (event) => {
        const nextValue = sliderValueToUnfocusedTransparency(event.target.value);
        if (unfocusedTransparency !== nextValue) {
          unfocusedTransparency = nextValue;
          updatePathControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { unfocusedTransparency: nextValue });
          } catch (error) {
            console.error('Failed to persist unfocused transparency:', error);
          }
        }
      });
    }

    if (createWallButton) {
      createWallButton.addEventListener('click', () => {
        void handleCreateWall();
      });
    }

    if (deleteWallButton) {
      deleteWallButton.addEventListener('click', () => {
        void handleDeleteWall();
      });
    }

    [newWallNameInput, newWallImageInput].forEach((input) => {
      if (!input) {
        return;
      }
      input.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          void handleCreateWall();
        }
      });
    });

    if (backgroundImage.complete) {
      backgroundReady = true;
      if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
        const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
        if (Number.isFinite(ratio) && ratio > 0) {
          canvasAspectRatio = ratio;
        }
      }
      resizeCanvas();
    } else {
      resizeCanvas();
    }

    let authMode = 'login';

    function setAuthMode(mode) {
      authMode = mode;
      const isLogin = authMode === 'login';
      authTitle.textContent = isLogin ? 'Sign in to continue' : 'Create your account';
      authSwitchLabel.textContent = isLogin ? "Don't have an account?" : 'Already have an account?';
      toggleAuthModeButton.textContent = isLogin ? 'Create one' : 'Sign in';
      authForm.querySelector('.auth-submit').textContent = isLogin ? 'Sign In' : 'Create Account';
      authPassword.setAttribute('autocomplete', isLogin ? 'current-password' : 'new-password');
      authError.textContent = '';
    }

    toggleAuthModeButton.addEventListener('click', () => {
      setAuthMode(authMode === 'login' ? 'register' : 'login');
    });

    async function lookupUsernameByUid(uid) {
      if (!uid) {
        return '';
      }

      try {
        const snapshot = await getDocs(query(collection(db, 'usernames'), where('uid', '==', uid), limit(1)));

        if (snapshot.empty) {
          return '';
        }

        const docSnap = snapshot.docs[0];
        const data = docSnap.data() || {};
        const fromField = normalizeUsername(data.username);
        const fromId = normalizeUsername(docSnap.id);
        return fromField || fromId;
      } catch (error) {
        console.error('Failed to look up username by UID:', error);
        return '';
      }
    }

    async function resolveUsernameForUser(user) {
      if (!user) {
        return '';
      }

      const displayName = normalizeUsername(user.displayName);
      if (isValidUsername(displayName)) {
        return displayName;
      }

      const mapped = await lookupUsernameByUid(user.uid);
      if (isValidUsername(mapped)) {
        if (!displayName) {
          try {
            await updateProfile(user, { displayName: mapped });
          } catch (error) {
            console.warn('Unable to synchronise display name with username:', error);
          }
        }
        return mapped;
      }

      const syntheticEmail = typeof user.email === 'string' ? user.email : '';
      if (syntheticEmail.endsWith(`@${SYNTHETIC_EMAIL_DOMAIN}`)) {
        const derived = normalizeUsername(
          syntheticEmail.slice(0, -(`@${SYNTHETIC_EMAIL_DOMAIN}`.length)),
        );
        if (isValidUsername(derived)) {
          return derived;
        }
      }

      return '';
    }

    authForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      authError.textContent = '';
      const rawUsername = authUsername.value;
      const normalizedUsername = normalizeUsername(rawUsername);
      const password = authPassword.value;

      if (!normalizedUsername) {
        authError.textContent = 'Enter your username to continue.';
        return;
      }

      if (!isValidUsername(normalizedUsername)) {
        authError.textContent =
          'Usernames must be 3-20 characters using only letters, numbers, or underscores.';
        return;
      }

      const syntheticEmail = buildSyntheticEmail(normalizedUsername);

      try {
        if (authMode === 'login') {
          await signInWithEmailAndPassword(auth, syntheticEmail, password);
          return;
        }

        const credentials = await createUserWithEmailAndPassword(auth, syntheticEmail, password);
        const { user } = credentials;

        try {
          await setDoc(doc(db, 'usernames', normalizedUsername), {
            uid: user.uid,
            username: normalizedUsername,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
          });
        } catch (error) {
          console.error('Failed to reserve username:', error);
          try {
            await deleteUser(user);
          } catch (cleanupError) {
            console.warn('Unable to clean up user after username failure:', cleanupError);
          }
          const usernameError = new Error('Username unavailable');
          usernameError.code = 'auth/username-unavailable';
          throw usernameError;
        }

        try {
          await updateProfile(user, { displayName: normalizedUsername });
        } catch (profileError) {
          console.warn('Failed to update display name:', profileError);
        }
      } catch (error) {
        let message = 'Unable to complete the request. Please try again.';

        switch (error?.code) {
          case 'auth/user-not-found':
          case 'auth/wrong-password':
            message = 'Invalid username or password.';
            break;
          case 'auth/email-already-in-use':
          case 'auth/username-unavailable':
          case 'permission-denied':
            message = 'That username is already taken. Choose another one.';
            break;
          case 'auth/invalid-email':
            message = 'Enter a valid username.';
            break;
          case 'auth/weak-password':
            message = 'Choose a stronger password (at least 6 characters).';
            break;
          default:
            if (error?.message) {
              message = error.message;
            }
        }

        authError.textContent = message;
      }
    });

    signOutButton.addEventListener('click', async () => {
      await signOutAndRedirectToIndex();
    });

    unauthorizedSignOut.addEventListener('click', async () => {
      await signOutAndRedirectToIndex();
    });

    async function ensureUserRole(user, username) {
      if (!user) {
        return null;
      }

      const normalizedUsername = normalizeUsername(username);

      if (!normalizedUsername) {
        return { role: 'default' };
      }

      try {
        const roleRef = doc(db, 'roles', user.uid);
        const roleSnap = await getDoc(roleRef);

        if (roleSnap.exists()) {
          const data = roleSnap.data() || {};
          const storedLowerRaw =
            typeof data.usernameLower === 'string'
              ? data.usernameLower
              : typeof data.username === 'string'
              ? data.username
              : '';
          let effectiveLower = normalizeUsername(storedLowerRaw);
          const trimmedRole =
            typeof data.role === 'string' ? data.role.trim().toLowerCase() : 'default';
          const mergedData = {
            ...data,
            role: trimmedRole,
          };

          if (effectiveLower !== normalizedUsername || !data.username) {
            try {
              await setDoc(
                roleRef,
                {
                  username: normalizedUsername,
                  usernameLower: normalizedUsername,
                  updatedAt: serverTimestamp(),
                },
                { merge: true },
              );
              mergedData.username = normalizedUsername;
              mergedData.usernameLower = normalizedUsername;
              effectiveLower = normalizedUsername;
            } catch (error) {
              console.warn('Failed to synchronise username on role document:', error);
            }
          }

          if (effectiveLower !== normalizedUsername) {
            mergedData.role = 'default';
          }

          return mergedData;
        }

        let role = 'default';

        try {
          const snapshot = await getDocs(
            query(collection(db, 'roles'), where('role', '==', 'setter'), limit(1)),
          );
          if (snapshot.empty) {
            role = 'setter';
          }
        } catch (error) {
          console.warn('Unable to inspect existing roles:', error);
        }

        const roleData = {
          role,
          username: normalizedUsername,
          usernameLower: normalizedUsername,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        };

        await setDoc(roleRef, roleData, { merge: true });
        return roleData;
      } catch (error) {
        console.error('Failed to ensure user role:', error);
        return { role: 'default' };
      }
    }

    async function resolveUserRole(user, username) {
      if (!user) {
        return null;
      }

      const normalizedUsername = normalizeUsername(username);
      if (!isValidUsername(normalizedUsername)) {
        return 'default';
      }

      try {
        const ensuredRole = await ensureUserRole(user, normalizedUsername);
        return typeof ensuredRole?.role === 'string'
          ? ensuredRole.role.trim().toLowerCase()
          : 'default';
      } catch (error) {
        console.error('Failed to fetch user role:', error);
        return 'default';
      }
    }

    function handleUnauthorized() {
      appContent.classList.add('hidden');
      unauthorizedNotice.classList.remove('hidden');
      routeSelector.disabled = true;
      deleteButton.disabled = true;
      clearStatus();
      setRoleControlsEnabled(false);
      resetRoleManagementUI('Setter access required to manage roles.');
      updateAdminConsoleAccess('');
      void finishTutorial();
    }

    function handleAuthorized(role) {
      unauthorizedNotice.classList.add('hidden');
      appContent.classList.remove('hidden');
      routeSelector.disabled = false;
      setRoleControlsEnabled(true);
      clearRoleStatus();
      const normalizedRole = typeof role === 'string' ? role.trim().toLowerCase() : '';
      updateAdminConsoleAccess(normalizedRole);
    }

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        currentUserId = user.uid;
        authOverlay.classList.add('hidden');

        const resolvedUsername = await resolveUsernameForUser(user);
        if (!isValidUsername(resolvedUsername)) {
          authError.textContent =
            'Unable to resolve your username. Please contact another setter for assistance.';
          await signOutAndRedirectToIndex();
          return;
        }

        currentUsername = resolvedUsername;

        const role = await resolveUserRole(user, resolvedUsername);

        if (!role) {
          authError.textContent = 'Unable to determine your role. Please try again later.';
          await signOutAndRedirectToIndex();
          return;
        }

        if (role !== 'setter' && role !== 'admin') {
          handleUnauthorized();
          return;
        }

        handleAuthorized(role);

        try {
          await loadRoutesList(currentRouteKey);
          if (currentRouteKey && routesCache.has(currentRouteKey)) {
            applyRouteToCanvas(currentRouteKey, routesCache.get(currentRouteKey));
          } else {
            prepareNewRoute('Select a saved route or start drawing a new one.');
          }
        } catch (error) {
          console.error('Unable to initialise routes:', error);
        }

        await startTutorial();
      } else {
        currentUsername = '';
        currentUserId = null;
        authOverlay.classList.remove('hidden');
        appContent.classList.add('hidden');
        unauthorizedNotice.classList.add('hidden');
        routeSelector.disabled = true;
        deleteButton.disabled = true;
        authForm.reset();
        prepareNewRoute();
        clearStatus();
        setRoleControlsEnabled(false);
        resetRoleManagementUI();
        setAuthMode('login');
        updateAdminConsoleAccess('');
        void finishTutorial();
      }
    });

    refreshWallSettingsCache()
      .then(() => {
        const locationKey = getCurrentLocationKey();
        const wallSettings = getWallSettingsForLocation(locationKey);
        pointDiameter = wallSettings.pointDiameter;
        unfocusedTransparency = wallSettings.unfocusedTransparency;
        updatePathControls();
        updateRoutesForAllWalls();
        redraw();
      })
      .catch((error) => {
        console.warn('Unable to initialise wall settings cache:', error);
      });

    setAuthMode('login');

    prepareNewRoute();
  </script>
</body>
</html>
