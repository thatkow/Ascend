<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ascend</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #000;
      --wall-background: url('./location/New Wall.jpg');
      background-image: var(--wall-background);
      background-position: center;
      background-size: 100% 100%;
      background-repeat: no-repeat;
      background-attachment: fixed;
      color: #fff;
      overflow: hidden;
    }

    .hidden {
      display: none !important;
    }

    .canvas-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .canvas-container.scrollable {
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
    }

    .focus-footer {
      position: absolute;
      left: 50%;
      bottom: 1.25rem;
      transform: translateX(-50%);
      z-index: 7;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .clear-focus-button {
      pointer-events: auto;
      border-radius: 999px;
      border: 1px solid rgba(126, 217, 87, 0.75);
      background: linear-gradient(135deg, rgba(126, 217, 87, 0.95), rgba(126, 217, 87, 0.7));
      color: #0c1905;
      font-weight: 600;
      padding: 0.6rem 1.5rem;
      font-size: 0.95rem;
      cursor: pointer;
      box-shadow: 0 14px 30px rgba(126, 217, 87, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
        border-color 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      letter-spacing: 0.01em;
    }

    .clear-focus-button:hover,
    .clear-focus-button:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 18px 36px rgba(126, 217, 87, 0.4);
      outline: none;
      border-color: rgba(126, 217, 87, 0.9);
      background: linear-gradient(135deg, rgba(126, 217, 87, 1), rgba(126, 217, 87, 0.82));
    }

    .tutorial-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      background-color: transparent;
      backdrop-filter: none;
      z-index: 30;
    }

    .tutorial-overlay.is-bottom-aligned {
      align-items: flex-end;
    }

    .tutorial-overlay.is-bottom-aligned .tutorial-card {
      margin-bottom: clamp(1.5rem, 8vh, 4rem);
    }

    .tutorial-card {
      width: min(520px, 100%);
      background: rgba(12, 18, 15, 0.95);
      border-radius: 1rem;
      padding: 1.75rem;
      display: flex;
      flex-direction: column;
      gap: 1.15rem;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(126, 217, 87, 0.2);
    }

    .tutorial-progress {
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(126, 217, 87, 0.8);
    }

    .tutorial-title {
      font-size: 1.35rem;
      font-weight: 700;
      line-height: 1.3;
    }

    .tutorial-description {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      color: rgba(248, 250, 252, 0.92);
      font-size: 0.98rem;
      line-height: 1.55;
    }

    .tutorial-description p {
      margin: 0;
    }

    .tutorial-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-end;
    }

    .tutorial-button {
      border-radius: 999px;
      border: none;
      padding: 0.65rem 1.4rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
        color 0.2s ease, border-color 0.2s ease;
    }

    .tutorial-primary {
      background: #7ed957;
      color: #0c1a07;
      box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
    }

    .tutorial-primary:hover,
    .tutorial-primary:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 18px 30px rgba(126, 217, 87, 0.35);
      outline: none;
    }

    .tutorial-secondary {
      background: rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 0.85);
    }

    .tutorial-secondary:hover,
    .tutorial-secondary:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 16px 34px rgba(0, 0, 0, 0.4);
      outline: none;
    }

    .tutorial-highlight {
      position: relative;
      z-index: 50;
      outline: 3px solid rgba(126, 217, 87, 0.9);
      border-radius: 1rem;
    }

    .tutorial-illuminated {
      animation: tutorial-illuminate 1.2s ease-in-out infinite;
    }

    .tutorial-pointer {
      position: fixed;
      width: 102px;
      height: 162px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 60;
      transform: translate(-50%, 0);
    }

    .tutorial-pointer.hidden {
      display: none;
    }

    .tutorial-pointer svg {
      width: 100%;
      height: 100%;
      filter: drop-shadow(0 10px 18px rgba(0, 0, 0, 0.45));
      animation: tutorial-pointer-bounce 1.05s ease-in-out infinite;
    }

    @media (max-width: 768px) {
      .tutorial-pointer {
        width: 51px;
        height: 81px;
      }
    }

    @keyframes tutorial-pointer-bounce {
      0%,
      100% {
        transform: translateY(4px);
      }
      50% {
        transform: translateY(-6px);
      }
    }

    @keyframes tutorial-illuminate {
      0%,
      100% {
        box-shadow: 0 0 0 6px rgba(126, 217, 87, 0.7), 0 0 28px rgba(126, 217, 87, 0.55);
      }
      50% {
        box-shadow: 0 0 0 10px rgba(255, 140, 66, 0.85), 0 0 42px rgba(255, 140, 66, 0.75);
      }
    }

    .sidebar-actions {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    .panel-icon-button {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(0, 0, 0, 0.55);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease,
        border-color 0.2s ease;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      padding: 0;
    }

    .panel-icon-button svg {
      width: 16px;
      height: 16px;
      display: block;
    }

    .panel-toggle-button {
      background: rgba(255, 255, 255, 0.25);
      color: #111;
      border-color: rgba(255, 255, 255, 0.55);
    }

    .panel-toggle-button:hover,
    .panel-toggle-button:focus-visible {
      background: rgba(255, 255, 255, 0.35);
      color: #0a0a0a;
    }

    .panel-toggle-icon {
      display: none;
      width: 16px;
      height: 16px;
    }

    .panel-toggle-icon svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .control-panel[data-expanded='true'] #panelToggle .panel-toggle-icon-close {
      display: block;
    }

    .control-panel[data-expanded='false'] #panelToggle .panel-toggle-icon-open {
      display: block;
    }

    .panel-icon-button:hover,
    .panel-icon-button:focus-visible {
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.18);
      border-color: rgba(255, 255, 255, 0.45);
      outline: none;
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.4);
    }

    .panel-icon-button:focus-visible {
      box-shadow: 0 0 0 4px rgba(126, 217, 87, 0.25), 0 12px 26px rgba(0, 0, 0, 0.4);
    }

    .panel-icon-button.info-button {
      border: 2px solid rgba(255, 255, 255, 0.35);
      background: linear-gradient(135deg, rgba(36, 36, 36, 0.9), rgba(92, 92, 92, 0.45));
      color: #f8fafc;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease,
        border-color 0.2s ease, color 0.2s ease;
    }

    .panel-icon-button.info-button:hover,
    .panel-icon-button.info-button:focus-visible {
      border-color: rgba(255, 255, 255, 0.55);
      background: linear-gradient(135deg, rgba(60, 60, 60, 0.95), rgba(120, 120, 120, 0.45));
    }

    .panel-icon-button.info-button.is-active {
      border-color: rgba(126, 217, 87, 0.6);
      background: #7ed957;
      color: #0c1905;
      box-shadow: 0 8px 22px rgba(126, 217, 87, 0.35);
    }

    .panel-icon-button.info-button.is-active:hover,
    .panel-icon-button.info-button.is-active:focus-visible {
      border-color: rgba(126, 217, 87, 0.9);
      background: #8ae064;
      color: #0c1905;
    }

    .panel-icon-button.drawing-toggle[aria-pressed='true'] {
      background: #15803d;
      border-color: rgba(255, 255, 255, 0.45);
      color: #0d1405;
      box-shadow: 0 16px 32px rgba(21, 128, 61, 0.35);
    }

    .panel-icon-button.drawing-toggle[aria-pressed='true']:hover,
    .panel-icon-button.drawing-toggle[aria-pressed='true']:focus-visible {
      background: #1c8f48;
      color: #031406;
    }

    .info-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .info-popover {
      position: absolute;
      top: 0;
      left: calc(100% + 0.75rem);
      transform: none;
      width: min(240px, 70vw);
      padding: 0.9rem 1rem;
      border-radius: 0.75rem;
      background: rgba(0, 0, 0, 0.85);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.8rem;
      line-height: 1.4;
      text-align: left;
      z-index: 20;
    }

    .info-popover p {
      color: rgba(255, 255, 255, 0.85);
    }

    .info-popover-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .info-popover-button {
      border: none;
      border-radius: 999px;
      padding: 0.5rem 1rem;
      background: rgba(126, 217, 87, 0.85);
      color: #041305;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .info-popover-button:hover,
    .info-popover-button:focus-visible {
      background: rgba(126, 217, 87, 1);
      box-shadow: 0 12px 28px rgba(126, 217, 87, 0.35);
      transform: translateY(-1px);
      outline: none;
    }

    .welcome-callout {
      position: fixed;
      z-index: 60;
      min-width: min(280px, 80vw);
      max-width: min(360px, 80vw);
      padding: 1rem 1.1rem;
      border-radius: 0.85rem;
      background: rgba(10, 16, 11, 0.94);
      border: 1px solid rgba(126, 217, 87, 0.55);
      box-shadow: 0 18px 42px rgba(0, 0, 0, 0.45);
      color: #f8fafc;
      line-height: 1.5;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      pointer-events: auto;
    }

    .welcome-callout::before {
      content: '';
      position: absolute;
      width: 0;
      height: 0;
      border: 10px solid transparent;
    }

    .welcome-callout[data-arrow='top']::before {
      top: -20px;
      left: var(--callout-arrow-offset, 28px);
      border-bottom-color: rgba(10, 16, 11, 0.94);
    }

    .welcome-callout[data-arrow='bottom']::before {
      bottom: -20px;
      left: var(--callout-arrow-offset, 28px);
      border-top-color: rgba(10, 16, 11, 0.94);
    }

    .welcome-callout strong {
      font-size: 0.95rem;
      letter-spacing: 0.01em;
    }

    .welcome-callout p {
      font-size: 0.85rem;
      color: rgba(248, 250, 252, 0.9);
    }

    .welcome-callout p + p {
      margin-top: 0.35rem;
    }

    canvas {
      display: block;
      height: 100%;
      width: auto;
      min-width: 100%;
      cursor: grab;
      transition: cursor 0.15s ease;
    }

    canvas[data-drawing-enabled='true'] {
      cursor: crosshair;
    }

    canvas[data-drawing-enabled='true'][data-pan-modifier='true'] {
      cursor: grab;
    }

    canvas.is-panning {
      cursor: grabbing;
    }

    .control-panel {
      position: fixed;
      top: 0;
      left: 0;
      right: auto;
      height: 100vh;
      display: flex;
      align-items: stretch;
      gap: 0;
      z-index: 12;
      --toggle-visible-width: 36px;
      transition: transform 0.25s ease;
      transform: translateX(0);
    }

    .panel-sidebar {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.85rem;
      align-self: center;
      order: 2;
      padding: 1rem 0.5rem;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 0 0.85rem 0.85rem 0;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
    }

    .panel-tablist {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.6rem;
    }

    .panel-tab {
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .panel-tab:hover,
    .panel-tab:focus-visible {
      background: rgba(255, 255, 255, 0.22);
    }

    .panel-tab[aria-selected='true'] {
      background: rgba(255, 255, 255, 0.85);
      color: #111;
      border-color: rgba(255, 255, 255, 0.75);
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.4);
    }

    .panel-sidebar::after {
      content: '';
      display: block;
      width: 100%;
      height: 0.5rem;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: stretch;
      width: min(320px, 92vw);
      max-width: 360px;
      height: 100vh;
      padding: 2rem 1.25rem 4rem;
      background: rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(8px);
      border-radius: 0 1rem 1rem 0;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      overflow-y: auto;
      transition: box-shadow 0.25s ease, background 0.25s ease;
      order: 1;
    }

    .control-panel[data-expanded='false'] {
      transform: translateX(calc(-100% + var(--toggle-visible-width)));
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .control-section {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .control-section-title {
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.75);
    }

    .control-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.85rem;
    }

    [data-help-text] {
      position: relative;
    }

    .help-tooltip {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 0.4rem;
      padding: 0.45rem 0.6rem;
      border-radius: 0.75rem;
      background: rgba(15, 15, 15, 0.94);
      border: 1px solid rgba(126, 217, 87, 0.45);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.72rem;
      line-height: 1.4;
      max-width: 260px;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      z-index: 30;
    }

    [data-help-text].showing-help > .help-tooltip {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .control-field span {
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .control-field input,
    .control-field select,
    .control-field textarea {
      border-radius: 0.65rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(0, 0, 0, 0.35);
      color: inherit;
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
    }

    .control-field textarea {
      min-height: 4.5rem;
      resize: vertical;
    }

    .control-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.65rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(0, 0, 0, 0.35);
      font-size: 0.85rem;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .control-toggle span {
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .control-toggle input[type='checkbox'] {
      width: 1.4rem;
      height: 1.4rem;
      flex-shrink: 0;
      accent-color: #7ed957;
    }

    .control-toggle.is-disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .control-toggle.is-disabled input[type='checkbox'] {
      pointer-events: none;
    }

    .tab-panels {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .tab-panel {
      display: none;
      flex-direction: column;
      gap: 1rem;
    }

    .tab-panel[aria-hidden='false'] {
      display: flex;
    }

    .control-row {
      display: flex;
      gap: 0.5rem;
      align-items: flex-end;
    }

    .control-row .control-field {
      flex: 1;
    }

    .controls input[type="color"] {
      width: 100%;
      min-height: 2.5rem;
      border: none;
      padding: 0.25rem;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 0.65rem;
    }

    .color-wheel-toggle {
      background: rgba(255, 255, 255, 0.2);
      color: #111;
      margin-top: 0.5rem;
    }

    .color-wheel-toggle:hover,
    .color-wheel-toggle:focus-visible {
      background: rgba(255, 255, 255, 0.35);
      outline: none;
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(255, 255, 255, 0.2);
    }

    .color-wheel {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-top: 0.75rem;
      padding: 0.75rem;
      border-radius: 0.75rem;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .color-wheel-canvas-wrapper {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #colorWheelCanvas {
      width: min(220px, 100%);
      height: auto;
      max-width: 100%;
      border-radius: 50%;
      touch-action: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
      cursor: crosshair;
    }

    #colorWheelCanvas:focus-visible {
      outline: 2px solid rgba(126, 217, 87, 0.65);
      outline-offset: 4px;
    }

    .color-wheel-marker {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid #fff;
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.4);
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    .color-lightness-control {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .color-lightness-control label {
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .color-lightness-control input[type='range'] {
      width: 100%;
      appearance: none;
      height: 0.65rem;
      border-radius: 999px;
      background: linear-gradient(90deg, #000, #fff);
      cursor: pointer;
    }

    .color-lightness-control input[type='range']::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid rgba(0, 0, 0, 0.6);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .color-lightness-control input[type='range']::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid rgba(0, 0, 0, 0.6);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .color-wheel-preview {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
    }

    .color-wheel-swatch {
      width: 1.8rem;
      height: 1.8rem;
      border-radius: 0.4rem;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: #ffde59;
    }

    .color-wheel-hint {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.7);
      line-height: 1.4;
    }

    .controls button {
      border: none;
      border-radius: 0.65rem;
      padding: 0.55rem 0.85rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
      color: #111;
      text-align: center;
    }

    .location-button {
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 0.85rem;
      padding: 0.65rem 1rem;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
      color: #fff;
      backdrop-filter: blur(6px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      width: 100%;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.45rem;
      margin-bottom: 0.75rem;
    }

    #createWallButton {
      background: #7ed957;
      color: #0d2600;
    }

    .delete-wall-button {
      background: rgba(255, 116, 116, 0.9);
      color: #1a0b0b;
    }

    .location-button:hover,
    .location-button:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
      outline: none;
    }

    .global-actions {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: stretch;
      justify-content: flex-start;
      width: 100%;
    }

    .global-action-button {
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 999px;
      padding: 0.6rem 1.25rem;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
      color: #fff;
      backdrop-filter: blur(6px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.45rem;
      width: 100%;
    }

    .button-icon {
      font-size: 1.05rem;
      line-height: 1;
    }

    .button-label {
      line-height: 1;
    }

    .global-action-button:hover,
    .global-action-button:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
      outline: none;
    }

    #climberViewButton {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    #personalDashboardButton {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    #adminConsoleButton {
      background: rgba(255, 232, 78, 0.95);
      color: #111;
    }

    #signOutButton {
      background: rgba(255, 116, 116, 0.9);
      color: #111;
    }

    #locationButton {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .location-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(3px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1rem;
      z-index: 30;
    }

    .location-modal.hidden {
      display: none !important;
    }

    .location-modal-content {
      background: rgba(18, 18, 18, 0.95);
      border-radius: 1.25rem;
      width: min(720px, 92vw);
      max-height: 90vh;
      padding: 1.5rem;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .location-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .location-modal-title {
      font-size: 1.35rem;
      font-weight: 700;
    }

    .location-modal-close {
      border: none;
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.4rem;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    .location-modal-close:hover,
    .location-modal-close:focus-visible {
      transform: translateY(-1px);
      background: rgba(255, 255, 255, 0.25);
      outline: none;
    }

    .location-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
    }

    .location-option {
      border: none;
      border-radius: 1rem;
      padding: 0;
      background: rgba(255, 255, 255, 0.1);
      color: inherit;
      cursor: pointer;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      text-align: left;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .location-option:hover,
    .location-option:focus-visible {
      transform: translateY(-4px);
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.4);
      outline: none;
      background: rgba(255, 255, 255, 0.18);
    }

    .location-option[aria-current='true'] {
      box-shadow: 0 0 0 3px rgba(126, 217, 87, 0.75);
      background: rgba(126, 217, 87, 0.18);
    }

    .location-option-preview {
      position: relative;
      width: 100%;
      padding-top: 66%;
      background-size: cover;
      background-position: center;
    }

    .location-option-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.9rem 1rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .location-option-name {
      flex: 1;
    }

    .location-option-badge {
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      background: rgba(250, 204, 21, 0.2);
      color: #facc15;
      font-size: 0.65rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    #clearButton {
      background: rgba(255, 116, 116, 0.9);
      color: #111;
    }

    #saveButton {
      background: #7ed957;
    }

    .appearance-save-button {
      background: #7ed957;
    }

    #deleteButton {
      background: rgba(255, 116, 116, 0.8);
      color: #111;
    }

    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
    }

    .controls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .auth-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.75);
      padding: 1.5rem;
      backdrop-filter: blur(2px);
      z-index: 20;
    }

    .auth-card {
      background: rgba(18, 18, 18, 0.95);
      border-radius: 1rem;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: min(90vw, 360px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
    }

    .auth-card h1 {
      font-size: 1.4rem;
      text-align: center;
    }

    .auth-field {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.95rem;
    }

    .auth-field input {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.35);
      color: #fff;
      padding: 0.65rem 1rem;
      font-size: 1rem;
    }

    .auth-submit {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1rem;
      background: #7ed957;
      color: #111;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.45rem;
    }

    .auth-submit:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
    }

    .auth-switch {
      font-size: 0.9rem;
      text-align: center;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      justify-content: center;
      align-items: center;
    }

    .auth-switch button {
      background: none;
      border: none;
      color: #7ed957;
      font-weight: 600;
      cursor: pointer;
      text-decoration: underline;
    }

    .auth-error {
      min-height: 1.25rem;
      color: #ff7a7a;
      text-align: center;
      font-size: 0.85rem;
    }

    .unauthorized {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      z-index: 30;
      padding: 2rem;
      text-align: center;
    }

    .unauthorized a {
      color: #7ed957;
      font-weight: 600;
      text-decoration: underline;
    }

    .status-message {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.55);
      padding: 0.75rem 1rem;
      border-radius: 0.85rem;
      min-width: min(320px, 92vw);
      max-width: min(360px, 92vw);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(6px);
      font-size: 0.85rem;
      letter-spacing: 0.01em;
      color: #e1e1e1;
    }

    .status-message[data-variant='success'] {
      color: #7ed957;
    }

    .status-message[data-variant='error'] {
      color: #ff7a7a;
    }

    .status-message[data-variant='info'] {
      color: #f1f1f1;
    }

    .status-message[data-variant='warning'] {
      color: #facc15;
    }

    .personal-dashboard-link {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 40;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      padding: 0;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(126, 217, 87, 0.95), rgba(126, 217, 87, 0.7));
      color: #0c1905;
      text-decoration: none;
      box-shadow: 0 14px 30px rgba(126, 217, 87, 0.35);
      border: 1px solid rgba(126, 217, 87, 0.75);
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
        border-color 0.2s ease;
    }

    .personal-dashboard-link svg {
      width: 22px;
      height: 22px;
      display: block;
    }

    .personal-dashboard-link:hover,
    .personal-dashboard-link:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 18px 36px rgba(126, 217, 87, 0.4);
      outline: none;
      border-color: rgba(126, 217, 87, 0.9);
      background: linear-gradient(135deg, rgba(126, 217, 87, 1), rgba(126, 217, 87, 0.82));
    }
  </style>
</head>
<body>
  <div id="authOverlay" class="auth-overlay" role="dialog" aria-modal="true" aria-labelledby="authTitle">
    <form id="authForm" class="auth-card">
      <h1 id="authTitle">Sign in to continue</h1>
      <label class="auth-field">
        <span>Username</span>
        <input id="authUsername" type="text" name="username" autocomplete="username" required />
      </label>
      <label class="auth-field">
        <span>Password</span>
        <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="6" required />
      </label>
      <p id="authError" class="auth-error" role="alert" aria-live="assertive"></p>
      <button type="submit" class="auth-submit">Sign In</button>
      <p class="auth-switch">
        <span id="authSwitchLabel">Don't have an account?</span>
        <button type="button" id="toggleAuthMode">Create one</button>
      </p>
    </form>
  </div>

  <div id="appContent" class="hidden">
    <a
      class="personal-dashboard-link"
      href="personal.html"
      aria-label="Open personal dashboard"
    >
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path
          d="M12 12a4 4 0 1 0-4-4 4 4 0 0 0 4 4Zm0 2c-4.41 0-8 2.24-8 5v1h16v-1c0-2.76-3.59-5-8-5Z"
          fill="currentColor"
        />
      </svg>
      <span class="sr-only">Open personal dashboard</span>
    </a>
    <div class="canvas-container">
      <canvas id="drawingCanvas"></canvas>
      <div class="focus-footer">
        <button
          id="clearFocusButton"
          class="clear-focus-button hidden"
          type="button"
          data-info-target="route-focus"
          aria-hidden="true"
        >
          Clear Focus
        </button>
      </div>
    </div>
    <div class="control-panel" data-expanded="true">
      <div id="panelSidebar" class="panel-sidebar">
        <div class="sidebar-actions">
          <button
            id="panelToggle"
            class="panel-icon-button panel-toggle-button"
            type="button"
            aria-pressed="false"
            aria-label="Hide menu"
            title="Hide menu"
          >
            <span class="panel-toggle-icon panel-toggle-icon-close" aria-hidden="true">
              <svg viewBox="0 0 24 24" focusable="false">
                <path
                  d="M6.34 6.34a1 1 0 0 1 1.32-.08l.1.08L12 10.59l4.24-4.25a1 1 0 0 1 1.5 1.32l-.08.1L13.41 12l4.25 4.24a1 1 0 0 1-1.32 1.5l-.1-.08L12 13.41l-4.24 4.25a1 1 0 0 1-1.5-1.32l.08-.1L10.59 12 6.34 7.76a1 1 0 0 1 0-1.42Z"
                  fill="currentColor"
                />
              </svg>
            </span>
            <span class="panel-toggle-icon panel-toggle-icon-open" aria-hidden="true">
              <svg viewBox="0 0 24 24" focusable="false">
                <path
                  d="M9.29 5.29a1 1 0 0 1 1.42 0l5 5a1 1 0 0 1 .08 1.32l-.08.1-5 5a1 1 0 0 1-1.5-1.32l.08-.1L13.59 12 9.3 7.7a1 1 0 0 1-.08-1.32Z"
                  fill="currentColor"
                />
              </svg>
            </span>
            <span class="sr-only">Hide menu</span>
          </button>
          <div class="info-wrapper">
            <button
              id="infoButton"
              class="panel-icon-button info-button"
              type="button"
              aria-label="Learn about setter tools"
              aria-haspopup="dialog"
              aria-pressed="false"
              aria-expanded="false"
              aria-controls="infoPopover"
              title="Learn about setter tools"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2" />
                <rect x="11" y="10" width="2" height="7" rx="1" />
                <circle cx="12" cy="7" r="1.5" />
              </svg>
              <span class="sr-only">Learn about setter tools</span>
            </button>
            <div
              id="infoPopover"
              class="info-popover hidden"
              role="dialog"
              aria-modal="false"
              aria-hidden="true"
              aria-label="About Ascend"
              tabindex="-1"
            >
              <p>Select any setter control to learn what it does.</p>
              <p>The next control you activate will show its tooltip and close this message.</p>
              <div class="info-popover-actions">
                <button id="startTutorialButton" class="info-popover-button" type="button">
                  Take the setter tour
                </button>
              </div>
            </div>
          </div>
          <button
            id="drawingToggle"
            class="panel-icon-button drawing-toggle"
            type="button"
            aria-pressed="false"
            aria-label="Enable drawing"
            title="Enable drawing"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M4 15.75V20h4.25l11.1-11.1a1 1 0 0 0 0-1.42L17.52 5.65a1 1 0 0 0-1.41 0L4 17.66Z"
                fill="currentColor"
              />
              <path d="m16.08 4.22 3.7 3.7 1.41-1.41a1 1 0 0 0 0-1.42l-2.28-2.28a1 1 0 0 0-1.42 0l-1.41 1.41Z" fill="currentColor" />
            </svg>
            <span class="sr-only">Enable drawing</span>
          </button>
        </div>
        <div
          id="panelTablist"
          class="panel-tablist"
          role="tablist"
          aria-orientation="vertical"
          aria-label="Setter controls"
        >
          <button
            id="routesTabButton"
            class="panel-icon-button panel-tab"
            type="button"
            role="tab"
            aria-selected="true"
            aria-controls="routesTab"
            data-target="routesTab"
            aria-label="Routes"
            title="Routes"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M6 19a3 3 0 0 1 0-6h12a2 2 0 0 0 0-4H8a4 4 0 0 1 0-8h10v2H8a2 2 0 0 0 0 4h10a4 4 0 0 1 0 8H6a1 1 0 0 0 0 2h12v2H6a3 3 0 0 1-3-3Z"
                fill="currentColor"
              />
            </svg>
            <span class="sr-only">Routes</span>
          </button>
          <button
            id="wallsTabButton"
            class="panel-icon-button panel-tab"
            type="button"
            role="tab"
            aria-selected="false"
            aria-controls="wallsTab"
            data-target="wallsTab"
            aria-label="Walls"
            title="Walls"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M12 2a7 7 0 0 1 7 7c0 4.42-4.56 9.52-6.38 11.34a0.88 0.88 0 0 1-1.24 0C9.56 18.52 5 13.42 5 9a7 7 0 0 1 7-7Zm0 4a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z"
                fill="currentColor"
              />
            </svg>
            <span class="sr-only">Walls</span>
          </button>
          <button
            id="configurationTabButton"
            class="panel-icon-button panel-tab"
            type="button"
            role="tab"
            aria-selected="false"
            aria-controls="configurationTab"
            data-target="configurationTab"
            aria-label="Configuration"
            title="Configuration"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M21.53 14.47 18 10.94V7.5a1 1 0 0 0-1-1h-3.44L11 3.94a2 2 0 0 0-2.83 0L7 5.12a1 1 0 0 0 0 1.41l2.83 2.83-6.72 6.72a2 2 0 0 0 0 2.83l1.41 1.41a2 2 0 0 0 2.83 0l6.72-6.72 2.83 2.83a1 1 0 0 0 1.41 0l1.18-1.18a2 2 0 0 0 .04-2.78Z"
                fill="currentColor"
              />
            </svg>
            <span class="sr-only">Configuration</span>
          </button>
        </div>
      </div>
      <div id="controlsPanel" class="controls">
        <div class="tab-panels">
          <div
            id="routesTab"
            class="tab-panel"
            role="tabpanel"
            aria-labelledby="routesTabButton"
            aria-hidden="false"
          >
            <div class="control-section">
              <label class="control-field" data-help-text="Select a saved route to edit or choose the new option to start fresh.">
                <span>Saved routes</span>
                <select id="routeSelector">
                  <option value="">Create new route…</option>
                </select>
              </label>
              <label class="control-field" data-help-text="Enter the setter name that should appear to climbers.">
                <span>Setter</span>
                <input id="routeSetterInput" type="text" placeholder="setter name" autocomplete="off" />
              </label>
              <label class="control-field" data-help-text="Provide a clear title that climbers will see in the list.">
                <span>Title</span>
                <input id="routeTitleInput" type="text" placeholder="Route title" autocomplete="off" />
              </label>
              <label class="control-field" data-help-text="Add beta notes or important information about the climb.">
                <span>Description</span>
                <textarea id="routeDescriptionInput" placeholder="Describe the climb"></textarea>
              </label>
              <label class="control-field" data-help-text="Record when the route was set to manage rotations.">
                <span>Date set</span>
                <input id="routeDateSetInput" type="datetime-local" />
              </label>
              <label
                class="control-toggle"
                data-help-text="Temporarily hide this route from the climber and personal pages without deleting it."
              >
                <span>Hide route from climbers</span>
                <input id="routeHiddenCheckbox" type="checkbox" role="switch" aria-checked="false" />
              </label>
            </div>
            <div class="control-section">
              <label class="control-field" data-help-text="Choose the colour used to draw this route on the wall preview.">
                <span>Stroke colour</span>
                <input type="color" id="colorPicker" value="#ffde59" />
              </label>
              <label class="control-field" data-help-text="Switch between freeform lines, hollow points, filled points, or rectangles while drawing.">
                <span>Path</span>
                <select id="pathTypeSelect">
                  <option value="brezer">Brezer</option>
                  <option value="hollow-point">Hollow point</option>
                  <option value="filled-point">Filled point</option>
                  <option value="rectangle">Rectangle</option>
                </select>
              </label>
              <button
                id="advancedColorToggle"
                class="color-wheel-toggle"
                type="button"
                aria-expanded="false"
                aria-controls="advancedColorPicker"
                data-help-text="Open the colour wheel to fine tune hue, saturation, and brightness."
              >
                Open colour wheel
              </button>
              <div
                id="advancedColorPicker"
                class="color-wheel hidden"
                aria-hidden="true"
                data-help-text="Drag in the wheel or adjust the slider to refine the stroke colour."
              >
                <div class="color-wheel-canvas-wrapper">
                  <canvas
                    id="colorWheelCanvas"
                    width="220"
                    height="220"
                    tabindex="0"
                    role="application"
                    aria-label="Colour wheel selector"
                    aria-describedby="colorWheelHint"
                  ></canvas>
                  <div id="colorWheelMarker" class="color-wheel-marker" aria-hidden="true"></div>
                </div>
                <p id="colorWheelHint" class="color-wheel-hint">
                  Drag on the wheel or use the arrow keys to adjust hue and saturation.
                </p>
                <div class="color-lightness-control" data-help-text="Use the slider to brighten or darken the selected colour.">
                  <label for="colorLightnessSlider">Lightness</label>
                  <input id="colorLightnessSlider" type="range" min="0" max="100" value="50" />
                </div>
                <div class="color-wheel-preview" aria-live="polite">
                  <div id="colorWheelSwatch" class="color-wheel-swatch" aria-hidden="true"></div>
                  <code id="colorWheelValue">#FFDE59</code>
                </div>
              </div>
              <button id="saveButton" type="button" data-help-text="Save the current drawing and route details.">Save route</button>
              <button id="deleteButton" type="button" data-help-text="Delete the selected route permanently.">Delete route</button>
              <button id="clearButton" type="button" data-help-text="Remove every drawn shape from the canvas.">Clear drawing</button>
            </div>
          </div>
          <div
            id="configurationTab"
            class="tab-panel"
            role="tabpanel"
            aria-labelledby="configurationTabButton"
            aria-hidden="true"
          >
            <div class="control-section">
              <h3 class="control-section-title">Appearance</h3>
              <label
                id="hollowPointDiameterField"
                class="control-field"
                data-help-text="Set the diameter for hollow point holds drawn on this wall."
              >
                <span>
                  Hollow point diameter
                  <span id="hollowPointDiameterValue"></span>
                </span>
                <input
                  id="hollowPointDiameterSlider"
                  type="range"
                  min="12"
                  max="160"
                  step="1"
                  value="48"
                />
              </label>
              <label
                id="filledPointDiameterField"
                class="control-field"
                data-help-text="Set the diameter for filled point holds drawn on this wall."
              >
                <span>
                  Filled point diameter
                  <span id="filledPointDiameterValue"></span>
                </span>
                <input
                  id="filledPointDiameterSlider"
                  type="range"
                  min="12"
                  max="160"
                  step="1"
                  value="48"
                />
              </label>
              <label
                id="rectangleWidthField"
                class="control-field"
                data-help-text="Adjust the width of rectangle holds when using the rectangle path."
              >
                <span>
                  Rectangle width
                  <span id="rectangleWidthValue"></span>
                </span>
                <input
                  id="rectangleWidthSlider"
                  type="range"
                  min="12"
                  max="200"
                  step="1"
                  value="80"
                />
              </label>
              <label
                id="rectangleHeightField"
                class="control-field"
                data-help-text="Adjust the height of rectangle holds when using the rectangle path."
              >
                <span>
                  Rectangle height
                  <span id="rectangleHeightValue"></span>
                </span>
                <input
                  id="rectangleHeightSlider"
                  type="range"
                  min="12"
                  max="200"
                  step="1"
                  value="60"
                />
              </label>
              <label
                id="brezerStrokeWidthField"
                class="control-field"
                data-help-text="Set the thickness of Brezer lines for freeform paths on this wall."
              >
                <span>
                  Brezer stroke width
                  <span id="brezerStrokeWidthValue"></span>
                </span>
                <input
                  id="brezerStrokeWidthSlider"
                  type="range"
                  min="2"
                  max="40"
                  step="1"
                  value="10"
                />
              </label>
              <label
                id="unfocusedTransparencyField"
                class="control-field"
                data-help-text="Control how transparent inactive routes appear for climbers."
              >
                <span>Unfocused transparency</span>
                <input
                  id="unfocusedTransparencySlider"
                  type="range"
                  min="0"
                  max="100"
                  step="5"
                  value="25"
                />
              </label>
              <button
                id="saveAppearanceButton"
                class="appearance-save-button"
                type="button"
                data-help-text="Save these appearance defaults for the current wall."
              >
                Save Appearance
              </button>
            </div>
            <div class="control-section">
              <h3 class="control-section-title">Session actions</h3>
              <div class="global-actions">
                <button
                  id="climberViewButton"
                  class="global-action-button"
                  type="button"
                  data-help-text="Open the climber preview using the active wall."
                >
                  <span class="button-label">Climber View</span>
                </button>
                <button
                  id="personalDashboardButton"
                  class="global-action-button"
                  type="button"
                  data-help-text="Jump to your personal dashboard to review ascents and progress."
                >
                  <span class="button-label">Personal Dashboard</span>
                </button>
                <button
                  id="adminConsoleButton"
                  class="global-action-button"
                  type="button"
                  data-help-text="Open the admin console for database management."
                >
                  <span class="button-icon" aria-hidden="true">🛡️</span>
                  <span class="button-label">Admin</span>
                </button>
                <button
                  id="signOutButton"
                  class="global-action-button"
                  type="button"
                  data-help-text="Sign out of the setter tools."
                >
                  <span class="button-icon" aria-hidden="true">🚪</span>
                  <span class="button-label">Sign Out</span>
                </button>
              </div>
              <p
                id="adminConsoleStatus"
                class="status-message hidden"
                role="status"
                aria-live="polite"
              ></p>
            </div>
          </div>
          <div
            id="wallsTab"
            class="tab-panel"
            role="tabpanel"
            aria-labelledby="wallsTabButton"
            aria-hidden="true"
          >
            <div class="control-section">
              <h3 class="control-section-title">Select wall</h3>
              <div class="global-actions">
                <button
                  id="locationButton"
                  class="global-action-button"
                  type="button"
                  aria-haspopup="dialog"
                  aria-expanded="false"
                  data-help-text="Open the wall picker to switch backgrounds."
                >
                  <span class="button-icon" aria-hidden="true">📍</span>
                  <span class="button-label">Select wall</span>
                </button>
              </div>
              <label
                id="wallVisibilityToggleWrapper"
                class="control-toggle"
                data-help-text="Hide this wall from climber-facing pages so only setters can access it."
              >
                <span>Hide wall from climbers</span>
                <input id="wallVisibilityToggle" type="checkbox" role="switch" aria-checked="false" />
              </label>
            </div>
            <div class="control-section">
              <h3 class="control-section-title">Create new wall</h3>
              <label class="control-field" data-help-text="Name shown in the wall selector for setters and climbers.">
                <span>Wall name</span>
                <input id="newWallNameInput" type="text" placeholder="e.g. Cave Wall" autocomplete="off" />
              </label>
              <label class="control-field" data-help-text="Provide an image path or URL for the wall background.">
                <span>Background image URL</span>
                <input
                  id="newWallImageInput"
                  type="text"
                  placeholder="./location/cave-wall.jpg"
                  autocomplete="off"
                />
              </label>
              <button
                id="createWallButton"
                class="location-button"
                type="button"
                data-help-text="Create a wall using the name and background above."
              >
                <span class="button-icon" aria-hidden="true">📍</span>
                <span class="button-label">Create wall</span>
              </button>
              <button
                id="deleteWallButton"
                class="location-button delete-wall-button"
                type="button"
                data-help-text="Remove the currently selected wall."
              >
                Delete Wall
              </button>
              <p
                id="createWallStatus"
                class="status-message hidden"
                role="status"
                aria-live="polite"
              ></p>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div id="unauthorizedNotice" class="unauthorized hidden" role="alert">
    <p><strong>Access denied.</strong> Your account does not have permission to use the setter tools.</p>
    <p>You can return to the <a id="previewLink" href="index.html">preview page</a> or contact a setter for help.</p>
    <button id="unauthorizedSignOut" class="auth-submit" type="button">
      <span class="button-icon" aria-hidden="true">🚪</span>
      <span class="button-label">Sign Out</span>
    </button>
  </div>

  <p id="routeStatus" class="status-message hidden" role="status" aria-live="polite"></p>

  <div
    id="locationModal"
    class="location-modal hidden"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="locationModalTitle"
  >
    <div class="location-modal-content">
      <div class="location-modal-header">
        <h2 id="locationModalTitle" class="location-modal-title">Select a wall</h2>
        <button id="locationModalClose" class="location-modal-close" type="button" aria-label="Close wall selector">
          ×
        </button>
      </div>
      <div id="locationOptions" class="location-options" role="listbox"></div>
    </div>
  </div>

  <div
    id="tutorialOverlay"
    class="tutorial-overlay hidden"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="tutorialTitle"
    aria-describedby="tutorialDescription"
    data-tutorial-exempt="true"
  >
    <div id="tutorialDialogCard" class="tutorial-card" role="document" tabindex="-1">
      <div id="tutorialProgress" class="tutorial-progress hidden" aria-live="polite"></div>
      <h2 id="tutorialTitle" class="tutorial-title"></h2>
      <div id="tutorialDescription" class="tutorial-description"></div>
      <div class="tutorial-actions">
        <button
          id="tutorialSecondaryAction"
          class="tutorial-button tutorial-secondary hidden"
          type="button"
          data-tutorial-exempt="true"
        >
          Back
        </button>
        <button
          id="tutorialPrimaryAction"
          class="tutorial-button tutorial-primary"
          type="button"
          data-tutorial-exempt="true"
        >
          Next
        </button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
    import {
      getAuth,
      onAuthStateChanged,
      signInWithEmailAndPassword,
      createUserWithEmailAndPassword,
      signOut,
      updateProfile,
      deleteUser,
    } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
    import {
      getFirestore,
      doc,
      getDoc,
      setDoc,
      serverTimestamp,
      collection,
      getDocs,
      query,
      limit,
      where,
      deleteDoc,
      deleteField,
      Timestamp,
    } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
    import { firebaseConfig } from './config.js';

    const firebaseApp = initializeApp(firebaseConfig);
    const auth = getAuth(firebaseApp);
    const db = getFirestore(firebaseApp);

    const authOverlay = document.getElementById('authOverlay');
    const appContent = document.getElementById('appContent');
    const canvasContainer = document.querySelector('.canvas-container');
    const canvas = document.getElementById('drawingCanvas');
    const clearFocusButton = document.getElementById('clearFocusButton');
    const authForm = document.getElementById('authForm');
    const authUsername = document.getElementById('authUsername');
    const authPassword = document.getElementById('authPassword');
    const authError = document.getElementById('authError');
    const authTitle = document.getElementById('authTitle');
    const authSwitchLabel = document.getElementById('authSwitchLabel');
    const toggleAuthModeButton = document.getElementById('toggleAuthMode');
    const signOutButton = document.getElementById('signOutButton');
    const unauthorizedSignOut = document.getElementById('unauthorizedSignOut');
    const unauthorizedNotice = document.getElementById('unauthorizedNotice');
    const routeSelector = document.getElementById('routeSelector');
    const routeSetterInput = document.getElementById('routeSetterInput');
    const routeTitleInput = document.getElementById('routeTitleInput');
    const routeDescriptionInput = document.getElementById('routeDescriptionInput');
    const routeDateSetInput = document.getElementById('routeDateSetInput');
    const deleteButton = document.getElementById('deleteButton');
    const routeStatus = document.getElementById('routeStatus');
    const routeHiddenCheckbox = document.getElementById('routeHiddenCheckbox');
    const controlPanel = document.querySelector('.control-panel');
    const drawingToggle = document.getElementById('drawingToggle');
    const panelSidebar = document.getElementById('panelSidebar');
    const panelToggleButton = document.getElementById('panelToggle');
    const infoButton = document.getElementById('infoButton');
    const infoPopover = document.getElementById('infoPopover');
    const startTutorialButton = document.getElementById('startTutorialButton');
    const climberViewButton = document.getElementById('climberViewButton');
    const personalDashboardButton = document.getElementById('personalDashboardButton');
    const adminConsoleButton = document.getElementById('adminConsoleButton');
    const adminConsoleStatus = document.getElementById('adminConsoleStatus');
    const previewLink = document.getElementById('previewLink');
    const previewLinkBaseHref = previewLink?.getAttribute('href') || 'index.html';
    const climberViewBaseHref = 'index.html';
    let climberViewTargetHref = climberViewBaseHref;

    async function signOutAndRedirectToIndex() {
      try {
        await signOut(auth);
      } catch (error) {
        console.error('Failed to sign out:', error);
        return false;
      }

      window.location.href = 'index.html';
      return true;
    }
    const locationButton = document.getElementById('locationButton');
    const locationButtonLabel = locationButton?.querySelector('.button-label');
    const locationModal = document.getElementById('locationModal');
    const locationOptions = document.getElementById('locationOptions');
    const locationModalClose = document.getElementById('locationModalClose');
    const routesTabButton = document.getElementById('routesTabButton');
    const wallsTabButton = document.getElementById('wallsTabButton');
    const configurationTabButton = document.getElementById('configurationTabButton');
    const tabButtons = [routesTabButton, wallsTabButton, configurationTabButton].filter(Boolean);
    const tabPanels = {
      routesTab: document.getElementById('routesTab'),
      wallsTab: document.getElementById('wallsTab'),
      configurationTab: document.getElementById('configurationTab'),
    };
    const newWallNameInput = document.getElementById('newWallNameInput');
    const newWallImageInput = document.getElementById('newWallImageInput');
    const createWallButton = document.getElementById('createWallButton');
    const deleteWallButton = document.getElementById('deleteWallButton');
    const createWallStatus = document.getElementById('createWallStatus');
    const wallVisibilityToggleWrapper = document.getElementById('wallVisibilityToggleWrapper');
    const wallVisibilityToggle = document.getElementById('wallVisibilityToggle');
    const tutorialOverlay = document.getElementById('tutorialOverlay');
    const tutorialDialogCard = document.getElementById('tutorialDialogCard');
    const tutorialTitle = document.getElementById('tutorialTitle');
    const tutorialDescription = document.getElementById('tutorialDescription');
    const tutorialPrimaryAction = document.getElementById('tutorialPrimaryAction');
    const tutorialSecondaryAction = document.getElementById('tutorialSecondaryAction');
    const tutorialProgress = document.getElementById('tutorialProgress');

    let isUpdatingWallVisibility = false;
    let tutorialPointer = null;
    let tutorialPointerTarget = null;
    let tutorialHighlightedElement = null;
    let tutorialHighlightedElementOptions = { illuminate: false };
    let tutorialPreviousFocus = null;
    let tutorialActive = false;
    let tutorialTransitionInProgress = false;
    let tutorialStepIndex = -1;
    let tutorialSteps = [];
    let tutorialPreviousTabId = null;
    let tutorialSecondaryActionMode = 'back';
    let tutorialAutostartTimeoutId = null;
    let tutorialAutostartAttempts = 0;

    const LOCATIONS = [
      { key: 'new-wall', name: 'New Wall', image: './location/New Wall.jpg', hidden: false },
      { key: 'old-wall', name: 'Old Wall', image: './location/Old Wall.jpg', hidden: false },
    ];

    const LOCATION_STORAGE_KEY = 'ascend.selectedWall';
    const WALL_QUERY_PARAM = 'wall';

    const PATH_TYPE_BREZER = 'brezer';
    const PATH_TYPE_HOLLOW_POINT = 'hollow-point';
    const PATH_TYPE_FILLED_POINT = 'filled-point';
    const PATH_TYPE_RECTANGLE = 'rectangle';
    const LEGACY_PATH_TYPE_POINT = 'point';
    const DEFAULT_PATH_TYPE = PATH_TYPE_BREZER;
    const BREZER_REMOVAL_RADIUS = 20;
    const MIN_POINT_DIAMETER = 12;
    const MAX_POINT_DIAMETER = 160;
    const DEFAULT_HOLLOW_POINT_DIAMETER = 48;
    const DEFAULT_FILLED_POINT_DIAMETER = 48;
    const DEFAULT_POINT_DIAMETER = DEFAULT_HOLLOW_POINT_DIAMETER;
    const MIN_RECTANGLE_SIZE = 12;
    const MAX_RECTANGLE_SIZE = 200;
    const DEFAULT_RECTANGLE_WIDTH = 80;
    const DEFAULT_RECTANGLE_HEIGHT = 60;
    const MIN_BREZER_STROKE_WIDTH = 2;
    const MAX_BREZER_STROKE_WIDTH = 40;
    const DEFAULT_BREZER_STROKE_WIDTH = 10;
    const MIN_UNFOCUSED_TRANSPARENCY = 0;
    const MAX_UNFOCUSED_TRANSPARENCY = 1;
    const DEFAULT_UNFOCUSED_TRANSPARENCY = 0.25;
    const MIN_GRADE_VALUE = 5;
    const MAX_GRADE_VALUE = 30;
    const MIN_GRADE_BAR_BASE_HEIGHT = 0;
    const MAX_GRADE_BAR_HEIGHT = 1000;
    const DEFAULT_GRADE_BAR_BASE_HEIGHT = 40;
    const DEFAULT_GRADE_BAR_MAX_HEIGHT = 220;
    const MIN_GRADE_BAR_WIDTH = 4;
    const MAX_GRADE_BAR_WIDTH = 160;
    const DEFAULT_GRADE_BAR_WIDTH = 24;
    const DEFAULT_GRADE_BAR_TRANSPARENCY = 0.85;
    const WALL_COLLECTION = 'walls';

    const normalizeLocationName = (value) => {
      if (typeof value !== 'string') {
        return '';
      }
      return value.trim().toLowerCase();
    };

    const normalizeWallKey = (value) => normalizeLocationName(value);

    const BUILTIN_LOCATION_KEYS = new Set(
      LOCATIONS.map((location) => normalizeWallKey(location?.key || location?.name)).filter(Boolean),
    );

    const findLocationByKey = (key) => LOCATIONS.find((location) => location.key === key);

    const findLocationByName = (name) => {
      const normalized = normalizeLocationName(name);
      return (
        LOCATIONS.find((location) => normalizeLocationName(location.name) === normalized) || null
      );
    };

    function buildWallAwareHref(baseHref, wallKey) {
      const normalizedKey = normalizeWallKey(wallKey);
      if (typeof baseHref !== 'string' || !baseHref) {
        return '';
      }

      try {
        const url = new URL(baseHref, window.location.origin);
        if (normalizedKey) {
          url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
        } else {
          url.searchParams.delete(WALL_QUERY_PARAM);
        }
        url.hash = '';
        const relativePath = `${url.pathname.replace(/^\//, '')}${url.search}`;
        return relativePath || baseHref;
      } catch (error) {
        if (!normalizedKey) {
          return baseHref;
        }

        const separator = baseHref.includes('?') ? '&' : '?';
        return `${baseHref}${separator}${encodeURIComponent(WALL_QUERY_PARAM)}=${encodeURIComponent(normalizedKey)}`;
      }
    }

    function getWallKeyFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search);
        const raw = params.get(WALL_QUERY_PARAM);
        return normalizeWallKey(raw);
      } catch (error) {
        console.warn('Unable to read wall from query string:', error);
        return '';
      }
    }

    function updateWallQueryParam(wallKey) {
      try {
        const normalizedKey = normalizeWallKey(wallKey);
        const url = new URL(window.location.href);
        if (normalizedKey) {
          url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
        } else {
          url.searchParams.delete(WALL_QUERY_PARAM);
        }
        url.hash = '';
        const next = url.toString();
        if (next !== window.location.href) {
          window.history.replaceState({}, '', next);
        }
      } catch (error) {
        console.warn('Unable to update wall query parameter:', error);
      }
    }

    function persistSelectedWall(wallKey) {
      const normalizedKey = normalizeWallKey(wallKey);
      try {
        if (normalizedKey) {
          window.localStorage?.setItem(LOCATION_STORAGE_KEY, normalizedKey);
        } else {
          window.localStorage?.removeItem(LOCATION_STORAGE_KEY);
        }
      } catch (error) {
        console.warn('Unable to persist setter location preference:', error);
      }
    }

    function updateWallNavigationTargets(wallKey) {
      const normalizedKey = normalizeWallKey(wallKey);
      if (previewLink) {
        previewLink.href = buildWallAwareHref(previewLinkBaseHref, normalizedKey);
      }

      const computedClimberHref = buildWallAwareHref(climberViewBaseHref, normalizedKey);
      climberViewTargetHref = computedClimberHref;
      if (climberViewButton) {
        climberViewButton.setAttribute('data-target-href', computedClimberHref);
      }
    }

    function upsertLocation({
      key = '',
      name = '',
      image = '',
      fallbackName = '',
      hidden = false,
    } = {}) {
      const trimmedName = typeof name === 'string' && name.trim() ? name.trim() : '';
      const fallback =
        trimmedName || (typeof fallbackName === 'string' && fallbackName.trim() ? fallbackName.trim() : '');
      const keySource = typeof key === 'string' && key.trim() ? key.trim() : fallback;
      const normalizedKey = normalizeWallKey(keySource);
      const displayName = fallback;
      if (!normalizedKey || !displayName) {
        return { entry: null, changed: false };
      }

      const normalizedImage = typeof image === 'string' ? image.trim() : '';
      const normalizedHidden = Boolean(hidden);
      const existingIndex = LOCATIONS.findIndex((location) => {
        if (!location) {
          return false;
        }
        if (location.key === normalizedKey) {
          return true;
        }
        return normalizeLocationName(location.name) === normalizeLocationName(displayName);
      });

      if (existingIndex >= 0) {
        const existing = LOCATIONS[existingIndex];
        const needsUpdate =
          existing.key !== normalizedKey ||
          existing.name !== displayName ||
          existing.image !== normalizedImage ||
          Boolean(existing.hidden) !== normalizedHidden;

        if (!needsUpdate) {
          return { entry: existing, changed: false };
        }

        const updated = {
          ...existing,
          key: normalizedKey,
          name: displayName,
          image: normalizedImage,
          hidden: normalizedHidden,
        };
        LOCATIONS[existingIndex] = updated;
        return { entry: updated, changed: true };
      }

      const created = {
        key: normalizedKey,
        name: displayName,
        image: normalizedImage,
        hidden: normalizedHidden,
      };
      LOCATIONS.push(created);
      return { entry: created, changed: true };
    }

    function synchronizeCurrentLocationReference() {
      if (!currentLocation) {
        return;
      }

      const normalizedKey = normalizeWallKey(currentLocation.key || currentLocation.name);
      const refreshed =
        (normalizedKey && findLocationByKey(normalizedKey)) ||
        findLocationByName(currentLocation.name);

      if (refreshed && refreshed !== currentLocation) {
        currentLocation = refreshed;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();
        const activeKey = getCurrentLocationKey();
        updateWallNavigationTargets(activeKey);
        updateWallQueryParam(activeKey);
        persistSelectedWall(activeKey);
      }

      updateWallVisibilityControls();
    }

    const DEFAULT_LOCATION = LOCATIONS[0];

    let currentLocation = DEFAULT_LOCATION;
    let backgroundImageSource = '';
    let backgroundReady = false;

    const wallSettingsCache = new Map();
    const wallDocumentIdMap = new Map();

    const backgroundImage = new Image();

    const updateLocationButtonLabel = () => {
      const baseName = currentLocation?.name || 'Select wall';
      const suffix = currentLocation?.hidden ? ' (Hidden)' : '';
      const labelText = `${baseName}${suffix}`;
      if (locationButtonLabel) {
        locationButtonLabel.textContent = labelText;
      }
      if (locationButton) {
        locationButton.setAttribute('aria-label', `Select wall: ${labelText}`);
        locationButton.setAttribute('title', labelText);
      }
    };

    const updateLocationOptionsState = () => {
      if (!locationOptions) {
        return;
      }

      const buttons = locationOptions.querySelectorAll('[data-location-key]');
      buttons.forEach((button) => {
        const key = button?.dataset?.locationKey;
        if (key && currentLocation && key === currentLocation.key) {
          button.setAttribute('aria-current', 'true');
        } else {
          button.removeAttribute('aria-current');
        }
      });
    };

    const updateDeleteWallButtonState = () => {
      if (!deleteWallButton) {
        return;
      }

      if (isDeletingWall) {
        deleteWallButton.disabled = true;
        return;
      }

      const activeKey = getCurrentLocationKey();
      const normalizedActiveKey = normalizeWallKey(activeKey);
      const hasAlternativeWall = LOCATIONS.some((location) => {
        if (!location) {
          return false;
        }
        const candidateKey = normalizeWallKey(location.key || location.name);
        return candidateKey && candidateKey !== normalizedActiveKey;
      });

      deleteWallButton.disabled = !normalizedActiveKey || !hasAlternativeWall;
    };

    function updateLocationHiddenFlag(locationKey, hidden) {
      const normalizedKey = normalizeWallKey(locationKey);
      if (!normalizedKey) {
        return;
      }

      LOCATIONS.forEach((location) => {
        if (!location) {
          return;
        }
        const candidateKey = normalizeWallKey(location.key || location.name);
        if (candidateKey === normalizedKey) {
          location.hidden = hidden;
        }
      });

      if (currentLocation) {
        const currentKey = normalizeWallKey(currentLocation.key || currentLocation.name);
        if (currentKey === normalizedKey) {
          currentLocation.hidden = hidden;
        }
      }
    }

    const updateWallVisibilityControls = () => {
      if (!wallVisibilityToggle) {
        return;
      }

      const isHidden = Boolean(currentLocation?.hidden);
      wallVisibilityToggle.checked = isHidden;
      wallVisibilityToggle.setAttribute('aria-checked', isHidden ? 'true' : 'false');

      const disabled = !currentLocation || isUpdatingWallVisibility;
      wallVisibilityToggle.disabled = disabled;
      wallVisibilityToggle.setAttribute('aria-disabled', disabled ? 'true' : 'false');

      if (wallVisibilityToggleWrapper) {
        wallVisibilityToggleWrapper.classList.toggle('is-disabled', disabled);
      }
    };

    async function applyWallVisibilityChange(nextHidden) {
      const locationKey = getCurrentLocationKey();
      if (!locationKey || !currentLocation) {
        updateWallVisibilityControls();
        return;
      }

      const normalizedNext = Boolean(nextHidden);
      const previousHidden = Boolean(currentLocation.hidden);
      if (normalizedNext === previousHidden) {
        updateWallVisibilityControls();
        return;
      }

      isUpdatingWallVisibility = true;
      updateWallVisibilityControls();

      updateLocationHiddenFlag(locationKey, normalizedNext);
      updateLocationButtonLabel();
      renderLocationOptions();
      updateLocationOptionsState();
      updateWallVisibilityControls();

      try {
        const locationDetails =
          findLocationByKey(locationKey) ||
          findLocationByName(currentLocation.name) ||
          currentLocation;

        const wallPayload = {
          hidden: normalizedNext,
          updatedAt: serverTimestamp(),
          key: locationKey,
        };

        if (locationDetails?.name) {
          wallPayload.name = locationDetails.name;
        }

        if (locationDetails?.image) {
          wallPayload.background_url = locationDetails.image;
        }

        const docId = wallDocumentIdMap.get(locationKey) || locationKey;
        await setDoc(doc(db, WALL_COLLECTION, docId), wallPayload, { merge: true });

        setStatus(
          normalizedNext ? 'Wall hidden from climbers.' : 'Wall visible to climbers.',
          'success',
        );
      } catch (error) {
        console.error('Failed to update wall visibility:', error);
        setStatus('Failed to update wall visibility. Please try again.', 'error');

        updateLocationHiddenFlag(locationKey, previousHidden);
        if (wallVisibilityToggle) {
          wallVisibilityToggle.checked = previousHidden;
          wallVisibilityToggle.setAttribute('aria-checked', previousHidden ? 'true' : 'false');
        }
        updateLocationButtonLabel();
        renderLocationOptions();
        updateLocationOptionsState();
      } finally {
        isUpdatingWallVisibility = false;
        updateWallVisibilityControls();
      }
    }

    const applyBodyBackground = (imagePath) => {
      if (!document.body) {
        return;
      }

      if (imagePath) {
        document.body.style.setProperty('--wall-background', `url('${imagePath}')`);
      } else {
        document.body.style.removeProperty('--wall-background');
      }
    };

    function activateTab(targetId) {
      if (!targetId) {
        return;
      }

      tabButtons.forEach((button) => {
        if (!button) {
          return;
        }
        const isActive = button.dataset?.target === targetId;
        button.setAttribute('aria-selected', String(isActive));
        button.tabIndex = isActive ? 0 : -1;
      });

      Object.values(tabPanels).forEach((panel) => {
        if (!panel) {
          return;
        }
        const isActive = panel.id === targetId;
        panel.setAttribute('aria-hidden', isActive ? 'false' : 'true');
      });

      updateHelpTooltips();
    }

    const updateBackgroundForCurrentLocation = () => {
      const imagePath = currentLocation?.image || '';
      applyBodyBackground(imagePath);

      if (imagePath && imagePath !== backgroundImageSource) {
        backgroundImageSource = imagePath;
        backgroundReady = false;
        backgroundImage.src = imagePath;
      } else if (!imagePath) {
        backgroundImageSource = '';
        backgroundReady = false;
      }
    };

    const closeLocationModal = () => {
      if (!locationModal) {
        return;
      }

      if (!locationModal.classList.contains('hidden')) {
        locationModal.classList.add('hidden');
        locationModal.setAttribute('aria-hidden', 'true');
        locationButton?.setAttribute('aria-expanded', 'false');
        updateHelpTooltips();
      }
    };

    const openLocationModal = () => {
      if (!locationModal) {
        return;
      }

      locationModal.classList.remove('hidden');
      locationModal.setAttribute('aria-hidden', 'false');
      locationButton?.setAttribute('aria-expanded', 'true');
      registerHelpTargets(locationModal);
      updateHelpTooltips();
      updateLocationOptionsState();
    };

    const setLocation = (
      location,
      { persist = true, refreshRoutes = true, wallFallback = null } = {},
    ) => {
      const targetLocation = location || DEFAULT_LOCATION;
      if (!targetLocation) {
        return;
      }

      const { entry: canonicalLocation, changed: locationEntryChanged } = upsertLocation({
        key: typeof targetLocation?.key === 'string' ? targetLocation.key : '',
        name: typeof targetLocation?.name === 'string' ? targetLocation.name : '',
        image: typeof targetLocation?.image === 'string' ? targetLocation.image : '',
        fallbackName: typeof targetLocation?.name === 'string' ? targetLocation.name : '',
        hidden: Boolean(targetLocation?.hidden),
      });

      if (!canonicalLocation) {
        return;
      }

      if (locationEntryChanged) {
        renderLocationOptions();
      }

      const previousKey = getCurrentLocationKey();
      const nextKey = normalizeWallKey(canonicalLocation.key || canonicalLocation.name);
      const changed = previousKey !== nextKey;

      currentLocation = canonicalLocation;
      clearRouteFocus();
      updateWallVisibilityControls();
      updateLocationButtonLabel();
      updateLocationOptionsState();
      updateBackgroundForCurrentLocation();
      updateDeleteWallButtonState();

      if (locationEntryChanged) {
        synchronizeCurrentLocationReference();
      }

      applyWallSettingsToStateForLocationKey(nextKey, wallFallback);
      redraw();

      updateWallNavigationTargets(nextKey);
      updateWallQueryParam(nextKey);

      if (persist) {
        persistSelectedWall(nextKey);
      }

      if (changed) {
        ensureWallSettings(nextKey)
          .then(() => {
            if (getCurrentLocationKey() !== nextKey) {
              return;
            }
            const wallSettings = getWallSettingsForLocation(nextKey);
            updateRoutesForWall(nextKey, wallSettings);
            pointDiameter = wallSettings.hollowPointDiameter ?? wallSettings.pointDiameter;
            filledPointDiameter = wallSettings.filledPointDiameter ?? wallSettings.pointDiameter;
            brezerStrokeWidth = wallSettings.brezerStrokeWidth;
            unfocusedTransparency = wallSettings.unfocusedTransparency;
            gradeBarBaseHeight = wallSettings.gradeBarBaseHeight;
            gradeBarMaxHeight = wallSettings.gradeBarMaxHeight;
            gradeBarWidth = wallSettings.gradeBarWidth;
            gradeBarTransparency = wallSettings.gradeBarTransparency;
            updatePathControls();
            updateAppearanceControls();
            redraw();
          })
          .catch((error) => {
            console.warn('Failed to load wall settings:', error);
          });
      }

      if (changed && refreshRoutes) {
        prepareNewRoute();
        loadRoutesList('').catch((error) => {
          console.error('Failed to refresh routes for the selected location:', error);
        });
      }
    };

    const handleLocationSelection = (locationKey) => {
      const nextLocation = findLocationByKey(locationKey);
      if (!nextLocation) {
        return;
      }

      setLocation(nextLocation);
      closeLocationModal();
    };

    const renderLocationOptions = () => {
      if (!locationOptions) {
        return;
      }

      locationOptions.replaceChildren();

      LOCATIONS.forEach((location) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'location-option';
        button.dataset.locationKey = location.key;
        button.setAttribute('role', 'option');
        button.dataset.helpText = `Switch to ${location.name}`;

        const preview = document.createElement('div');
        preview.className = 'location-option-preview';
        preview.style.backgroundImage = `url('${location.image}')`;
        button.appendChild(preview);

        const label = document.createElement('span');
        label.className = 'location-option-label';
        const name = document.createElement('span');
        name.className = 'location-option-name';
        name.textContent = location.name;
        label.appendChild(name);

        if (location.hidden) {
          const badge = document.createElement('span');
          badge.className = 'location-option-badge';
          badge.textContent = 'Hidden';
          label.appendChild(badge);
        }
        button.appendChild(label);

        button.addEventListener('click', () => {
          handleLocationSelection(location.key);
        });

        locationOptions.appendChild(button);
      });

      registerHelpTargets(locationOptions);
      updateHelpTooltips();

      updateLocationOptionsState();
      updateDeleteWallButtonState();
    };

    function resetLocationsToBuiltins() {
      for (let index = LOCATIONS.length - 1; index >= 0; index -= 1) {
        const entry = LOCATIONS[index];
        if (!entry) {
          continue;
        }

        const normalizedKey = normalizeWallKey(entry.key || entry.name);
        if (!BUILTIN_LOCATION_KEYS.has(normalizedKey)) {
          LOCATIONS.splice(index, 1);
        }
      }

      renderLocationOptions();

      const currentKey = normalizeWallKey(currentLocation?.key || currentLocation?.name);
      if (!currentKey || !BUILTIN_LOCATION_KEYS.has(currentKey)) {
        setLocation(DEFAULT_LOCATION, { persist: true, refreshRoutes: false });
      } else {
        synchronizeCurrentLocationReference();
        updateLocationOptionsState();
      }

      updateDeleteWallButtonState();
    }

    backgroundImage.onload = () => {
      backgroundReady = true;
      if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
        const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
        if (Number.isFinite(ratio) && ratio > 0) {
          canvasAspectRatio = ratio;
        }
      }
      resizeCanvas();
    };

    backgroundImage.onerror = () => {
      backgroundReady = false;
      resizeCanvas();
    };

    const updatePanelMeasurements = () => {
      if (!controlPanel || !panelSidebar) {
        return;
      }

      const { width } = panelSidebar.getBoundingClientRect();
      if (Number.isFinite(width) && width > 0) {
        controlPanel.style.setProperty('--toggle-visible-width', `${Math.ceil(width)}px`);
      }

      let panelOffset = 0;
      if (controlPanel) {
        const panelRect = controlPanel.getBoundingClientRect();
        if (Number.isFinite(panelRect.width) && panelRect.width > 0) {
          panelOffset = Math.ceil(panelRect.width);
        }

        const isExpanded = controlPanel.getAttribute('data-expanded') !== 'false';
        if (!isExpanded) {
          const storedToggleWidth =
            controlPanel.style.getPropertyValue('--toggle-visible-width') ||
            window.getComputedStyle(controlPanel).getPropertyValue('--toggle-visible-width');
          const parsedToggleWidth = storedToggleWidth ? parseFloat(storedToggleWidth) : NaN;
          if (Number.isFinite(parsedToggleWidth) && parsedToggleWidth > 0) {
            panelOffset = Math.ceil(parsedToggleWidth);
          }
        }
      }

    };

    const updateDrawingToggle = () => {
      if (!drawingToggle) {
        return;
      }

      const label = isDrawingEnabled ? 'Disable drawing' : 'Enable drawing';
      drawingToggle.setAttribute('aria-pressed', String(isDrawingEnabled));
      const labelTarget = drawingToggle.querySelector('.sr-only');
      if (labelTarget) {
        labelTarget.textContent = label;
      }
      drawingToggle.setAttribute('aria-label', label);
      drawingToggle.setAttribute('title', label);

      if (canvas) {
        canvas.setAttribute('data-drawing-enabled', String(isDrawingEnabled));
      }
    };

    function setDrawingEnabled(value) {
      const next = Boolean(value);
      if (isDrawingEnabled === next) {
        return;
      }
      isDrawingEnabled = next;
      updateDrawingToggle();
    }

    function registerHelpTargets(root = document) {
      if (!root || typeof root.querySelectorAll !== 'function') {
        return;
      }

      const directMatch =
        root instanceof Element && root.matches('[data-help-text]') ? [root] : [];
      const candidates = [...directMatch, ...root.querySelectorAll('[data-help-text]')];
      candidates.forEach((element) => {
        if (helpTargets.has(element)) {
          return;
        }
        if (infoButton && infoButton.contains(element)) {
          return;
        }
        const text = element.dataset?.helpText;
        if (!text) {
          return;
        }
        const tooltip = document.createElement('span');
        tooltip.className = 'help-tooltip';
        tooltip.textContent = text;
        tooltip.setAttribute('role', 'note');
        tooltip.hidden = true;
        element.appendChild(tooltip);
        helpTargets.set(element, tooltip);
      });
    }

    function isElementVisible(element) {
      if (!element || !element.isConnected) {
        return false;
      }
      if (element.closest('.hidden')) {
        return false;
      }
      const rect = element.getBoundingClientRect();
      return rect.width > 0 && rect.height > 0;
    }

    function setTutorialDescriptionContent(content = []) {
      if (!tutorialDescription) {
        return;
      }

      tutorialDescription.innerHTML = '';

      const fragment = document.createDocumentFragment();
      const items = Array.isArray(content) ? content : [content];

      items.forEach((item) => {
        if (typeof item === 'string') {
          const paragraph = document.createElement('p');
          paragraph.textContent = item;
          fragment.appendChild(paragraph);
          return;
        }

        if (typeof item === 'function') {
          try {
            const result = item();
            if (result instanceof Node) {
              fragment.appendChild(result);
              return;
            }

            if (typeof result === 'string') {
              const paragraph = document.createElement('p');
              paragraph.textContent = result;
              fragment.appendChild(paragraph);
            }
          } catch (error) {
            console.warn('Unable to render tutorial content item:', error);
          }
          return;
        }

        if (item instanceof Node) {
          fragment.appendChild(item);
        }
      });

      tutorialDescription.appendChild(fragment);
    }

    function ensureTutorialPointer() {
      if (tutorialPointer) {
        return tutorialPointer;
      }

      tutorialPointer = document.createElement('div');
      tutorialPointer.className = 'tutorial-pointer hidden';
      tutorialPointer.setAttribute('aria-hidden', 'true');
      tutorialPointer.innerHTML =
        '<svg viewBox="0 0 64 96" role="presentation" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><path fill="#27b4db" d="M32 0l32 36H44v56H20V36H0z"/></svg>';
      document.body.appendChild(tutorialPointer);

      return tutorialPointer;
    }

    function updateTutorialPointerPosition() {
      if (!tutorialPointer || tutorialPointer.classList.contains('hidden')) {
        return;
      }

      if (!tutorialPointerTarget || !isElementVisible(tutorialPointerTarget)) {
        hideTutorialPointer();
        return;
      }

      const rect = tutorialPointerTarget.getBoundingClientRect();
      const verticalOffset = 12;

      tutorialPointer.style.left = `${rect.left + rect.width / 2}px`;
      tutorialPointer.style.top = `${rect.bottom + verticalOffset}px`;
    }

    function showTutorialPointerFor(element) {
      if (!(element instanceof HTMLElement) || !isElementVisible(element)) {
        hideTutorialPointer();
        return;
      }

      ensureTutorialPointer();

      tutorialPointerTarget = element;
      tutorialPointer.classList.remove('hidden');
      tutorialPointer.setAttribute('aria-hidden', 'false');
      updateTutorialPointerPosition();
    }

    function hideTutorialPointer() {
      if (!tutorialPointer) {
        tutorialPointerTarget = null;
        return;
      }

      tutorialPointerTarget = null;
      tutorialPointer.classList.add('hidden');
      tutorialPointer.setAttribute('aria-hidden', 'true');
    }

    window.addEventListener('resize', updateTutorialPointerPosition);
    window.addEventListener('scroll', updateTutorialPointerPosition, true);

    function highlightTutorialElement(element, options = {}) {
      const shouldIlluminate = options?.illuminate === true;

      if (tutorialHighlightedElement) {
        if (tutorialHighlightedElement !== element || !element) {
          tutorialHighlightedElement.classList.remove('tutorial-highlight');
          tutorialHighlightedElement.classList.remove('tutorial-illuminated');
          tutorialHighlightedElementOptions = { illuminate: false };
        } else if (tutorialHighlightedElementOptions.illuminate !== shouldIlluminate) {
          tutorialHighlightedElement.classList.toggle('tutorial-illuminated', shouldIlluminate);
          tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
          return;
        } else {
          return;
        }
      }

      if (element instanceof HTMLElement) {
        element.classList.add('tutorial-highlight');
        element.classList.toggle('tutorial-illuminated', shouldIlluminate);
        tutorialHighlightedElement = element;
        tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
      } else {
        tutorialHighlightedElement = null;
        tutorialHighlightedElementOptions = { illuminate: false };
      }
    }

    function setTutorialOverlayAlignment(alignment = 'center') {
      if (!tutorialOverlay) {
        return;
      }

      const shouldAlignBottom = alignment === 'bottom';
      tutorialOverlay.classList.toggle('is-bottom-aligned', shouldAlignBottom);
    }

    function openTutorialOverlay() {
      if (!tutorialOverlay) {
        return;
      }

      tutorialPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;

      tutorialOverlay.classList.remove('hidden');
      tutorialOverlay.setAttribute('aria-hidden', 'false');

      if (tutorialDialogCard && typeof tutorialDialogCard.focus === 'function') {
        tutorialDialogCard.focus();
      }
    }

    function closeTutorialOverlay() {
      if (!tutorialOverlay) {
        return;
      }

      tutorialOverlay.classList.add('hidden');
      tutorialOverlay.setAttribute('aria-hidden', 'true');

      if (tutorialPreviousFocus && typeof tutorialPreviousFocus.focus === 'function') {
        tutorialPreviousFocus.focus();
      }

      tutorialPreviousFocus = null;
    }

    function attachTutorialKeydown() {
      document.addEventListener('keydown', handleTutorialKeydown, true);
    }

    function detachTutorialKeydown() {
      document.removeEventListener('keydown', handleTutorialKeydown, true);
    }

    function renderTutorialStep() {
      if (!tutorialActive) {
        return;
      }

      const step = tutorialSteps[tutorialStepIndex];
      if (!step) {
        return;
      }

      if (tutorialTitle) {
        tutorialTitle.textContent = step.title || '';
      }

      setTutorialDescriptionContent(step.body || []);

      if (tutorialProgress) {
        tutorialProgress.textContent = `Step ${tutorialStepIndex + 1} of ${tutorialSteps.length}`;
        tutorialProgress.classList.toggle('hidden', tutorialSteps.length <= 1);
      }

      if (tutorialPrimaryAction) {
        tutorialPrimaryAction.textContent =
          tutorialStepIndex === tutorialSteps.length - 1 ? 'Finish' : 'Next';
      }

      if (tutorialSecondaryAction) {
        const secondaryConfig = step.secondaryAction || null;
        let secondaryLabel = 'Back';
        let shouldShowSecondary = tutorialStepIndex > 0;
        tutorialSecondaryActionMode = 'back';

        if (secondaryConfig && (secondaryConfig.mode === 'skip' || secondaryConfig.mode === 'close')) {
          tutorialSecondaryActionMode = 'skip';
          secondaryLabel =
            typeof secondaryConfig.label === 'string' && secondaryConfig.label.trim().length
              ? secondaryConfig.label
              : 'Skip';
          shouldShowSecondary = true;
        }

        tutorialSecondaryAction.textContent = secondaryLabel;
        tutorialSecondaryAction.dataset.mode = tutorialSecondaryActionMode;
        tutorialSecondaryAction.classList.toggle('hidden', !shouldShowSecondary);
      }
    }

    function buildSetterTutorialSteps() {
      const steps = [
        {
          title: 'Welcome to the setter workspace',
          body: [
            'Design, update, and publish climbs from here. The wall preview on the left responds instantly as you draw or tweak route details.',
            'Use the sidebar tabs to switch between saved routes, manage walls, and adjust how problems appear to climbers.',
          ],
          secondaryAction: { mode: 'skip', label: 'Skip' },
          onEnter: () => {
            setTutorialOverlayAlignment('center');
            highlightTutorialElement(null);
            hideTutorialPointer();
            deactivateInfoMode({ clearTooltip: true });
          },
          onExit: () => {
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Routes panel',
          body: [
            'Select existing problems or start fresh, then fill in setter info, descriptions, and notes for climbers.',
            'Pick colours, change path types, and save or clear drawings while you iterate on new ideas.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            activateTab('routesTab');
            if (routesTabButton && isElementVisible(routesTabButton)) {
              highlightTutorialElement(routesTabButton, { illuminate: true });
              showTutorialPointerFor(routesTabButton);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Walls panel',
          body: [
            'Switch the active wall, create new backgrounds, or temporarily hide a wall from climbers.',
            'Use it to manage rotations and keep your wall list tidy as sets change over time.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            activateTab('wallsTab');
            if (wallsTabButton && isElementVisible(wallsTabButton)) {
              highlightTutorialElement(wallsTabButton, { illuminate: true });
              showTutorialPointerFor(wallsTabButton);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Configuration panel',
          body: [
            'Tune how holds render by adjusting point sizes, rectangle dimensions, and transparency defaults.',
            'Save appearance settings so climbers see consistent visuals across every wall you manage.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            activateTab('configurationTab');
            if (configurationTabButton && isElementVisible(configurationTabButton)) {
              highlightTutorialElement(configurationTabButton, { illuminate: true });
              showTutorialPointerFor(configurationTabButton);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Enable drawing',
          body: [
            'Toggle drawing mode when you want to sketch new holds or edit existing shapes directly on the wall.',
            'Switch it off to pan around freely or inspect details without leaving stray marks behind.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            if (drawingToggle && isElementVisible(drawingToggle)) {
              highlightTutorialElement(drawingToggle, { illuminate: true });
              showTutorialPointerFor(drawingToggle);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Info mode',
          body: [
            'Tap the info button any time for quick tooltips explaining each control in the sidebar.',
            'Info mode stays active until you toggle it off, so you can explore every setting at your own pace.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            deactivateInfoMode({ clearTooltip: true });
            if (infoButton && isElementVisible(infoButton)) {
              highlightTutorialElement(infoButton, { illuminate: true });
              showTutorialPointerFor(infoButton);
            } else {
              highlightTutorialElement(null);
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
      ];

      return steps;
    }

    async function goToTutorialStep(index) {
      if (!tutorialActive || tutorialTransitionInProgress) {
        return;
      }

      if (index < 0 || index >= tutorialSteps.length) {
        return;
      }

      tutorialTransitionInProgress = true;

      if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
        const currentStep = tutorialSteps[tutorialStepIndex];
        if (currentStep && typeof currentStep.onExit === 'function') {
          try {
            await currentStep.onExit();
          } catch (error) {
            console.warn('Tutorial step cleanup failed:', error);
          }
        }
      }

      tutorialStepIndex = index;
      renderTutorialStep();

      const nextStep = tutorialSteps[tutorialStepIndex];
      if (nextStep && typeof nextStep.onEnter === 'function') {
        try {
          await nextStep.onEnter();
        } catch (error) {
          console.warn('Tutorial step setup failed:', error);
        }
      }

      tutorialTransitionInProgress = false;

      if (tutorialPrimaryAction) {
        tutorialPrimaryAction.focus();
      }
    }

    async function startTutorial(options = {}) {
      const { force = false } = options;

      if (
        !tutorialOverlay ||
        !tutorialDialogCard ||
        !tutorialTitle ||
        !tutorialDescription ||
        !tutorialPrimaryAction
      ) {
        return false;
      }

      if (tutorialTransitionInProgress) {
        if (!force) {
          return false;
        }
        await finishTutorial();
      } else if (tutorialActive) {
        if (!force) {
          return false;
        }
        await finishTutorial();
      }

      tutorialSteps = buildSetterTutorialSteps();
      if (!Array.isArray(tutorialSteps) || tutorialSteps.length === 0) {
        return false;
      }

      cancelTutorialAutostart();

      const activeTabButton = tabButtons.find((button) => button?.getAttribute('aria-selected') === 'true');
      tutorialPreviousTabId = activeTabButton?.dataset?.target || null;

      tutorialActive = true;
      tutorialStepIndex = -1;
      tutorialTransitionInProgress = false;
      tutorialSecondaryActionMode = 'back';

      if (tutorialProgress) {
        tutorialProgress.classList.remove('hidden');
      }

      setTutorialOverlayAlignment('center');
      openTutorialOverlay();
      attachTutorialKeydown();

      await goToTutorialStep(0);
      tutorialAutostartAttempts = 0;

      return true;
    }

    function cancelTutorialAutostart() {
      if (tutorialAutostartTimeoutId !== null) {
        clearTimeout(tutorialAutostartTimeoutId);
        tutorialAutostartTimeoutId = null;
      }
    }

    function scheduleTutorialAutostart() {
      cancelTutorialAutostart();
      tutorialAutostartAttempts = 0;

      const attemptStart = async () => {
        tutorialAutostartTimeoutId = null;
        const started = await startTutorial();
        if (!started) {
          if (tutorialAutostartAttempts < 2) {
            tutorialAutostartAttempts += 1;
            tutorialAutostartTimeoutId = window.setTimeout(attemptStart, 450);
          }
        } else {
          tutorialAutostartAttempts = 0;
        }
      };

      tutorialAutostartTimeoutId = window.setTimeout(attemptStart, 0);
    }

    async function finishTutorial() {
      cancelTutorialAutostart();
      if (!tutorialActive && !tutorialTransitionInProgress) {
        tutorialPreviousTabId = null;
        tutorialSecondaryActionMode = 'back';
        return;
      }

      tutorialTransitionInProgress = true;

      if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
        const finalStep = tutorialSteps[tutorialStepIndex];
        if (finalStep && typeof finalStep.onExit === 'function') {
          try {
            await finalStep.onExit();
          } catch (error) {
            console.warn('Tutorial completion cleanup failed:', error);
          }
        }
      }

      tutorialActive = false;
      tutorialStepIndex = -1;
      tutorialTransitionInProgress = false;
      tutorialSteps = [];
      tutorialSecondaryActionMode = 'back';

      highlightTutorialElement(null);
      hideTutorialPointer();
      setTutorialOverlayAlignment('center');

      if (tutorialProgress) {
        tutorialProgress.classList.add('hidden');
      }

      closeTutorialOverlay();
      detachTutorialKeydown();

      if (tutorialPreviousTabId) {
        activateTab(tutorialPreviousTabId);
      } else {
        activateTab('routesTab');
      }

      tutorialPreviousTabId = null;
    }

    function handleTutorialKeydown(event) {
      if (!tutorialActive) {
        return;
      }

      if (event.key === 'Escape') {
        event.preventDefault();
        void finishTutorial();
        return;
      }

      if (event.key === 'ArrowRight') {
        event.preventDefault();
        if (tutorialStepIndex >= tutorialSteps.length - 1) {
          void finishTutorial();
        } else {
          void goToTutorialStep(tutorialStepIndex + 1);
        }
        return;
      }

      if (event.key === 'ArrowLeft') {
        event.preventDefault();
        if (tutorialStepIndex > 0) {
          void goToTutorialStep(tutorialStepIndex - 1);
        }
      }
    }

    function updateHelpTooltips() {
      if (!activeHelpEntry) {
        return;
      }

      const { element } = activeHelpEntry;
      if (!element || !element.isConnected) {
        clearActiveHelpTooltip();
        return;
      }

      if (!helpTargets.has(element)) {
        registerHelpTargets(element);
      }

      const tooltip = helpTargets.get(element);
      if (!tooltip) {
        clearActiveHelpTooltip();
        return;
      }

      activeHelpEntry.tooltip = tooltip;

      const activePanel = document.querySelector('.tab-panel[aria-hidden="false"]');
      const panelCollapsed = controlPanel?.getAttribute('data-expanded') === 'false';
      const modalAncestor = element.closest('.location-modal');
      const inVisibleModal = Boolean(
        modalAncestor && !modalAncestor.classList.contains('hidden'),
      );
      const insideControlPanel = controlPanel ? controlPanel.contains(element) : false;
      const inActivePanel = activePanel ? activePanel.contains(element) : true;
      const visible = isElementVisible(element);
      const shouldShow =
        visible &&
        (!panelCollapsed || !insideControlPanel) &&
        (inActivePanel || inVisibleModal || (!activePanel && visible));

      element.classList.toggle('showing-help', shouldShow);
      tooltip.hidden = !shouldShow;
    }

    function setInfoButtonActiveState(active) {
      if (!infoButton) {
        return;
      }

      const label = active ? 'Hide setter help' : 'Learn about setter tools';
      infoButton.setAttribute('aria-label', label);
      infoButton.setAttribute('title', label);
      infoButton.setAttribute('aria-pressed', active ? 'true' : 'false');
      infoButton.setAttribute('aria-expanded', active ? 'true' : 'false');
      infoButton.classList.toggle('is-active', active);

      const srTarget = infoButton.querySelector('.sr-only');
      if (srTarget) {
        srTarget.textContent = label;
      }
    }

    function showInfoPopover() {
      if (!infoPopover) {
        return;
      }

      infoPopover.classList.remove('hidden');
      infoPopover.setAttribute('aria-hidden', 'false');
      if (typeof infoPopover.focus === 'function') {
        infoPopover.focus({ preventScroll: true });
      }
    }

    function hideInfoPopover() {
      if (!infoPopover) {
        return;
      }

      infoPopover.classList.add('hidden');
      infoPopover.setAttribute('aria-hidden', 'true');
    }

    function clearActiveHelpTooltip() {
      if (!activeHelpEntry) {
        return;
      }

      const { element, tooltip } = activeHelpEntry;
      if (element) {
        element.classList.remove('showing-help');
      }
      if (tooltip) {
        tooltip.hidden = true;
      }
      activeHelpEntry = null;
    }

    function showHelpTooltipForElement(element) {
      if (!element) {
        return null;
      }

      registerHelpTargets(element);
      const tooltip = helpTargets.get(element);
      if (!tooltip) {
        return null;
      }

      if (activeHelpEntry && activeHelpEntry.element !== element) {
        clearActiveHelpTooltip();
      }

      activeHelpEntry = { element, tooltip };
      updateHelpTooltips();
      return activeHelpEntry;
    }

    function activateInfoMode() {
      if (infoModeActive) {
        return;
      }

      infoModeActive = true;
      awaitingHelpTargetSelection = true;
      clearActiveHelpTooltip();
      setInfoButtonActiveState(true);
      showInfoPopover();
    }

    function deactivateInfoMode({ clearTooltip = false } = {}) {
      awaitingHelpTargetSelection = false;

      if (infoModeActive) {
        infoModeActive = false;
      }

      setInfoButtonActiveState(false);
      hideInfoPopover();

      if (clearTooltip) {
        clearActiveHelpTooltip();
      }
    }

    const isInteractiveElement = (element) => {
      if (!element) {
        return false;
      }

      const candidate = element instanceof Element ? element : element.parentElement;
      if (!candidate) {
        return false;
      }

      if (candidate.isContentEditable) {
        return true;
      }

      if (typeof candidate.closest === 'function') {
        if (candidate.closest('[contenteditable="true"]')) {
          return true;
        }

        if (candidate.closest('input, textarea, select, button, a')) {
          return true;
        }
      }

      const tagName = typeof candidate.tagName === 'string' ? candidate.tagName.toLowerCase() : '';
      return (
        tagName === 'input' ||
        tagName === 'textarea' ||
        tagName === 'select' ||
        tagName === 'button' ||
        tagName === 'a'
      );
    };

    const updatePanModifierState = (active) => {
      isPanModifierActive = Boolean(active);

      if (!canvas) {
        return;
      }

      if (isPanModifierActive) {
        canvas.setAttribute('data-pan-modifier', 'true');
      } else {
        canvas.removeAttribute('data-pan-modifier');
      }
    };

    const hasScrollableCanvasArea = () => {
      if (!canvasContainer) {
        return false;
      }

      if (isCanvasScrollable) {
        return true;
      }

      return (
        canvasContainer.scrollWidth > canvasContainer.clientWidth ||
        canvasContainer.scrollHeight > canvasContainer.clientHeight
      );
    };

    const beginCanvasPan = (event) => {
      if (!canvasContainer || !canvas || !hasScrollableCanvasArea()) {
        return false;
      }

      isPointerPanning = true;
      panPointerId = event.pointerId;
      panPointerButton = event.button;
      panStartScrollLeft = canvasContainer.scrollLeft;
      panStartScrollTop = canvasContainer.scrollTop;
      panOriginX = event.clientX;
      panOriginY = event.clientY;
      shouldIgnoreNextClick = event.button === 0;

      canvas.classList.add('is-panning');

      if (typeof canvas.setPointerCapture === 'function') {
        try {
          canvas.setPointerCapture(event.pointerId);
        } catch (error) {
          // Ignore pointer capture errors (e.g., unsupported platforms).
        }
      }

      if (typeof event.preventDefault === 'function') {
        event.preventDefault();
      }

      return true;
    };

    const moveCanvasPan = (event) => {
      if (!isPointerPanning || event.pointerId !== panPointerId || !canvasContainer) {
        return;
      }

      const deltaX = event.clientX - panOriginX;
      const deltaY = event.clientY - panOriginY;

      canvasContainer.scrollLeft = panStartScrollLeft - deltaX;
      canvasContainer.scrollTop = panStartScrollTop - deltaY;
    };

    const endCanvasPan = () => {
      if (!isPointerPanning) {
        return;
      }

      if (
        canvas &&
        panPointerId !== null &&
        typeof canvas.hasPointerCapture === 'function' &&
        canvas.hasPointerCapture(panPointerId)
      ) {
        try {
          canvas.releasePointerCapture(panPointerId);
        } catch (error) {
          // Ignore pointer capture release errors.
        }
      }

      canvas?.classList.remove('is-panning');

      if (panPointerButton !== 0) {
        shouldIgnoreNextClick = false;
      }

      isPointerPanning = false;
      panPointerId = null;
      panPointerButton = 0;
    };

    const handleCanvasPointerDown = (event) => {
      const isPrimaryButton = event.button === 0;
      const isMiddleButton = event.button === 1;
      const panWithPrimary = isPrimaryButton && (!isDrawingEnabled || isPanModifierActive);

      if (isMiddleButton || panWithPrimary) {
        if (beginCanvasPan(event)) {
          return;
        }
      }

      shouldIgnoreNextClick = false;
    };

    const handleCanvasPointerMove = (event) => {
      moveCanvasPan(event);
    };

    const handleCanvasPointerEnd = (event) => {
      if (!isPointerPanning || event.pointerId !== panPointerId) {
        return;
      }

      endCanvasPan();
    };

    deleteButton.disabled = true;
    routeSelector.disabled = true;
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('colorPicker');
    const pathTypeSelect = document.getElementById('pathTypeSelect');
    const hollowPointDiameterField = document.getElementById('hollowPointDiameterField');
    const hollowPointDiameterSlider = document.getElementById('hollowPointDiameterSlider');
    const hollowPointDiameterValue = document.getElementById('hollowPointDiameterValue');
    const filledPointDiameterField = document.getElementById('filledPointDiameterField');
    const filledPointDiameterSlider = document.getElementById('filledPointDiameterSlider');
    const filledPointDiameterValue = document.getElementById('filledPointDiameterValue');
    const rectangleWidthField = document.getElementById('rectangleWidthField');
    const rectangleWidthSlider = document.getElementById('rectangleWidthSlider');
    const rectangleWidthValue = document.getElementById('rectangleWidthValue');
    const rectangleHeightField = document.getElementById('rectangleHeightField');
    const rectangleHeightSlider = document.getElementById('rectangleHeightSlider');
    const rectangleHeightValue = document.getElementById('rectangleHeightValue');
    const brezerStrokeWidthField = document.getElementById('brezerStrokeWidthField');
    const brezerStrokeWidthSlider = document.getElementById('brezerStrokeWidthSlider');
    const brezerStrokeWidthValue = document.getElementById('brezerStrokeWidthValue');
    const unfocusedTransparencyField = document.getElementById('unfocusedTransparencyField');
    const unfocusedTransparencySlider = document.getElementById('unfocusedTransparencySlider');
    const gradeBarBaseHeightInput = document.getElementById('gradeBarBaseHeightInput');
    const gradeBarMaxHeightInput = document.getElementById('gradeBarMaxHeightInput');
    const gradeBarWidthInput = document.getElementById('gradeBarWidthInput');
    const gradeBarTransparencyInput = document.getElementById('gradeBarTransparencyInput');
    const saveAppearanceButton = document.getElementById('saveAppearanceButton');
    const advancedColorToggle = document.getElementById('advancedColorToggle');
    const advancedColorPicker = document.getElementById('advancedColorPicker');
    const colorWheelCanvas = document.getElementById('colorWheelCanvas');
    const colorWheelMarker = document.getElementById('colorWheelMarker');
    const colorLightnessSlider = document.getElementById('colorLightnessSlider');
    const colorWheelValue = document.getElementById('colorWheelValue');
    const colorWheelSwatch = document.getElementById('colorWheelSwatch');
    const clearButton = document.getElementById('clearButton');
    const saveButton = document.getElementById('saveButton');
    const cancelRouteButton = document.getElementById('cancelRouteButton');

    const SYNTHETIC_EMAIL_DOMAIN = 'users.anuascend.local';
    const USERNAME_PATTERN = /^[a-z0-9_]{3,20}$/;
    const SETTER_NAME_PATTERN = /^[a-z0-9_ ]{3,40}$/;

    const normalizeUsername = (value) => {
      if (typeof value !== 'string') {
        return '';
      }
      return value.trim().toLowerCase();
    };

    const normalizeSetterName = (value) => {
      if (typeof value !== 'string') {
        return '';
      }
      return value
        .trim()
        .toLowerCase()
        .replace(/\s+/g, ' ');
    };

    function normalizePathType(value) {
      if (typeof value === 'string') {
        const trimmed = value.trim().toLowerCase();
        const normalized = trimmed.replace(/\s+/g, '-');
        if (normalized === PATH_TYPE_BREZER) {
          return PATH_TYPE_BREZER;
        }
        if (normalized === PATH_TYPE_RECTANGLE) {
          return PATH_TYPE_RECTANGLE;
        }
        if (normalized === PATH_TYPE_FILLED_POINT) {
          return PATH_TYPE_FILLED_POINT;
        }
        if (normalized === PATH_TYPE_HOLLOW_POINT || normalized === LEGACY_PATH_TYPE_POINT) {
          return PATH_TYPE_HOLLOW_POINT;
        }
      }
      return DEFAULT_PATH_TYPE;
    }

    function isNormalizedPointPathType(value) {
      return value === PATH_TYPE_HOLLOW_POINT || value === PATH_TYPE_FILLED_POINT;
    }

    function getDefaultPointDiameterForPathType(pathTypeValue) {
      const normalized = normalizePathType(pathTypeValue);
      if (normalized === PATH_TYPE_FILLED_POINT) {
        return DEFAULT_FILLED_POINT_DIAMETER;
      }
      if (normalized === PATH_TYPE_HOLLOW_POINT) {
        return DEFAULT_HOLLOW_POINT_DIAMETER;
      }
      return DEFAULT_POINT_DIAMETER;
    }

    function getStatePointDiameterForPathType(pathTypeValue) {
      const normalized = normalizePathType(pathTypeValue);
      if (normalized === PATH_TYPE_FILLED_POINT) {
        return filledPointDiameter;
      }
      return pointDiameter;
    }

    function getRoutePointDiameterForPathType(routeData, pathTypeValue) {
      const normalized = normalizePathType(pathTypeValue ?? routeData?.pathType);
      if (normalized === PATH_TYPE_FILLED_POINT) {
        const sourceValue =
          routeData?.filledPointDiameter ??
          routeData?.pointDiameter ??
          filledPointDiameter;
        return normalizePointDiameter(sourceValue, DEFAULT_FILLED_POINT_DIAMETER);
      }
      if (normalized === PATH_TYPE_HOLLOW_POINT) {
        const sourceValue =
          routeData?.hollowPointDiameter ??
          routeData?.pointDiameter ??
          pointDiameter;
        return normalizePointDiameter(sourceValue, DEFAULT_HOLLOW_POINT_DIAMETER);
      }
      return normalizePointDiameter(routeData?.pointDiameter, DEFAULT_POINT_DIAMETER);
    }

    function normalizePointDiameter(value, fallback = DEFAULT_POINT_DIAMETER) {
      const numeric = Number(value);
      let candidate = numeric;
      if (!Number.isFinite(candidate)) {
        const fallbackNumeric = Number(fallback);
        candidate = Number.isFinite(fallbackNumeric) ? fallbackNumeric : DEFAULT_POINT_DIAMETER;
      }
      const clamped = Math.min(
        Math.max(Math.round(candidate), MIN_POINT_DIAMETER),
        MAX_POINT_DIAMETER,
      );
      return clamped;
    }

    function normalizeRectangleSize(value, fallback = DEFAULT_RECTANGLE_WIDTH) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return fallback;
      }
      const clamped = Math.min(
        Math.max(Math.round(numeric), MIN_RECTANGLE_SIZE),
        MAX_RECTANGLE_SIZE,
      );
      return clamped;
    }

    function normalizeBrezerStrokeWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_BREZER_STROKE_WIDTH;
      }
      const clamped = Math.min(
        Math.max(Math.round(numeric), MIN_BREZER_STROKE_WIDTH),
        MAX_BREZER_STROKE_WIDTH,
      );
      return clamped;
    }

    function normalizeGradeBarHeight(value, fallback) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return fallback;
      }
      const clamped = Math.min(
        Math.max(numeric, MIN_GRADE_BAR_BASE_HEIGHT),
        MAX_GRADE_BAR_HEIGHT,
      );
      return Math.round(clamped);
    }

    function normalizeGradeBarWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_GRADE_BAR_WIDTH;
      }
      const clamped = Math.min(
        Math.max(Math.round(numeric), MIN_GRADE_BAR_WIDTH),
        MAX_GRADE_BAR_WIDTH,
      );
      return clamped;
    }

    function normalizeGradeBarTransparency(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_GRADE_BAR_TRANSPARENCY;
      }
      const clamped = Math.min(Math.max(numeric, 0), 1);
      return Math.round(clamped * 1000) / 1000;
    }

    function normalizeGradeValue(value) {
      if (value === null || value === undefined) {
        return null;
      }

      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }

      if (!Number.isInteger(numeric)) {
        return null;
      }

      if (numeric < MIN_GRADE_VALUE || numeric > MAX_GRADE_VALUE) {
        return null;
      }

      return numeric;
    }

    function normalizeUnfocusedTransparency(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_UNFOCUSED_TRANSPARENCY;
      }
      const clamped = Math.min(
        Math.max(numeric, MIN_UNFOCUSED_TRANSPARENCY),
        MAX_UNFOCUSED_TRANSPARENCY,
      );
      return Math.round(clamped * 1000) / 1000;
    }

    function convertUnfocusedTransparencyToSliderValue(value) {
      return Math.round(normalizeUnfocusedTransparency(value) * 100);
    }

    function sliderValueToUnfocusedTransparency(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return DEFAULT_UNFOCUSED_TRANSPARENCY;
      }
      return normalizeUnfocusedTransparency(numeric / 100);
    }

    function createDefaultWallSettings() {
      return {
        pointDiameter: DEFAULT_HOLLOW_POINT_DIAMETER,
        hollowPointDiameter: DEFAULT_HOLLOW_POINT_DIAMETER,
        filledPointDiameter: DEFAULT_FILLED_POINT_DIAMETER,
        rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
        rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
        brezerStrokeWidth: DEFAULT_BREZER_STROKE_WIDTH,
        unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
        gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
        gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
        gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
        gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
      };
    }

    function normalizeWallSettings(raw = {}) {
      if (!raw || typeof raw !== 'object') {
        return createDefaultWallSettings();
      }

      const hollowPointDiameter = normalizePointDiameter(
        raw.hollowPointDiameter ?? raw.pointDiameter,
        DEFAULT_HOLLOW_POINT_DIAMETER,
      );
      const filledPointDiameter = normalizePointDiameter(
        raw.filledPointDiameter ?? raw.pointDiameter,
        DEFAULT_FILLED_POINT_DIAMETER,
      );
      const rectangleWidth = normalizeRectangleSize(
        raw.rectangleWidth,
        DEFAULT_RECTANGLE_WIDTH,
      );
      const rectangleHeight = normalizeRectangleSize(
        raw.rectangleHeight,
        DEFAULT_RECTANGLE_HEIGHT,
      );
      const brezerStrokeWidth = normalizeBrezerStrokeWidth(raw.brezerStrokeWidth);
      const gradeBarBaseHeight = normalizeGradeBarHeight(
        raw.gradeBarBaseHeight,
        DEFAULT_GRADE_BAR_BASE_HEIGHT,
      );
      const gradeBarMaxHeight = Math.max(
        gradeBarBaseHeight,
        normalizeGradeBarHeight(raw.gradeBarMaxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
      );
      const gradeBarWidth = normalizeGradeBarWidth(raw.gradeBarWidth);
      const gradeBarTransparency = normalizeGradeBarTransparency(
        raw.gradeBarTransparency ?? raw.transparency,
      );
      return {
        pointDiameter: hollowPointDiameter,
        hollowPointDiameter,
        filledPointDiameter,
        rectangleWidth,
        rectangleHeight,
        brezerStrokeWidth,
        unfocusedTransparency: normalizeUnfocusedTransparency(raw.unfocusedTransparency),
        gradeBarBaseHeight,
        gradeBarMaxHeight,
        gradeBarWidth,
        gradeBarTransparency,
      };
    }

    function getWallSettingsWithFallback(locationKey, fallback = null) {
      const key = normalizeWallKey(locationKey);
      if (key) {
        const cached = wallSettingsCache.get(key);
        if (cached) {
          return { ...cached };
        }
      }

      if (fallback) {
        const normalized = normalizeWallSettings(fallback);
        if (key) {
          wallSettingsCache.set(key, normalized);
        }
        return normalized;
      }

      return createDefaultWallSettings();
    }

    function getWallSettingsForLocation(locationKey) {
      return getWallSettingsWithFallback(locationKey);
    }

    function applyWallSettingsToStateForLocationKey(locationKey, fallback = null) {
      const settings = getWallSettingsWithFallback(locationKey, fallback);
      pointDiameter = settings.hollowPointDiameter ?? settings.pointDiameter;
      filledPointDiameter = settings.filledPointDiameter ?? settings.pointDiameter;
      rectangleWidth = settings.rectangleWidth;
      rectangleHeight = settings.rectangleHeight;
      brezerStrokeWidth = settings.brezerStrokeWidth;
      unfocusedTransparency = settings.unfocusedTransparency;
      gradeBarBaseHeight = settings.gradeBarBaseHeight;
      gradeBarMaxHeight = settings.gradeBarMaxHeight;
      gradeBarWidth = settings.gradeBarWidth;
      gradeBarTransparency = settings.gradeBarTransparency;
      updatePathControls();
      updateAppearanceControls();
    }

    function getCurrentLocationKey() {
      if (currentLocation?.key) {
        return normalizeWallKey(currentLocation.key);
      }
      return normalizeLocationName(currentLocation?.name);
    }

    async function ensureWallSettings(locationKey) {
      const key = normalizeWallKey(locationKey);
      if (!key) {
        return createDefaultWallSettings();
      }

      if (wallSettingsCache.has(key)) {
        return { ...wallSettingsCache.get(key) };
      }

      try {
        const docId = wallDocumentIdMap.get(key) || key;
        const wallRef = doc(db, WALL_COLLECTION, docId);
        const snap = await getDoc(wallRef);
        if (snap.exists()) {
          const data = snap.data();
          const settings = normalizeWallSettings(data);
          const normalizedId = normalizeWallKey(snap.id);
          const normalizedName = normalizeWallKey(data?.name);

          if (normalizedId) {
            wallSettingsCache.set(normalizedId, settings);
            wallDocumentIdMap.set(normalizedId, snap.id);
          }

          if (normalizedName) {
            wallDocumentIdMap.set(normalizedName, snap.id);
            if (!wallSettingsCache.has(normalizedName)) {
              wallSettingsCache.set(normalizedName, settings);
            }
          }

          if (data?.key) {
            const normalizedLocationKey = normalizeWallKey(data.key);
            if (normalizedLocationKey) {
              wallDocumentIdMap.set(normalizedLocationKey, snap.id);
              if (!wallSettingsCache.has(normalizedLocationKey)) {
                wallSettingsCache.set(normalizedLocationKey, settings);
              }
            }
          }

          const { changed: locationChanged } = upsertLocation({
            key: typeof data?.key === 'string' ? data.key : snap.id,
            name: typeof data?.name === 'string' ? data.name : '',
            image: typeof data?.background_url === 'string' ? data.background_url : '',
            fallbackName: typeof data?.name === 'string' && data.name ? data.name : snap.id,
            hidden: Boolean(data?.hidden),
          });

          if (locationChanged) {
            renderLocationOptions();
            synchronizeCurrentLocationReference();
          }

          return { ...settings };
        }
      } catch (error) {
        console.warn(`Failed to load wall settings for ${locationKey}:`, error);
      }

      return createDefaultWallSettings();
    }

    async function refreshWallSettingsCache() {
      try {
        const snapshot = await getDocs(collection(db, WALL_COLLECTION));
        const fetchedKeys = new Set();
        wallDocumentIdMap.clear();
        let locationsChanged = false;
        snapshot.forEach((docSnap) => {
          const data = docSnap.data();
          const settings = normalizeWallSettings(data);
          const normalizedId = normalizeWallKey(docSnap.id);
          const normalizedName = normalizeWallKey(data?.name);

          if (normalizedId) {
            wallSettingsCache.set(normalizedId, settings);
            wallDocumentIdMap.set(normalizedId, docSnap.id);
            fetchedKeys.add(normalizedId);
          }

          if (normalizedName) {
            wallDocumentIdMap.set(normalizedName, docSnap.id);
            wallSettingsCache.set(normalizedName, settings);
            fetchedKeys.add(normalizedName);
          }

          if (data?.key) {
            const normalizedLocationKey = normalizeWallKey(data.key);
            if (normalizedLocationKey) {
              wallDocumentIdMap.set(normalizedLocationKey, docSnap.id);
              wallSettingsCache.set(normalizedLocationKey, settings);
              fetchedKeys.add(normalizedLocationKey);
            }
          }

          const { changed } = upsertLocation({
            key: typeof data?.key === 'string' ? data.key : docSnap.id,
            name: typeof data?.name === 'string' ? data.name : '',
            image: typeof data?.background_url === 'string' ? data.background_url : '',
            fallbackName: typeof data?.name === 'string' && data.name ? data.name : docSnap.id,
            hidden: Boolean(data?.hidden),
          });

          if (changed) {
            locationsChanged = true;
          }
        });

        wallSettingsCache.forEach((value, key) => {
          if (!fetchedKeys.has(key)) {
            wallSettingsCache.delete(key);
          }
        });

        if (locationsChanged) {
          renderLocationOptions();
          synchronizeCurrentLocationReference();
        }
      } catch (error) {
        console.warn('Failed to refresh wall settings:', error);
      }
    }

    function updateRoutesForWall(locationKey, settings) {
      const normalizedKey = normalizeWallKey(locationKey);
      if (!normalizedKey || !settings) {
        return;
      }

      routesCache.forEach((data, routeKey) => {
        const routeLocationKey = normalizeWallKey(
          typeof data?.locationKey === 'string'
            ? data.locationKey
            : normalizeLocationName(data?.location),
        );
        if (routeLocationKey === normalizedKey) {
          routesCache.set(routeKey, {
            ...data,
            pointDiameter: settings.hollowPointDiameter ?? settings.pointDiameter,
            hollowPointDiameter: settings.hollowPointDiameter ?? settings.pointDiameter,
            filledPointDiameter: settings.filledPointDiameter ?? settings.pointDiameter,
            brezerStrokeWidth: settings.brezerStrokeWidth,
            rectangleWidth: settings.rectangleWidth,
            rectangleHeight: settings.rectangleHeight,
            gradeBarBaseHeight: settings.gradeBarBaseHeight,
            gradeBarMaxHeight: settings.gradeBarMaxHeight,
            gradeBarWidth: settings.gradeBarWidth,
            gradeBarTransparency: settings.gradeBarTransparency,
          });
        }
      });
    }

    function updateRoutesForAllWalls() {
      routesCache.forEach((data, key) => {
        const routeLocationKey = normalizeWallKey(
          typeof data?.locationKey === 'string'
            ? data.locationKey
            : normalizeLocationName(data?.location),
        );
        const settings = getWallSettingsForLocation(routeLocationKey);
        routesCache.set(key, {
          ...data,
          pointDiameter: settings.hollowPointDiameter ?? settings.pointDiameter,
          hollowPointDiameter: settings.hollowPointDiameter ?? settings.pointDiameter,
          filledPointDiameter: settings.filledPointDiameter ?? settings.pointDiameter,
          brezerStrokeWidth: settings.brezerStrokeWidth,
          rectangleWidth: settings.rectangleWidth,
          rectangleHeight: settings.rectangleHeight,
          gradeBarBaseHeight: settings.gradeBarBaseHeight,
          gradeBarMaxHeight: settings.gradeBarMaxHeight,
          gradeBarWidth: settings.gradeBarWidth,
          gradeBarTransparency: settings.gradeBarTransparency,
        });
      });
    }

    async function persistWallSettings(locationKey, updates = {}) {
      const normalizedKey = normalizeWallKey(locationKey);
      if (!normalizedKey) {
        return;
      }

      const merged = normalizeWallSettings({
        ...getWallSettingsForLocation(normalizedKey),
        ...updates,
      });

      wallSettingsCache.set(normalizedKey, merged);
      updateRoutesForWall(normalizedKey, merged);

      if (getCurrentLocationKey() === normalizedKey) {
        pointDiameter = merged.hollowPointDiameter ?? merged.pointDiameter;
        filledPointDiameter = merged.filledPointDiameter ?? merged.pointDiameter;
        brezerStrokeWidth = merged.brezerStrokeWidth;
        unfocusedTransparency = merged.unfocusedTransparency;
        gradeBarBaseHeight = merged.gradeBarBaseHeight;
        gradeBarMaxHeight = merged.gradeBarMaxHeight;
        gradeBarWidth = merged.gradeBarWidth;
        gradeBarTransparency = merged.gradeBarTransparency;
        updatePathControls();
        updateAppearanceControls();
        redraw();
      } else {
        redraw();
      }

      try {
        const locationDetails =
          (currentLocation && normalizeWallKey(currentLocation.name) === normalizedKey
            ? currentLocation
            : null) ||
          findLocationByName(normalizedKey) ||
          null;

        const wallPayload = {
          pointDiameter: merged.hollowPointDiameter ?? merged.pointDiameter,
          hollowPointDiameter: merged.hollowPointDiameter ?? merged.pointDiameter,
          filledPointDiameter: merged.filledPointDiameter ?? merged.pointDiameter,
          rectangleWidth: merged.rectangleWidth,
          rectangleHeight: merged.rectangleHeight,
          brezerStrokeWidth: merged.brezerStrokeWidth,
          unfocusedTransparency: merged.unfocusedTransparency,
          gradeBarBaseHeight: merged.gradeBarBaseHeight,
          gradeBarMaxHeight: merged.gradeBarMaxHeight,
          gradeBarWidth: merged.gradeBarWidth,
          transparency: merged.gradeBarTransparency,
          updatedAt: serverTimestamp(),
          key: normalizedKey,
        };

        if (locationDetails) {
          const { name, image } = locationDetails;
          if (typeof name === 'string' && name.trim()) {
            wallPayload.name = name.trim();
          }

          if (typeof image === 'string' && image.trim()) {
            wallPayload.background_url = image.trim();
          }
        }

        const docId = wallDocumentIdMap.get(normalizedKey) || normalizedKey;
        await setDoc(doc(db, WALL_COLLECTION, docId), wallPayload, { merge: true });
        wallDocumentIdMap.set(normalizedKey, docId);

        if (typeof wallPayload.name === 'string' && wallPayload.name) {
          const normalizedName = normalizeWallKey(wallPayload.name);
          if (normalizedName) {
            wallDocumentIdMap.set(normalizedName, docId);
            if (!wallSettingsCache.has(normalizedName)) {
              wallSettingsCache.set(normalizedName, merged);
            }
          }
        }

        if (locationDetails?.key) {
          const normalizedLocationKey = normalizeWallKey(locationDetails.key);
          if (normalizedLocationKey) {
            wallDocumentIdMap.set(normalizedLocationKey, docId);
            if (!wallSettingsCache.has(normalizedLocationKey)) {
              wallSettingsCache.set(normalizedLocationKey, merged);
            }
          }
        }
      } catch (error) {
        console.error('Failed to save wall settings:', error);
        setStatus('Failed to save wall settings. Please try again.', 'error');
        throw error;
      }
    }

    async function handleCreateWall() {
      if (isCreatingWall) {
        return;
      }

      clearCreateWallStatusMessage();

      const rawName = newWallNameInput?.value ?? '';
      const trimmedName = rawName.trim();
      if (!trimmedName) {
        setCreateWallStatusMessage('Enter a wall name.', 'error');
        newWallNameInput?.focus();
        return;
      }

      const rawImage = newWallImageInput?.value ?? '';
      const trimmedImage = rawImage.trim();
      if (!trimmedImage) {
        setCreateWallStatusMessage('Enter a background image URL.', 'error');
        newWallImageInput?.focus();
        return;
      }

      const normalizedKey = normalizeWallKey(trimmedName);
      if (!normalizedKey) {
        setCreateWallStatusMessage('Enter a valid wall name.', 'error');
        newWallNameInput?.focus();
        return;
      }

      if (findLocationByKey(normalizedKey) || findLocationByName(trimmedName)) {
        setCreateWallStatusMessage('A wall with this name already exists.', 'error');
        return;
      }

      if (wallDocumentIdMap.has(normalizedKey)) {
        setCreateWallStatusMessage('A wall with this key already exists.', 'error');
        return;
      }

      isCreatingWall = true;
      if (createWallButton) {
        createWallButton.disabled = true;
      }

      setCreateWallStatusMessage('Creating wall…');

      try {
        const wallSettings = createDefaultWallSettings();
        const payload = {
          name: trimmedName,
          background_url: trimmedImage,
          pointDiameter: wallSettings.hollowPointDiameter,
          hollowPointDiameter: wallSettings.hollowPointDiameter,
          filledPointDiameter: wallSettings.filledPointDiameter,
          rectangleWidth: wallSettings.rectangleWidth,
          rectangleHeight: wallSettings.rectangleHeight,
          unfocusedTransparency: wallSettings.unfocusedTransparency,
          gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
          gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
          gradeBarWidth: wallSettings.gradeBarWidth,
          transparency: wallSettings.gradeBarTransparency,
          key: normalizedKey,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        };

        const docId = normalizedKey;
        await setDoc(doc(db, WALL_COLLECTION, docId), payload, { merge: true });

        wallDocumentIdMap.set(normalizedKey, docId);
        wallSettingsCache.set(normalizedKey, wallSettings);

        const { entry: locationEntry, changed } = upsertLocation({
          key: normalizedKey,
          name: trimmedName,
          image: trimmedImage,
          fallbackName: trimmedName,
          hidden: false,
        });

        if (changed) {
          renderLocationOptions();
        }

        synchronizeCurrentLocationReference();

        if (newWallNameInput) {
          newWallNameInput.value = '';
        }
        if (newWallImageInput) {
          newWallImageInput.value = '';
        }

        const targetLocation =
          locationEntry ||
          findLocationByKey(normalizedKey) ||
          { key: normalizedKey, name: trimmedName, image: trimmedImage };

        setLocation(targetLocation, {
          persist: true,
          refreshRoutes: true,
          wallFallback: wallSettings,
        });

        setCreateWallStatusMessage(`Created wall “${trimmedName}”.`, 'success');
      } catch (error) {
        console.error('Failed to create wall:', error);
        setCreateWallStatusMessage('Failed to create wall. Please try again.', 'error');
      } finally {
        isCreatingWall = false;
        if (createWallButton) {
          createWallButton.disabled = false;
        }
      }
    }

    async function handleDeleteWall() {
      if (isDeletingWall) {
        return;
      }

      clearCreateWallStatusMessage();

      const activeLocation = currentLocation || null;
      const locationKey = getCurrentLocationKey();
      const locationName = activeLocation?.name || '';

      if (!locationKey) {
        setCreateWallStatusMessage('Select a wall before deleting it.', 'error');
        return;
      }

      if (LOCATIONS.length <= 1) {
        setCreateWallStatusMessage(
          'At least one wall must remain. Create another wall before deleting this one.',
          'error',
        );
        return;
      }

      const confirmationLabel = locationName || locationKey;
      const confirmed = window.confirm(
        `Delete wall “${confirmationLabel}”? This will remove all associated routes.`,
      );

      if (!confirmed) {
        return;
      }

      const normalizedCurrentKey = normalizeWallKey(locationKey);
      const docId = wallDocumentIdMap.get(normalizedCurrentKey) || locationKey;
      const wallRef = doc(db, WALL_COLLECTION, docId);

      isDeletingWall = true;
      if (deleteWallButton) {
        deleteWallButton.disabled = true;
      }

      setCreateWallStatusMessage('Deleting wall…');
      updateDeleteWallButtonState();

      try {
        let wallSnapshot = null;
        try {
          wallSnapshot = await getDoc(wallRef);
        } catch (snapshotError) {
          console.warn('Unable to load wall before deletion:', snapshotError);
        }

        const wallData = wallSnapshot?.exists?.() ? wallSnapshot.data() : null;

        const normalizedTargets = new Set(
          [
            normalizedCurrentKey,
            normalizeWallKey(docId),
            normalizeWallKey(wallData?.key),
            normalizeLocationName(wallData?.name),
            normalizeLocationName(locationName),
          ].filter(Boolean),
        );

        const routesSnapshot = await getDocs(collection(db, 'routes'));
        const routeIdsToDelete = [];
        routesSnapshot.forEach((routeSnap) => {
          const data = routeSnap.data();
          const normalizedRouteLocation = normalizeWallKey(
            typeof data?.locationKey === 'string' && data.locationKey
              ? data.locationKey
              : normalizeLocationName(data?.location),
          );
          if (normalizedRouteLocation && normalizedTargets.has(normalizedRouteLocation)) {
            routeIdsToDelete.push(routeSnap.id);
          }
        });

        for (const routeId of routeIdsToDelete) {
          await deleteDoc(doc(db, 'routes', routeId));
          routesCache.delete(routeId);
        }

        await deleteDoc(wallRef);

        const keysToRemove = new Set(normalizedTargets);

        for (const [key, value] of [...wallDocumentIdMap.entries()]) {
          if (keysToRemove.has(key) || value === docId) {
            wallDocumentIdMap.delete(key);
          }
        }

        for (const key of keysToRemove) {
          wallSettingsCache.delete(key);
        }

        for (let index = LOCATIONS.length - 1; index >= 0; index -= 1) {
          const entry = LOCATIONS[index];
          if (!entry) {
            continue;
          }
          const entryKey = normalizeWallKey(entry.key);
          const entryName = normalizeLocationName(entry.name);
          if (keysToRemove.has(entryKey) || keysToRemove.has(entryName)) {
            LOCATIONS.splice(index, 1);
          }
        }

        renderLocationOptions();

        const fallbackLocation = LOCATIONS.find((location) => {
          const entryKey = normalizeWallKey(location?.key || location?.name);
          return entryKey && !keysToRemove.has(entryKey);
        });

        if (fallbackLocation) {
          setLocation(fallbackLocation, { persist: true, refreshRoutes: false });
        } else {
        currentLocation = null;
        clearRouteFocus();
          updateLocationButtonLabel();
          updateLocationOptionsState();
          applyBodyBackground('');
        }

        updateDeleteWallButtonState();

        const cacheRouteKeysToDelete = [];
        routesCache.forEach((data, routeKey) => {
          const normalizedRouteLocation = normalizeWallKey(
            typeof data?.locationKey === 'string' && data.locationKey
              ? data.locationKey
              : normalizeLocationName(data?.location),
          );
          if (normalizedRouteLocation && keysToRemove.has(normalizedRouteLocation)) {
            cacheRouteKeysToDelete.push(routeKey);
          }
        });

        cacheRouteKeysToDelete.forEach((routeKey) => {
          routesCache.delete(routeKey);
        });

        await loadRoutesList('');
        prepareNewRoute('Wall deleted. You can select another wall.');

        setCreateWallStatusMessage(`Deleted wall “${confirmationLabel}”.`, 'success');
      } catch (error) {
        console.error('Failed to delete wall:', error);
        setCreateWallStatusMessage('Failed to delete wall. Please try again.', 'error');
      } finally {
        isDeletingWall = false;
        if (deleteWallButton) {
          deleteWallButton.disabled = false;
        }
        updateDeleteWallButtonState();
      }
    }

    const isValidUsername = (value) => USERNAME_PATTERN.test(normalizeUsername(value));
    const isValidSetterName = (value) => SETTER_NAME_PATTERN.test(normalizeSetterName(value));

    const buildSyntheticEmail = (username) => {
      const normalized = normalizeUsername(username);
      return normalized ? `${normalized}@${SYNTHETIC_EMAIL_DOMAIN}` : '';
    };

    const points = [];
    const normalizedPointsByPathType = new Map();
    let strokeColor = sanitizeColor(colorPicker.value || '#ffde59');
    let pathType = DEFAULT_PATH_TYPE;
    let isDrawingEnabled = false;
    let pointDiameter = DEFAULT_HOLLOW_POINT_DIAMETER;
    let filledPointDiameter = DEFAULT_FILLED_POINT_DIAMETER;
    let rectangleWidth = DEFAULT_RECTANGLE_WIDTH;
    let rectangleHeight = DEFAULT_RECTANGLE_HEIGHT;
    let brezerStrokeWidth = DEFAULT_BREZER_STROKE_WIDTH;
    let unfocusedTransparency = DEFAULT_UNFOCUSED_TRANSPARENCY;
    let gradeBarBaseHeight = DEFAULT_GRADE_BAR_BASE_HEIGHT;
    let gradeBarMaxHeight = DEFAULT_GRADE_BAR_MAX_HEIGHT;
    let gradeBarWidth = DEFAULT_GRADE_BAR_WIDTH;
    let gradeBarTransparency = DEFAULT_GRADE_BAR_TRANSPARENCY;
    let currentRouteMedianGrade = null;
    let wheelHue = 48;
    let wheelSaturation = 1;
    let wheelLightness = 0.5;
    let isWheelPointerActive = false;
    let loadedNormalizedPoints = null;
    let currentRouteKey = '';
    let hasUnsavedChanges = false;
    let isSaving = false;
    let currentUsername = '';
    let currentUserId = null;
    let isCanvasScrollable = false;
    let isCreatingWall = false;
    let isDeletingWall = false;
    let isPointerPanning = false;
    let panPointerId = null;
    let panPointerButton = 0;
    let panStartScrollLeft = 0;
    let panStartScrollTop = 0;
    let panOriginX = 0;
    let panOriginY = 0;
    let shouldIgnoreNextClick = false;
    let isPanModifierActive = false;
    const helpTargets = new Map();
    let infoModeActive = false;
    let awaitingHelpTargetSelection = false;
    let activeHelpEntry = null;

    registerHelpTargets(document);
    setInfoButtonActiveState(false);
    updateHelpTooltips();

    if (drawingToggle) {
      updateDrawingToggle();
      drawingToggle.addEventListener('click', () => {
        setDrawingEnabled(!isDrawingEnabled);
      });
    }

    if (tutorialPrimaryAction) {
      tutorialPrimaryAction.addEventListener('click', () => {
        if (!tutorialActive) {
          return;
        }

        if (tutorialStepIndex >= tutorialSteps.length - 1) {
          void finishTutorial();
        } else {
          void goToTutorialStep(tutorialStepIndex + 1);
        }
      });
    }

    if (tutorialSecondaryAction) {
      tutorialSecondaryAction.addEventListener('click', () => {
        if (!tutorialActive) {
          return;
        }

        const mode = tutorialSecondaryAction.dataset.mode || tutorialSecondaryActionMode;
        if (mode === 'skip' || mode === 'close') {
          void finishTutorial();
          return;
        }

        if (tutorialStepIndex <= 0) {
          return;
        }

        void goToTutorialStep(tutorialStepIndex - 1);
      });
    }

    if (tutorialOverlay) {
      tutorialOverlay.addEventListener('click', (event) => {
        if (event.target === tutorialOverlay) {
          void finishTutorial();
        }
      });
    }

    window.addEventListener('keydown', (event) => {
      if (event.code !== 'Space') {
        return;
      }

      if (event.repeat) {
        event.preventDefault();
        return;
      }

      if (isInteractiveElement(event.target)) {
        return;
      }

      event.preventDefault();
      updatePanModifierState(true);
    });

    window.addEventListener('keyup', (event) => {
      if (event.code !== 'Space') {
        return;
      }

      updatePanModifierState(false);
    });

    window.addEventListener('blur', () => {
      updatePanModifierState(false);
    });

    if (clearFocusButton) {
      clearFocusButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        clearRouteFocus();
      });
    }

    if (canvas) {
      canvas.addEventListener('pointerdown', handleCanvasPointerDown);
      canvas.addEventListener('pointermove', handleCanvasPointerMove);
      canvas.addEventListener('pointerup', handleCanvasPointerEnd);
      canvas.addEventListener('pointercancel', handleCanvasPointerEnd);
      canvas.addEventListener('pointerleave', handleCanvasPointerEnd);
    }

    const routesCache = new Map();
    let routeMedianGrades = new Map();
    let queuedGradeBarOverlays = [];
    let focusedRouteKey = '';
    let overlayInteractionEntries = [];

    const DOUBLE_FOCUS_TIME_THRESHOLD = 350;
    const DOUBLE_FOCUS_DISTANCE_THRESHOLD = 32;
    let lastFocusActivation = {
      time: 0,
      routeKey: '',
      pointerType: '',
      x: 0,
      y: 0,
    };

    const updateClearFocusButton = () => {
      if (!clearFocusButton) {
        return;
      }

      const hasFocus = Boolean(focusedRouteKey);
      clearFocusButton.classList.toggle('hidden', !hasFocus);
      clearFocusButton.setAttribute('aria-hidden', hasFocus ? 'false' : 'true');

      if (hasFocus) {
        clearFocusButton.removeAttribute('disabled');
      } else {
        clearFocusButton.setAttribute('disabled', 'true');
        if (document.activeElement === clearFocusButton && typeof clearFocusButton.blur === 'function') {
          clearFocusButton.blur();
        }
      }
    };

    const resetLastFocusActivation = () => {
      lastFocusActivation = {
        time: 0,
        routeKey: '',
        pointerType: '',
        x: 0,
        y: 0,
      };
    };

    const resolvePointerType = (event) => {
      if (!event) {
        return '';
      }

      if (typeof event.pointerType === 'string') {
        return event.pointerType;
      }

      if (typeof event.type === 'string') {
        if (event.type.startsWith('mouse')) {
          return 'mouse';
        }
        if (event.type.startsWith('touch')) {
          return 'touch';
        }
        if (event.type.startsWith('pen')) {
          return 'pen';
        }
      }

      return '';
    };

    const shouldFocusFromInteraction = (event, entry) => {
      if (!entry || typeof entry.routeKey !== 'string' || !entry.routeKey) {
        resetLastFocusActivation();
        return false;
      }

      const pointerType = resolvePointerType(event);
      const now = typeof event?.timeStamp === 'number' ? event.timeStamp : Date.now();
      const clickCount = typeof event?.detail === 'number' ? event.detail : 0;
      let isDoubleActivation = clickCount >= 2;

      if (!isDoubleActivation && lastFocusActivation.routeKey) {
        const elapsed = now - lastFocusActivation.time;
        if (elapsed <= DOUBLE_FOCUS_TIME_THRESHOLD) {
          const pointerMatches =
            !pointerType || !lastFocusActivation.pointerType
              ? true
              : pointerType === lastFocusActivation.pointerType;
          if (pointerMatches && entry.routeKey === lastFocusActivation.routeKey) {
            const dx = (entry.canvasX ?? 0) - (lastFocusActivation.x ?? 0);
            const dy = (entry.canvasY ?? 0) - (lastFocusActivation.y ?? 0);
            const distanceSquared = dx * dx + dy * dy;
            if (distanceSquared <= DOUBLE_FOCUS_DISTANCE_THRESHOLD * DOUBLE_FOCUS_DISTANCE_THRESHOLD) {
              isDoubleActivation = true;
            }
          }
        }
      }

      lastFocusActivation = {
        time: now,
        routeKey: entry.routeKey,
        pointerType,
        x: entry.canvasX ?? 0,
        y: entry.canvasY ?? 0,
      };

      return isDoubleActivation;
    };

    const distanceSquared = (x1, y1, x2, y2) => {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return dx * dx + dy * dy;
    };

    const isPointNearSegment = (px, py, x1, y1, x2, y2, padding = 0) => {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const lengthSquared = dx * dx + dy * dy;

      if (lengthSquared <= 0.0001) {
        return distanceSquared(px, py, x1, y1) <= padding * padding;
      }

      let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
      t = Math.max(0, Math.min(1, t));

      const projX = x1 + t * dx;
      const projY = y1 + t * dy;
      return distanceSquared(px, py, projX, projY) <= padding * padding;
    };

    const getOverlayRouteAtCanvasPoint = (canvasX, canvasY) => {
      if (!overlayInteractionEntries.length) {
        return null;
      }

      for (let index = overlayInteractionEntries.length - 1; index >= 0; index -= 1) {
        const entry = overlayInteractionEntries[index];
        if (!entry || !entry.routeKey) {
          continue;
        }

        if (entry.type === 'circle') {
          const radius = Number(entry.radius) || 0;
          if (radius > 0) {
            const distance = distanceSquared(canvasX, canvasY, Number(entry.cx), Number(entry.cy));
            if (distance <= radius * radius) {
              return {
                routeKey: entry.routeKey,
                canvasX: entry.cx,
                canvasY: entry.cy,
                route: routesCache.get(entry.routeKey) || null,
              };
            }
          }
        } else if (entry.type === 'rect') {
          const left = Number(entry.left);
          const right = Number(entry.right);
          const top = Number(entry.top);
          const bottom = Number(entry.bottom);
          if (canvasX >= left && canvasX <= right && canvasY >= top && canvasY <= bottom) {
            return {
              routeKey: entry.routeKey,
              canvasX: (left + right) / 2,
              canvasY: (top + bottom) / 2,
              route: routesCache.get(entry.routeKey) || null,
            };
          }
        } else if (entry.type === 'segment') {
          const padding = Number(entry.padding) || 0;
          const x1 = Number(entry.x1);
          const y1 = Number(entry.y1);
          const x2 = Number(entry.x2);
          const y2 = Number(entry.y2);
          if (isPointNearSegment(canvasX, canvasY, x1, y1, x2, y2, padding)) {
            return {
              routeKey: entry.routeKey,
              canvasX: (x1 + x2) / 2,
              canvasY: (y1 + y2) / 2,
              route: routesCache.get(entry.routeKey) || null,
            };
          }
        }
      }

      return null;
    };

    const setFocusedRouteKey = (routeKey) => {
      const normalizedKey = typeof routeKey === 'string' ? routeKey : '';
      if (focusedRouteKey === normalizedKey) {
        updateClearFocusButton();
        return;
      }

      focusedRouteKey = normalizedKey;
      updateClearFocusButton();
      redraw();
    };

    const clearRouteFocus = () => {
      if (!focusedRouteKey) {
        return;
      }

      focusedRouteKey = '';
      resetLastFocusActivation();
      updateClearFocusButton();
      redraw();
    };

    const handlePotentialOverlayFocus = (event) => {
      if (!canvas) {
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const canvasX = event.clientX - rect.left;
      const canvasY = event.clientY - rect.top;

      if (!Number.isFinite(canvasX) || !Number.isFinite(canvasY)) {
        resetLastFocusActivation();
        return;
      }

      const entry = getOverlayRouteAtCanvasPoint(canvasX, canvasY);
      if (!entry || !entry.routeKey) {
        resetLastFocusActivation();
        return;
      }

      const shouldFocusRoute = shouldFocusFromInteraction(event, {
        routeKey: entry.routeKey,
        canvasX: entry.canvasX,
        canvasY: entry.canvasY,
      });

      if (shouldFocusRoute) {
        setFocusedRouteKey(entry.routeKey);
      }
    };

    updateClearFocusButton();

    const updatePanelToggleState = () => {
      if (!panelToggleButton || !controlPanel) {
        return;
      }

      const expanded = controlPanel.getAttribute('data-expanded') !== 'false';
      const label = expanded ? 'Hide menu' : 'Show menu';
      const pressed = !expanded;
      panelToggleButton.setAttribute('aria-label', label);
      panelToggleButton.setAttribute('title', label);
      panelToggleButton.setAttribute('aria-pressed', String(pressed));
      const srTarget = panelToggleButton.querySelector('.sr-only');
      if (srTarget) {
        srTarget.textContent = label;
      }
    };

    const setPanelExpanded = (value) => {
      if (!controlPanel) {
        return;
      }

      const expanded = Boolean(value);
      controlPanel.setAttribute('data-expanded', String(expanded));
      updatePanelToggleState();
      updateHelpTooltips();
    };

    if (controlPanel) {
      const initialExpanded = controlPanel.getAttribute('data-expanded') !== 'false';
      setPanelExpanded(initialExpanded);
      updatePanelMeasurements();

      window.addEventListener('resize', updatePanelMeasurements);

      if ('ResizeObserver' in window && panelSidebar) {
        const resizeObserver = new ResizeObserver(updatePanelMeasurements);
        resizeObserver.observe(panelSidebar);
      }
    }

    if (panelToggleButton) {
      panelToggleButton.addEventListener('click', () => {
        const isExpanded = controlPanel?.getAttribute('data-expanded') !== 'false';
        setPanelExpanded(!isExpanded);
        requestAnimationFrame(updatePanelMeasurements);
      });
    }

    if (infoButton && infoPopover) {
      infoButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (infoModeActive) {
          deactivateInfoMode({ clearTooltip: true });
        } else {
          activateInfoMode();
        }
      });

      infoPopover.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      if (startTutorialButton) {
        startTutorialButton.addEventListener('click', async (event) => {
          event.preventDefault();
          event.stopPropagation();
          cancelTutorialAutostart();
          deactivateInfoMode({ clearTooltip: true });
          const started = await startTutorial({ force: true });
          if (!started) {
            scheduleTutorialAutostart();
          }
        });
      }
    }

    document.addEventListener(
      'click',
      (event) => {
        if (!infoModeActive || !awaitingHelpTargetSelection) {
          return;
        }

        const target = event.target instanceof Element ? event.target : null;
        if (!target) {
          deactivateInfoMode({ clearTooltip: true });
          return;
        }

        if ((infoButton && infoButton.contains(target)) || (infoPopover && infoPopover.contains(target))) {
          return;
        }

        const helpElement = target.closest('[data-help-text]');
        if (helpElement) {
          event.preventDefault();
          event.stopPropagation();
          const entry = showHelpTooltipForElement(helpElement);
          deactivateInfoMode({ clearTooltip: !entry });
        } else {
          deactivateInfoMode({ clearTooltip: true });
        }
      },
      true,
    );

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        if (infoModeActive) {
          deactivateInfoMode({ clearTooltip: true });
          if (infoButton) {
            infoButton.focus();
          }
        } else if (activeHelpEntry) {
          clearActiveHelpTooltip();
          if (infoButton) {
            infoButton.focus();
          }
        }
      }
    });

    renderLocationOptions();
    updateWallVisibilityControls();

    if (tabButtons.length) {
      tabButtons.forEach((button) => {
        if (!button) {
          return;
        }
        button.addEventListener('click', () => {
          const targetId = button.dataset?.target;
          const expanded = controlPanel
            ? controlPanel.getAttribute('data-expanded') !== 'false'
            : false;
          const isActive = button.getAttribute('aria-selected') === 'true';

          if (isActive && expanded) {
            setPanelExpanded(false);
            requestAnimationFrame(updatePanelMeasurements);
            return;
          }

          if (!expanded) {
            setPanelExpanded(true);
            requestAnimationFrame(updatePanelMeasurements);
          }

          if (targetId) {
            activateTab(targetId);
          }
        });
      });
    }

    activateTab('routesTab');

    const wallKeyFromQuery = getWallKeyFromQuery();
    let initialLocation = wallKeyFromQuery
      ? findLocationByKey(wallKeyFromQuery) || findLocationByName(wallKeyFromQuery)
      : null;

    let storedLocationKey = null;
    if (!initialLocation) {
      try {
        storedLocationKey = window.localStorage?.getItem(LOCATION_STORAGE_KEY) || null;
      } catch (error) {
        console.warn('Unable to read setter location preference:', error);
      }

      if (storedLocationKey) {
        const normalizedStoredKey = normalizeWallKey(storedLocationKey);
        initialLocation =
          findLocationByKey(normalizedStoredKey) || findLocationByName(normalizedStoredKey);
      }
    }

    if (!initialLocation) {
      initialLocation = DEFAULT_LOCATION;
    }

    setLocation(initialLocation, { persist: true, refreshRoutes: false });

    if (locationButton) {
      locationButton.setAttribute('aria-expanded', 'false');
    }

    if (locationButton) {
      locationButton.addEventListener('click', (event) => {
        event.preventDefault();
        openLocationModal();
      });
    }

    if (wallVisibilityToggle) {
      wallVisibilityToggle.addEventListener('change', (event) => {
        applyWallVisibilityChange(event.target.checked).catch((error) => {
          console.error('Failed to update wall visibility:', error);
        });
      });
    }

    if (locationModalClose) {
      locationModalClose.addEventListener('click', (event) => {
        event.preventDefault();
        closeLocationModal();
      });
    }

    if (locationModal) {
      locationModal.addEventListener('click', (event) => {
        if (event.target === locationModal) {
          closeLocationModal();
        }
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        closeLocationModal();
      }
    });

    const wheelCtx = colorWheelCanvas ? colorWheelCanvas.getContext('2d') : null;

    if (colorWheelCanvas) {
      const baseSize = 220;
      const ratio = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      colorWheelCanvas.width = Math.round(baseSize * ratio);
      colorWheelCanvas.height = Math.round(baseSize * ratio);
    }

    function hslToRgb(h, s, l) {
      let r;
      let g;
      let b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hueToRgb = (p, q, t) => {
          let temp = t;
          if (temp < 0) temp += 1;
          if (temp > 1) temp -= 1;
          if (temp < 1 / 6) return p + (q - p) * 6 * temp;
          if (temp < 1 / 2) return q;
          if (temp < 2 / 3) return p + (q - p) * (2 / 3 - temp) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function hslToHex(h, s, l) {
      const [r, g, b] = hslToRgb((h % 360 + 360) % 360 / 360, s, l);
      return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    function rgbToHsl(r, g, b) {
      const red = r / 255;
      const green = g / 255;
      const blue = b / 255;
      const max = Math.max(red, green, blue);
      const min = Math.min(red, green, blue);
      let h = 0;
      let s = 0;
      const l = (max + min) / 2;

      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case red:
            h = (green - blue) / d + (green < blue ? 6 : 0);
            break;
          case green:
            h = (blue - red) / d + 2;
            break;
          default:
            h = (red - green) / d + 4;
            break;
        }
        h /= 6;
      }

      return { h: h * 360, s, l };
    }

    function hexToHsl(value) {
      if (typeof value !== 'string') {
        return { h: wheelHue, s: wheelSaturation, l: wheelLightness };
      }

      const match = value.trim().match(/^#?([0-9a-f]{6})$/i);
      if (!match) {
        return { h: wheelHue, s: wheelSaturation, l: wheelLightness };
      }

      const hex = match[1];
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      return rgbToHsl(r, g, b);
    }

    function drawColorWheel(lightness = wheelLightness) {
      if (!wheelCtx || !colorWheelCanvas) {
        return;
      }

      const { width, height } = colorWheelCanvas;
      const imageData = wheelCtx.createImageData(width, height);
      const { data } = imageData;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(centerX, centerY);

      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const index = (y * width + x) * 4;

          if (distance <= radius) {
            const hue = (Math.atan2(dy, dx) * 180) / Math.PI;
            const saturation = Math.min(1, distance / radius);
            const [r, g, b] = hslToRgb(((hue % 360) + 360) % 360 / 360, saturation, lightness);
            data[index] = r;
            data[index + 1] = g;
            data[index + 2] = b;
            data[index + 3] = 255;
          } else {
            data[index] = 0;
            data[index + 1] = 0;
            data[index + 2] = 0;
            data[index + 3] = 0;
          }
        }
      }

      wheelCtx.putImageData(imageData, 0, 0);
    }

    function updateColorWheelMarker() {
      if (!colorWheelMarker || !colorWheelCanvas) {
        return;
      }

      const radius = Math.min(colorWheelCanvas.width, colorWheelCanvas.height) / 2;
      const angle = (wheelHue * Math.PI) / 180;
      const markerRadius = wheelSaturation * radius;
      const x = radius + Math.cos(angle) * markerRadius;
      const y = radius + Math.sin(angle) * markerRadius;
      colorWheelMarker.style.left = `${x}px`;
      colorWheelMarker.style.top = `${y}px`;
    }

    function updateLightnessSliderGradient() {
      if (!colorLightnessSlider) {
        return;
      }

      const dark = hslToHex(wheelHue, wheelSaturation, 0);
      const mid = hslToHex(wheelHue, wheelSaturation, 0.5);
      const light = hslToHex(wheelHue, wheelSaturation, 1);
      colorLightnessSlider.style.background = `linear-gradient(90deg, ${dark}, ${mid}, ${light})`;
    }

    function updateAdvancedPreview(hex) {
      if (colorWheelValue) {
        colorWheelValue.textContent = hex.toUpperCase();
      }
      if (colorWheelSwatch) {
        colorWheelSwatch.style.background = hex;
      }
    }

    function setStrokeColorFromWheel(nextHue, nextSaturation, nextLightness, { quiet = false } = {}) {
      wheelHue = ((nextHue % 360) + 360) % 360;
      wheelSaturation = Math.min(Math.max(nextSaturation, 0), 1);
      wheelLightness = Math.min(Math.max(nextLightness, 0), 1);

      if (colorLightnessSlider) {
        const sliderValue = Math.round(wheelLightness * 100);
        if (Number.isFinite(sliderValue)) {
          colorLightnessSlider.value = String(sliderValue);
        }
      }

      updateColorWheelMarker();
      updateLightnessSliderGradient();

      const hex = sanitizeColor(hslToHex(wheelHue, wheelSaturation, wheelLightness));
      if (colorPicker && colorPicker.value !== hex) {
        colorPicker.value = hex;
      }
      updateAdvancedPreview(hex);

      if (strokeColor !== hex && !quiet) {
        strokeColor = hex;
        loadedNormalizedPoints = null;
        redraw();
        markUnsavedChange();
      } else if (strokeColor !== hex) {
        strokeColor = hex;
      }
    }

    function syncAdvancedColorPicker(color) {
      if (!colorWheelCanvas) {
        return;
      }

      const sanitized = sanitizeColor(color);
      const { h, s, l } = hexToHsl(sanitized);
      wheelHue = Number.isFinite(h) ? h : wheelHue;
      wheelSaturation = Number.isFinite(s) ? s : wheelSaturation;
      wheelLightness = Number.isFinite(l) ? l : wheelLightness;

      drawColorWheel(wheelLightness);
      updateColorWheelMarker();
      updateLightnessSliderGradient();

      if (colorLightnessSlider) {
        colorLightnessSlider.value = String(Math.round(wheelLightness * 100));
      }

      updateAdvancedPreview(sanitized);
    }

    function handleWheelSelection(clientX, clientY) {
      if (!colorWheelCanvas) {
        return;
      }

      const rect = colorWheelCanvas.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        return;
      }

      const scaleX = colorWheelCanvas.width / rect.width;
      const scaleY = colorWheelCanvas.height / rect.height;
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      const centerX = colorWheelCanvas.width / 2;
      const centerY = colorWheelCanvas.height / 2;
      let dx = x - centerX;
      let dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const radius = Math.min(centerX, centerY);

      if (distance > radius) {
        const ratio = radius / distance;
        dx *= ratio;
        dy *= ratio;
      }

      const hue = ((Math.atan2(dy, dx) * 180) / Math.PI + 360) % 360;
      const saturation = Math.min(1, Math.sqrt(dx * dx + dy * dy) / radius);
      setStrokeColorFromWheel(hue, saturation, wheelLightness);
    }

    if (advancedColorToggle && advancedColorPicker) {
      advancedColorToggle.addEventListener('click', () => {
        if (!advancedColorPicker) {
          return;
        }

        const isHidden = advancedColorPicker.classList.toggle('hidden');
        const expanded = !isHidden;
        advancedColorToggle.setAttribute('aria-expanded', String(expanded));
        advancedColorPicker.setAttribute('aria-hidden', String(!expanded));
        advancedColorToggle.textContent = expanded ? 'Hide colour wheel' : 'Open colour wheel';

        if (expanded) {
          drawColorWheel(wheelLightness);
          updateColorWheelMarker();
          updateLightnessSliderGradient();
        }

        updateHelpTooltips();
      });
    }

    if (colorWheelCanvas) {
      const normalizeEvent = (event) => {
        event.preventDefault();
        handleWheelSelection(event.clientX, event.clientY);
      };

      colorWheelCanvas.addEventListener('pointerdown', (event) => {
        isWheelPointerActive = true;
        if (typeof colorWheelCanvas.setPointerCapture === 'function') {
          colorWheelCanvas.setPointerCapture(event.pointerId);
        }
        if (document.activeElement !== colorWheelCanvas) {
          colorWheelCanvas.focus();
        }
        normalizeEvent(event);
      });

      colorWheelCanvas.addEventListener('pointermove', (event) => {
        if (!isWheelPointerActive) {
          return;
        }
        normalizeEvent(event);
      });

      const stopPointer = (event) => {
        if (
          typeof colorWheelCanvas.releasePointerCapture === 'function' &&
          colorWheelCanvas.hasPointerCapture(event.pointerId)
        ) {
          colorWheelCanvas.releasePointerCapture(event.pointerId);
        }
        isWheelPointerActive = false;
      };

      colorWheelCanvas.addEventListener('pointerup', stopPointer);
      colorWheelCanvas.addEventListener('pointercancel', stopPointer);
      colorWheelCanvas.addEventListener('pointerleave', () => {
        isWheelPointerActive = false;
      });

      colorWheelCanvas.addEventListener('keydown', (event) => {
        const hueStep = event.shiftKey ? 10 : 3;
        const satStep = event.shiftKey ? 0.05 : 0.02;
        let handled = true;

        switch (event.key) {
          case 'ArrowLeft':
            setStrokeColorFromWheel(wheelHue - hueStep, wheelSaturation, wheelLightness);
            break;
          case 'ArrowRight':
            setStrokeColorFromWheel(wheelHue + hueStep, wheelSaturation, wheelLightness);
            break;
          case 'ArrowUp':
            setStrokeColorFromWheel(wheelHue, Math.min(1, wheelSaturation + satStep), wheelLightness);
            break;
          case 'ArrowDown':
            setStrokeColorFromWheel(wheelHue, Math.max(0, wheelSaturation - satStep), wheelLightness);
            break;
          default:
            handled = false;
            break;
        }

        if (handled) {
          event.preventDefault();
        }
      });
    }

    if (colorLightnessSlider) {
      colorLightnessSlider.addEventListener('input', (event) => {
        const value = Number(event.target.value);
        if (!Number.isFinite(value)) {
          return;
        }

        const normalized = Math.min(Math.max(value, 0), 100) / 100;
        setStrokeColorFromWheel(wheelHue, wheelSaturation, normalized);
        drawColorWheel(wheelLightness);
      });
    }

    syncAdvancedColorPicker(strokeColor);

    if (climberViewButton) {
      climberViewButton.addEventListener('click', () => {
        const activeKey = getCurrentLocationKey();
        const targetHref = buildWallAwareHref(climberViewBaseHref, activeKey);
        const destination = targetHref || climberViewTargetHref || climberViewBaseHref;
        window.location.href = destination;
      });
    }

    if (personalDashboardButton) {
      personalDashboardButton.addEventListener('click', () => {
        window.location.href = 'personal.html';
      });
    }

    const ADMIN_CONSOLE_PATH = 'admin.html';

    if (adminConsoleButton) {
      adminConsoleButton.addEventListener('click', () => {
        if (adminConsoleButton.disabled) {
          return;
        }

        window.location.href = ADMIN_CONSOLE_PATH;
      });
    }

    function updateAdminConsoleAccess(role) {
      const normalized = typeof role === 'string' ? role.trim().toLowerCase() : '';
      const isAdmin = normalized === 'admin';

      if (adminConsoleButton) {
        adminConsoleButton.classList.toggle('hidden', !isAdmin);
        adminConsoleButton.disabled = !isAdmin;
      }

      if (!adminConsoleStatus) {
        return;
      }

      if (isAdmin) {
        adminConsoleStatus.textContent = 'Open the admin console to manage database operations.';
        adminConsoleStatus.dataset.variant = 'info';
        adminConsoleStatus.classList.remove('hidden');
        return;
      }

      adminConsoleStatus.textContent = '';
      adminConsoleStatus.classList.add('hidden');
      delete adminConsoleStatus.dataset.variant;
    }

    updateAdminConsoleAccess('');

    

    

    

    function normalizeDateValue(value) {
      if (!value) {
        return null;
      }

      if (typeof value === 'string') {
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date.toISOString();
      }

      if (value instanceof Date) {
        return Number.isNaN(value.getTime()) ? null : value.toISOString();
      }

      if (typeof value?.toDate === 'function') {
        const date = value.toDate();
        if (date instanceof Date && !Number.isNaN(date.getTime())) {
          return date.toISOString();
        }
        return null;
      }

      return null;
    }

    function isoStringToInputValue(isoString) {
      if (!isoString) {
        return '';
      }

      const date = new Date(isoString);
      if (Number.isNaN(date.getTime())) {
        return '';
      }

      const offset = date.getTimezoneOffset();
      const local = new Date(date.getTime() - offset * 60000);
      return local.toISOString().slice(0, 16);
    }

    function inputValueToIsoString(inputValue) {
      if (!inputValue) {
        return null;
      }

      const date = new Date(inputValue);
      if (Number.isNaN(date.getTime())) {
        return null;
      }

      return date.toISOString();
    }

    function getNowInputValue() {
      const now = new Date();
      const offset = now.getTimezoneOffset();
      const local = new Date(now.getTime() - offset * 60000);
      return local.toISOString().slice(0, 16);
    }

    function normalizeRouteData(raw = {}) {
      const normalizeRouteUid = (value) =>
        typeof value === 'string' && value.trim() ? value.trim() : '';
      const rawUid = normalizeRouteUid(raw?.uid);
      const rawId = normalizeRouteUid(raw?.id);
      const resolvedId = rawUid || rawId;
      const { date_removed: _unusedDateRemoved, ...rest } = raw || {};
      const rawLocation = typeof rest.location === 'string' ? rest.location.trim() : '';
      const locationName = rawLocation || DEFAULT_LOCATION?.name || '';
      const locationKey = normalizeLocationName(locationName);
      const normalizedPathType = normalizePathType(rest.pathType);
      const fallbackHollowPointDiameter = normalizePointDiameter(
        rest.hollowPointDiameter ?? rest.pointDiameter,
        DEFAULT_HOLLOW_POINT_DIAMETER,
      );
      const fallbackFilledPointDiameter = normalizePointDiameter(
        rest.filledPointDiameter ?? rest.pointDiameter,
        DEFAULT_FILLED_POINT_DIAMETER,
      );
      const fallbackPointDiameter = fallbackHollowPointDiameter;
      const fallbackRectangleWidth = normalizeRectangleSize(
        rest.rectangleWidth,
        DEFAULT_RECTANGLE_WIDTH,
      );
      const fallbackRectangleHeight = normalizeRectangleSize(
        rest.rectangleHeight,
        DEFAULT_RECTANGLE_HEIGHT,
      );
      const fallbackBrezerStrokeWidth = normalizeBrezerStrokeWidth(rest.brezerStrokeWidth);
      const gradeBarBaseHeight = normalizeGradeBarHeight(
        rest.gradeBarBaseHeight,
        DEFAULT_GRADE_BAR_BASE_HEIGHT,
      );
      const gradeBarMaxHeight = Math.max(
        gradeBarBaseHeight,
        normalizeGradeBarHeight(rest.gradeBarMaxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
      );
      const gradeBarWidth = normalizeGradeBarWidth(rest.gradeBarWidth);
      const gradeBarTransparency = normalizeGradeBarTransparency(
        rest.gradeBarTransparency ?? rest.transparency,
      );
      const wallSettings = getWallSettingsWithFallback(locationKey, {
        pointDiameter: fallbackPointDiameter,
        hollowPointDiameter: fallbackHollowPointDiameter,
        filledPointDiameter: fallbackFilledPointDiameter,
        rectangleWidth: fallbackRectangleWidth,
        rectangleHeight: fallbackRectangleHeight,
        brezerStrokeWidth: fallbackBrezerStrokeWidth,
        gradeBarBaseHeight,
        gradeBarMaxHeight,
        gradeBarWidth,
        gradeBarTransparency,
      });
      const medianFromCache = resolvedId ? routeMedianGrades.get(resolvedId) : undefined;
      const rawMedianGrade =
        typeof rest.medianGrade === 'number' && Number.isFinite(rest.medianGrade)
          ? rest.medianGrade
          : medianFromCache;
      const medianGrade =
        typeof rawMedianGrade === 'number' && Number.isFinite(rawMedianGrade)
          ? Math.min(Math.max(rawMedianGrade, MIN_GRADE_VALUE), MAX_GRADE_VALUE)
          : null;
      let pointsSource = rest.points;
      if (
        rest.pointsByType instanceof Map ||
        (rest.pointsByType && typeof rest.pointsByType === 'object' && !Array.isArray(rest.pointsByType))
      ) {
        pointsSource = rest.pointsByType;
      }

      const { pointsByType, activePoints } = normalizeRoutePoints(
        pointsSource,
        normalizedPathType,
      );

      const usersMap = normalizeRouteUsers(rest.users);

      return {
        id: resolvedId,
        uid: resolvedId,
        ...rest,
        setter: normalizeSetterName(rest.setter),
        title: typeof rest.title === 'string' ? rest.title.trim() : '',
        description: typeof rest.description === 'string' ? rest.description.trim() : '',
        strokeColor: sanitizeColor(rest.strokeColor),
        pathType: normalizedPathType,
        pointDiameter: wallSettings.hollowPointDiameter ?? wallSettings.pointDiameter,
        hollowPointDiameter: wallSettings.hollowPointDiameter ?? wallSettings.pointDiameter,
        filledPointDiameter: wallSettings.filledPointDiameter ?? wallSettings.pointDiameter,
        rectangleWidth: wallSettings.rectangleWidth,
        rectangleHeight: wallSettings.rectangleHeight,
        brezerStrokeWidth: wallSettings.brezerStrokeWidth,
        gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
        gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
        gradeBarWidth: wallSettings.gradeBarWidth,
        gradeBarTransparency: wallSettings.gradeBarTransparency,
        points: activePoints,
        pointsByType,
        users: usersMap,
        date_set: normalizeDateValue(rest.date_set),
        location: locationName,
        locationKey,
        medianGrade,
        hiddenFromClimbers: rest.hiddenFromClimbers === true,
      };
    }

      function calculateMedian(values = []) {
        if (!Array.isArray(values) || !values.length) {
          return null;
        }

        const sorted = values
          .filter((value) => typeof value === 'number' && Number.isFinite(value))
          .sort((a, b) => a - b);

        if (!sorted.length) {
          return null;
        }

        const mid = Math.floor(sorted.length / 2);
        if (sorted.length % 2 === 0) {
          return (sorted[mid - 1] + sorted[mid]) / 2;
        }
        return sorted[mid];
      }

      function sanitizeNormalizedPoint(point) {
        const x = Number(point?.x);
        const y = Number(point?.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          return null;
        }
        return { x, y };
      }

      function sanitizeNormalizedPointsArray(rawPoints) {
        if (Array.isArray(rawPoints)) {
          return rawPoints.map(sanitizeNormalizedPoint).filter(Boolean);
        }

        if (rawPoints && typeof rawPoints === 'object' && rawPoints !== null) {
          return Object.values(rawPoints).map(sanitizeNormalizedPoint).filter(Boolean);
        }

        return [];
      }

      function normalizeRoutePoints(rawPoints, activePathType) {
        const normalizedActiveType = normalizePathType(activePathType);
        const pointsByType = new Map();

        if (rawPoints instanceof Map) {
          rawPoints.forEach((value, key) => {
            const normalizedKey = normalizePathType(key);
            if (!normalizedKey) {
              return;
            }
            pointsByType.set(normalizedKey, sanitizeNormalizedPointsArray(value));
          });
        } else if (rawPoints && typeof rawPoints === 'object' && !Array.isArray(rawPoints)) {
          Object.entries(rawPoints).forEach(([key, value]) => {
            const normalizedKey = normalizePathType(key);
            if (!normalizedKey) {
              return;
            }
            pointsByType.set(normalizedKey, sanitizeNormalizedPointsArray(value));
          });
        } else if (Array.isArray(rawPoints)) {
          pointsByType.set(normalizedActiveType, sanitizeNormalizedPointsArray(rawPoints));
        }

        if (!pointsByType.has(normalizedActiveType)) {
          pointsByType.set(normalizedActiveType, []);
        }

        return {
          pointsByType,
          activePoints: pointsByType.get(normalizedActiveType) || [],
        };
      }

      function collectRoutePointEntries(routeData) {
        const entries = [];
        if (!routeData) {
          return entries;
        }

        const appendEntry = (pathTypeKey, pointsValue) => {
          const normalizedType = normalizePathType(pathTypeKey);
          if (!normalizedType) {
            return;
          }

          const normalizedPoints = sanitizeNormalizedPointsArray(pointsValue);
          if (!Array.isArray(normalizedPoints) || !normalizedPoints.length) {
            return;
          }

          entries.push({
            pathType: normalizedType,
            normalizedPoints,
          });
        };

        const { pointsByType } = routeData;
        if (pointsByType instanceof Map) {
          pointsByType.forEach((value, key) => appendEntry(key, value));
        } else if (pointsByType && typeof pointsByType === 'object' && !Array.isArray(pointsByType)) {
          Object.entries(pointsByType).forEach(([key, value]) => appendEntry(key, value));
        }

        if (!entries.length) {
          appendEntry(routeData.pathType, routeData.points);
        }

        return entries;
      }

      function serialiseNormalizedPointsByType(pointsByType) {
        const payload = {};
        if (!(pointsByType instanceof Map)) {
          return payload;
        }

        pointsByType.forEach((pointsArray, key) => {
          if (!key || !Array.isArray(pointsArray)) {
            return;
          }
          const sanitized = pointsArray
            .map((point) => sanitizeNormalizedPoint(point))
            .filter(Boolean)
            .map(({ x, y }) => ({
              x: Number(x),
              y: Number(y),
            }));

          payload[key] = sanitized;
        });

        return payload;
      }

      function sanitizeUsersForPersistence(rawUsers) {
        const sanitized = {};

        if (!rawUsers || typeof rawUsers !== 'object') {
          return sanitized;
        }

        if (rawUsers instanceof Map) {
          rawUsers.forEach((details, username) => {
            if (!isValidUsername(username)) {
              return;
            }
            const normalizedUsername = normalizeUsername(username);
            if (!normalizedUsername) {
              return;
            }
            sanitized[normalizedUsername] = sanitizeUserEntry(details);
          });
          return sanitized;
        }

        Object.entries(rawUsers).forEach(([username, details]) => {
          if (!isValidUsername(username)) {
            return;
          }

          const normalizedUsername = normalizeUsername(username);
          if (!normalizedUsername) {
            return;
          }

          sanitized[normalizedUsername] = sanitizeUserEntry(details);
        });

        return sanitized;
      }

      function sanitizeUserEntry(details) {
        const normalizedDetails =
          details && typeof details === 'object' ? details : {};

        const normalizedGrade = normalizeGradeValue(normalizedDetails.grade);
        let ascendedValue = null;
        if (normalizedDetails.ascended === true) {
          ascendedValue = true;
        } else if (normalizedDetails.ascended === false) {
          ascendedValue = false;
        }

        const betatipValue =
          typeof normalizedDetails.betatip === 'string'
            ? normalizedDetails.betatip.replace(/\r\n/g, '\n').trim()
            : null;

        return {
          grade: normalizedGrade,
          ascended: ascendedValue,
          betatip: betatipValue || null,
        };
      }

      function normalizeRouteUsers(rawUsers) {
        const map = new Map();
        if (!rawUsers || typeof rawUsers !== 'object') {
          return map;
        }

        if (rawUsers instanceof Map) {
          rawUsers.forEach((details, username) => {
            if (!isValidUsername(username)) {
              return;
            }
            const normalizedUsername = normalizeUsername(username);
            if (!normalizedUsername) {
              return;
            }
            map.set(normalizedUsername, sanitizeUserEntry(details));
          });
          return map;
        }

        Object.entries(rawUsers).forEach(([username, details]) => {
          if (!isValidUsername(username)) {
            return;
          }

          const normalizedUsername = normalizeUsername(username);
          if (!normalizedUsername) {
            return;
          }

          map.set(normalizedUsername, sanitizeUserEntry(details));
        });

        return map;
      }

      async function fetchMedianGrades() {
        const medianMap = new Map();

        try {
          const snapshot = await getDocs(collection(db, 'routes'));

          snapshot.forEach((docSnap) => {
          const data = docSnap.data() ?? {};
          const routeUid =
            typeof data.uid === 'string' && data.uid.trim() ? data.uid.trim() : docSnap.id;
          const userEntries = normalizeRouteUsers(data.users);

            if (!(userEntries instanceof Map) || userEntries.size === 0) {
              return;
            }

            const grades = [];
            userEntries.forEach((entry) => {
              const grade = normalizeGradeValue(entry?.grade);
              if (grade !== null) {
                grades.push(grade);
              }
            });

            if (!grades.length) {
              return;
            }

            const median = calculateMedian(grades);
            if (median !== null) {
              medianMap.set(routeUid, median);
            }
          });
        } catch (error) {
          console.warn('Failed to load median grades:', error);
        }

        return medianMap;
      }

    function generateRouteUid() {
      if (typeof crypto !== 'undefined') {
        if (typeof crypto.randomUUID === 'function') {
          return crypto.randomUUID();
        }

        if (typeof crypto.getRandomValues === 'function') {
          const buffer = new Uint32Array(4);
          crypto.getRandomValues(buffer);
          return Array.from(buffer)
            .map((value) => value.toString(16).padStart(8, '0'))
            .join('');
        }
      }

      const timestamp = Date.now().toString(36);
      const random = Math.random().toString(36).slice(2, 10);
      return `route-${timestamp}-${random}`;
    }

    function findConflictingRouteKey(title, excludeKey = '') {
      if (typeof title !== 'string') {
        return null;
      }

      const target = title.trim().toLowerCase();
      if (!target) {
        return null;
      }

      for (const [key, data] of routesCache.entries()) {
        if (key === excludeKey) {
          continue;
        }

        const existingTitle = (data?.title || key).trim().toLowerCase();
        if (existingTitle === target) {
          return key;
        }
      }

      return null;
    }

    function setStatus(message, variant = 'info') {
      if (!routeStatus) {
        return;
      }
      if (!message) {
        clearStatus();
        return;
      }
      routeStatus.textContent = message;
      routeStatus.classList.remove('hidden');
      if (variant) {
        routeStatus.dataset.variant = variant;
      } else {
        delete routeStatus.dataset.variant;
      }
    }

    function clearStatus() {
      if (!routeStatus) {
        return;
      }
      routeStatus.textContent = '';
      routeStatus.classList.add('hidden');
      delete routeStatus.dataset.variant;
    }

    function setCreateWallStatusMessage(message, variant = 'info') {
      if (!createWallStatus) {
        return;
      }
      if (!message) {
        clearCreateWallStatusMessage();
        return;
      }
      createWallStatus.textContent = message;
      createWallStatus.classList.remove('hidden');
      if (variant) {
        createWallStatus.dataset.variant = variant;
      } else {
        delete createWallStatus.dataset.variant;
      }
    }

    function clearCreateWallStatusMessage() {
      if (!createWallStatus) {
        return;
      }
      createWallStatus.textContent = '';
      createWallStatus.classList.add('hidden');
      delete createWallStatus.dataset.variant;
    }

    

    

    

    

    

    

    

    

    function markUnsavedChange() {
      if (!hasUnsavedChanges) {
        hasUnsavedChanges = true;
        setStatus('Unsaved changes – remember to save.', 'info');
      }
    }

    function resetUnsavedState() {
      hasUnsavedChanges = false;
    }

    function updatePathControls() {
      if (pathTypeSelect) {
        pathTypeSelect.value = pathType;
      }
      if (hollowPointDiameterSlider) {
        hollowPointDiameterSlider.value = String(pointDiameter);
      }
      if (hollowPointDiameterValue) {
        hollowPointDiameterValue.textContent = `${pointDiameter}px`;
      }
      if (filledPointDiameterSlider) {
        filledPointDiameterSlider.value = String(filledPointDiameter);
      }
      if (filledPointDiameterValue) {
        filledPointDiameterValue.textContent = `${filledPointDiameter}px`;
      }
      if (rectangleWidthSlider) {
        rectangleWidthSlider.value = String(rectangleWidth);
      }
      if (rectangleWidthValue) {
        rectangleWidthValue.textContent = `${rectangleWidth}px`;
      }
      if (rectangleHeightSlider) {
        rectangleHeightSlider.value = String(rectangleHeight);
      }
      if (rectangleHeightValue) {
        rectangleHeightValue.textContent = `${rectangleHeight}px`;
      }
      if (brezerStrokeWidthSlider) {
        brezerStrokeWidthSlider.value = String(brezerStrokeWidth);
      }
      if (brezerStrokeWidthValue) {
        brezerStrokeWidthValue.textContent = `${brezerStrokeWidth}px`;
      }
      if (unfocusedTransparencySlider) {
        unfocusedTransparencySlider.value = String(
          convertUnfocusedTransparencyToSliderValue(unfocusedTransparency),
        );
      }
    }

    function updateAppearanceControls() {
      if (gradeBarBaseHeightInput) {
        gradeBarBaseHeightInput.value = String(gradeBarBaseHeight);
      }
      if (gradeBarMaxHeightInput) {
        gradeBarMaxHeightInput.value = String(gradeBarMaxHeight);
      }
      if (gradeBarWidthInput) {
        gradeBarWidthInput.value = String(gradeBarWidth);
      }
      if (gradeBarTransparencyInput) {
        gradeBarTransparencyInput.value = String(gradeBarTransparency);
      }
    }

    const DEFAULT_CANVAS_ASPECT_RATIO = 1536 / 1024;
    let canvasAspectRatio = DEFAULT_CANVAS_ASPECT_RATIO;

    function computeCanvasDimensions() {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const aspectRatio = Number.isFinite(canvasAspectRatio) && canvasAspectRatio > 0
        ? canvasAspectRatio
        : DEFAULT_CANVAS_ASPECT_RATIO;
      const enableScroll = viewportWidth <= 768 && viewportHeight > viewportWidth;

      if (enableScroll) {
        const height = viewportHeight;
        const width = Math.max(viewportWidth, Math.round(height * aspectRatio));
        return { width, height, enableScroll };
      }

      return {
        width: viewportWidth,
        height: viewportHeight,
        enableScroll: false,
      };
    }

    function resizeCanvas() {
      const previousWidth = canvas.width || 0;
      const previousHeight = canvas.height || 0;
      const { width, height, enableScroll } = computeCanvasDimensions();

      if (canvasContainer) {
        canvasContainer.classList.toggle('scrollable', enableScroll);
      }

      canvas.width = width;
      canvas.height = height;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;

      if (canvasContainer) {
        if (enableScroll) {
          const maxScrollLeft = Math.max(0, width - window.innerWidth);
          if (!isCanvasScrollable) {
            canvasContainer.scrollLeft = Math.max(0, maxScrollLeft / 2);
          } else if (canvasContainer.scrollLeft > maxScrollLeft) {
            canvasContainer.scrollLeft = maxScrollLeft;
          }
        } else if (isCanvasScrollable) {
          canvasContainer.scrollLeft = 0;
        }
      }

      const safePreviousWidth = previousWidth || width;
      const safePreviousHeight = previousHeight || height;

      if (loadedNormalizedPoints) {
        points.length = 0;
        loadedNormalizedPoints.forEach(({ x, y }) => {
          if (Number.isFinite(x) && Number.isFinite(y)) {
            points.push({ x: x * canvas.width, y: y * canvas.height });
          }
        });
      } else if (points.length && safePreviousWidth && safePreviousHeight) {
        const scaledPoints = points.map(({ x, y }) => ({
          x: (x / safePreviousWidth) * canvas.width,
          y: (y / safePreviousHeight) * canvas.height,
        }));
        points.length = 0;
        points.push(...scaledPoints);
      }

      isCanvasScrollable = enableScroll;
      redraw();
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (backgroundReady && backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      queuedGradeBarOverlays = [];
      drawExistingRoutesOverlay();
      drawStoredPathPreviews();
      const activePointDiameter = getStatePointDiameterForPathType(pathType);
      drawRouteFromCanvasPoints(
        points,
        strokeColor,
        1,
        pathType,
        activePointDiameter,
        rectangleWidth,
        rectangleHeight,
        brezerStrokeWidth,
      );
      if (points.length) {
        queueGradeBarOverlay({
          routePoints: points,
          color: strokeColor,
          alpha: 1,
          medianGrade: currentRouteMedianGrade,
          baseHeight: gradeBarBaseHeight,
          maxHeight: gradeBarMaxHeight,
          width: gradeBarWidth,
          transparency: gradeBarTransparency,
          isAscended: false,
        });
      }
      renderQueuedGradeBarOverlays();
    }

    function drawStoredPathPreviews() {
      if (!(normalizedPointsByPathType instanceof Map) || !normalizedPointsByPathType.size) {
        return;
      }

      const activeType = normalizePathType(pathType);
      normalizedPointsByPathType.forEach((value, type) => {
        const normalizedType = normalizePathType(type);
        if (!normalizedType || normalizedType === activeType) {
          return;
        }

        const normalizedPoints = sanitizeNormalizedPointsArray(value);
        if (!Array.isArray(normalizedPoints) || !normalizedPoints.length) {
          return;
        }

        normalizedPointsByPathType.set(normalizedType, normalizedPoints);

        const canvasPoints = convertNormalizedToCanvasPoints(normalizedPoints);
        if (!Array.isArray(canvasPoints) || !canvasPoints.length) {
          return;
        }

        const previewPointDiameter = getStatePointDiameterForPathType(normalizedType);
        drawRouteFromCanvasPoints(
          canvasPoints,
          strokeColor,
          0.7,
          normalizedType,
          previewPointDiameter,
          rectangleWidth,
          rectangleHeight,
          brezerStrokeWidth,
        );
      });
    }

    function clamp(value, min, max) {
      if (!Number.isFinite(value)) {
        return min;
      }
      if (value < min) {
        return min;
      }
      if (value > max) {
        return max;
      }
      return value;
    }

    function calculateAverageXFromCanvasPoints(routePoints = []) {
      if (!Array.isArray(routePoints) || !routePoints.length) {
        return null;
      }

      const valid = routePoints
        .map((point) => Number(point?.x))
        .filter((x) => Number.isFinite(x));

      if (!valid.length) {
        return null;
      }

      const sum = valid.reduce((total, x) => total + x, 0);
      return sum / valid.length;
    }

    function queueGradeBarOverlay() {
      queuedGradeBarOverlays = [];
    }

    function renderQueuedGradeBarOverlays() {
      queuedGradeBarOverlays = [];
    }

    function drawRouteFromCanvasPoints(
      routePoints = [],
      color = '#ffde59',
      alpha = 1,
      routePathType = DEFAULT_PATH_TYPE,
      routePointDiameter = DEFAULT_POINT_DIAMETER,
      routeRectangleWidth = DEFAULT_RECTANGLE_WIDTH,
      routeRectangleHeight = DEFAULT_RECTANGLE_HEIGHT,
      routeBrezerStrokeWidth = DEFAULT_BREZER_STROKE_WIDTH,
    ) {
      if (!Array.isArray(routePoints) || !routePoints.length) {
        return;
      }

      ctx.save();
      ctx.globalAlpha = alpha;

      const effectivePathType = normalizePathType(routePathType);
      const effectivePointDiameter = normalizePointDiameter(
        routePointDiameter,
        getDefaultPointDiameterForPathType(effectivePathType),
      );
      const effectiveRectangleWidth = normalizeRectangleSize(
        routeRectangleWidth,
        DEFAULT_RECTANGLE_WIDTH,
      );
      const effectiveRectangleHeight = normalizeRectangleSize(
        routeRectangleHeight,
        DEFAULT_RECTANGLE_HEIGHT,
      );

      if (effectivePathType === PATH_TYPE_BREZER) {
        const strokeWidth = normalizeBrezerStrokeWidth(routeBrezerStrokeWidth);
        if (routePoints.length >= 2) {
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = color;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(routePoints[0].x, routePoints[0].y);

          for (let i = 0; i < routePoints.length - 1; i++) {
            const p0 = i === 0 ? routePoints[0] : routePoints[i - 1];
            const p1 = routePoints[i];
            const p2 = routePoints[i + 1];
            const p3 = i + 2 < routePoints.length ? routePoints[i + 2] : routePoints[i + 1];

            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
          }

          ctx.stroke();
        }

        const anchorRadius = Math.max(2, Math.round(Math.max(strokeWidth, 2) / 3));
        ctx.fillStyle = color;
        routePoints.forEach((point) => {
          if (!point) {
            return;
          }
          ctx.beginPath();
          ctx.arc(point.x, point.y, anchorRadius, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.restore();
        return;
      }

      if (effectivePathType === PATH_TYPE_HOLLOW_POINT) {
        const radius = Math.max(1, effectivePointDiameter / 2);
        const strokeWidth = Math.max(2, Math.round(effectivePointDiameter / 10));
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = color;
        routePoints.forEach((point) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
          ctx.stroke();
        });
      } else if (effectivePathType === PATH_TYPE_FILLED_POINT) {
        const radius = Math.max(1, effectivePointDiameter / 2);
        ctx.fillStyle = color;
        routePoints.forEach((point) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
          ctx.fill();
        });
      } else if (effectivePathType === PATH_TYPE_RECTANGLE) {
        const halfWidth = Math.max(1, effectiveRectangleWidth / 2);
        const halfHeight = Math.max(1, effectiveRectangleHeight / 2);
        const strokeWidth = Math.max(
          2,
          Math.round(Math.max(effectiveRectangleWidth, effectiveRectangleHeight) / 10),
        );
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = color;
        routePoints.forEach((point) => {
          ctx.strokeRect(
            point.x - halfWidth,
            point.y - halfHeight,
            effectiveRectangleWidth,
            effectiveRectangleHeight,
          );
        });
      } else {
        ctx.fillStyle = color;
        routePoints.forEach((point) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, Math.max(1, effectivePointDiameter / 2), 0, Math.PI * 2);
          ctx.fill();
        });
      }

      ctx.restore();
    }

    function createNormalizedPointKey(x, y) {
      if (!Number.isFinite(x) || !Number.isFinite(y)) {
        return null;
      }

      const clampedX = Math.min(Math.max(x, 0), 1);
      const clampedY = Math.min(Math.max(y, 0), 1);
      const scaledX = Math.round(clampedX * 10000);
      const scaledY = Math.round(clampedY * 10000);
      return `${scaledX}:${scaledY}`;
    }

    function buildNormalizedPointKeySetFromCanvasPoints(canvasPoints = []) {
      const keys = new Set();
      if (!Array.isArray(canvasPoints) || !canvasPoints.length || !canvas.width || !canvas.height) {
        return keys;
      }

      const width = canvas.width;
      const height = canvas.height;

      canvasPoints.forEach((point) => {
        if (!point) {
          return;
        }

        const normalizedX = Number(point.x) / width;
        const normalizedY = Number(point.y) / height;
        const key = createNormalizedPointKey(normalizedX, normalizedY);
        if (key) {
          keys.add(key);
        }
      });

      return keys;
    }

    function convertNormalizedToCanvasPoints(normalizedPoints = []) {
      if (!Array.isArray(normalizedPoints) || !canvas.width || !canvas.height) {
        return [];
      }

      return normalizedPoints
        .map((point) => {
          const x = Number(point?.x);
          const y = Number(point?.y);
          if (Number.isFinite(x) && Number.isFinite(y)) {
            return { x: x * canvas.width, y: y * canvas.height };
          }
          return null;
        })
        .filter(Boolean);
    }

    function createOverlapGroupKey(pathTypeValue, pointKey) {
      if (!pathTypeValue || !pointKey) {
        return null;
      }
      return `${pathTypeValue}::${pointKey}`;
    }

    function buildOverlayOverlapGroups(routeEntries = []) {
      const groups = new Map();

      routeEntries.forEach((entry) => {
        if (!entry) {
          return;
        }

        const { pathType: pathTypeValue, normalizedPoints } = entry;
        if (
          (!isNormalizedPointPathType(pathTypeValue) && pathTypeValue !== PATH_TYPE_RECTANGLE) ||
          !Array.isArray(normalizedPoints) ||
          !normalizedPoints.length
        ) {
          return;
        }

        normalizedPoints.forEach((point) => {
          const normalizedX = Number(point?.x);
          const normalizedY = Number(point?.y);
          const key = createNormalizedPointKey(normalizedX, normalizedY);
          if (!key) {
            return;
          }

          const groupKey = createOverlapGroupKey(pathTypeValue, key);
          if (!groupKey) {
            return;
          }

          if (!groups.has(groupKey)) {
            groups.set(groupKey, {
              pathType: pathTypeValue,
              entries: [],
            });
          }

          const group = groups.get(groupKey);
          group.entries.push({
            routeId: entry.id,
            color: entry.color,
            pointDiameter: entry.pointDiameter,
            rectangleWidth: entry.rectangleWidth,
            rectangleHeight: entry.rectangleHeight,
            alpha: entry.alpha,
          });
        });
      });

      for (const [key, group] of groups) {
        if (!group || !Array.isArray(group.entries) || group.entries.length <= 1) {
          groups.delete(key);
        }
      }

      return groups;
    }

    function drawOverlayPointGroup(center, entries) {
      if (!center || !Array.isArray(entries) || entries.length <= 1) {
        return;
      }

      const total = entries.length;
      const radii = entries.map((entry) => Math.max(1, Number(entry.pointDiameter) / 2));
      const radius = Math.max(...radii, 4);
      const step = (Math.PI * 2) / total;
      const startAngle = -Math.PI / 2;

      ctx.save();
      ctx.setLineDash([]);
      ctx.lineCap = 'butt';
      ctx.lineJoin = 'miter';

      entries.forEach((entry, index) => {
        const strokeWidth = Math.max(2, Math.round(Number(entry.pointDiameter) / 10) || 2);
        const angleStart = startAngle + step * index;
        const angleEnd = angleStart + step;

        ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = entry.color || '#ffde59';
        ctx.beginPath();
        ctx.arc(center.x, center.y, radius, angleStart, angleEnd);
        ctx.stroke();
      });

      ctx.restore();
    }

    function drawOverlayRectangleGroup(center, width, height, entries) {
      if (!center || !Array.isArray(entries) || entries.length <= 1) {
        return;
      }

      const normalizedWidth = Math.max(...entries.map((entry) => Number(entry.rectangleWidth) || 0), width);
      const normalizedHeight = Math.max(
        ...entries.map((entry) => Number(entry.rectangleHeight) || 0),
        height,
      );
      const finalWidth = Math.max(1, normalizedWidth);
      const finalHeight = Math.max(1, normalizedHeight);
      const halfWidth = finalWidth / 2;
      const halfHeight = finalHeight / 2;
      const perimeter = 2 * (finalWidth + finalHeight);

      if (!Number.isFinite(perimeter) || perimeter <= 0) {
        return;
      }

      const segmentLength = perimeter / entries.length;
      const edges = [
        { length: finalWidth, startX: center.x - halfWidth, startY: center.y - halfHeight, dx: 1, dy: 0 },
        { length: finalHeight, startX: center.x + halfWidth, startY: center.y - halfHeight, dx: 0, dy: 1 },
        { length: finalWidth, startX: center.x + halfWidth, startY: center.y + halfHeight, dx: -1, dy: 0 },
        { length: finalHeight, startX: center.x - halfWidth, startY: center.y + halfHeight, dx: 0, dy: -1 },
      ];
      const edgeCount = edges.length;

      let offset = 0;

      entries.forEach((entry) => {
        let localOffset = offset % perimeter;
        if (localOffset < 0) {
          localOffset += perimeter;
        }

        let edgeIndex = 0;
        while (localOffset >= edges[edgeIndex].length && edgeIndex < edgeCount - 1) {
          localOffset -= edges[edgeIndex].length;
          edgeIndex += 1;
        }

        let currentX = edges[edgeIndex].startX + edges[edgeIndex].dx * localOffset;
        let currentY = edges[edgeIndex].startY + edges[edgeIndex].dy * localOffset;
        let remaining = segmentLength;

        ctx.save();
        ctx.setLineDash([]);
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.lineWidth = Math.max(
          2,
          Math.round(
            Math.max(Number(entry.rectangleWidth) || 0, Number(entry.rectangleHeight) || 0) / 10,
          ) || 2,
        );
        ctx.strokeStyle = entry.color || '#ffde59';
        ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;

        while (remaining > 0) {
          const edge = edges[edgeIndex];
          const available = edge.length - localOffset;
          const step = Math.min(remaining, available);
          const nextOffset = localOffset + step;
          const nextX = edge.startX + edge.dx * nextOffset;
          const nextY = edge.startY + edge.dy * nextOffset;

          ctx.beginPath();
          ctx.moveTo(currentX, currentY);
          ctx.lineTo(nextX, nextY);
          ctx.stroke();

          remaining -= step;
          currentX = nextX;
          currentY = nextY;
          localOffset = 0;
          edgeIndex = (edgeIndex + 1) % edgeCount;
        }

        ctx.restore();

        offset += segmentLength;
        if (offset >= perimeter) {
          offset -= perimeter;
        }
      });
    }

    function drawExistingRoutesOverlay() {
      if (!routesCache.size) {
        overlayInteractionEntries = [];
        if (focusedRouteKey) {
          focusedRouteKey = '';
          updateClearFocusButton();
          resetLastFocusActivation();
        }
        return;
      }

      const activeLocationKey = getCurrentLocationKey();
      const wallSettings = getWallSettingsForLocation(activeLocationKey);
      const overlayAlpha = normalizeUnfocusedTransparency(wallSettings.unfocusedTransparency);
      const focusPointKeys = points.length
        ? buildNormalizedPointKeySetFromCanvasPoints(points)
        : null;

      if (focusedRouteKey && !routesCache.has(focusedRouteKey)) {
        focusedRouteKey = '';
        updateClearFocusButton();
      }

      overlayInteractionEntries = [];

      const overlayEntries = [];

      routesCache.forEach((data, key) => {
        if (!data || key === currentRouteKey) {
          return;
        }

        const routeLocationKey =
          typeof data?.locationKey === 'string'
            ? data.locationKey
            : normalizeLocationName(data?.location);
        if (activeLocationKey && routeLocationKey !== activeLocationKey) {
          return;
        }

        const color = sanitizeColor(data.strokeColor);
        const normalizedRectangleWidth = normalizeRectangleSize(
          data.rectangleWidth,
          DEFAULT_RECTANGLE_WIDTH,
        );
        const normalizedRectangleHeight = normalizeRectangleSize(
          data.rectangleHeight,
          DEFAULT_RECTANGLE_HEIGHT,
        );
        const normalizedBrezerWidth = normalizeBrezerStrokeWidth(data.brezerStrokeWidth);

        const pointEntries = collectRoutePointEntries(data);
        pointEntries.forEach(({ pathType: entryPathType, normalizedPoints }) => {
          if (!Array.isArray(normalizedPoints) || !normalizedPoints.length) {
            return;
          }

          const canvasPoints = convertNormalizedToCanvasPoints(normalizedPoints);
          if (!canvasPoints.length) {
            return;
          }

          const entryPointDiameter = getRoutePointDiameterForPathType(data, entryPathType);
          overlayEntries.push({
            id: key,
            color,
            pathType: entryPathType,
            canvasPoints,
            normalizedPoints,
            pointDiameter: entryPointDiameter,
            brezerStrokeWidth: normalizedBrezerWidth,
            rectangleWidth: normalizedRectangleWidth,
            rectangleHeight: normalizedRectangleHeight,
            alpha: overlayAlpha,
            medianGrade: data.medianGrade,
            gradeBarBaseHeight: data.gradeBarBaseHeight,
            gradeBarMaxHeight: data.gradeBarMaxHeight,
            gradeBarWidth: data.gradeBarWidth,
            gradeBarTransparency: data.gradeBarTransparency,
          });
        });
      });

      if (!overlayEntries.length) {
        return;
      }

      const overlapGroups = buildOverlayOverlapGroups(overlayEntries);
      const handledOverlapKeys = new Set();

      overlayEntries.forEach((entry) => {
        const {
          color,
          pathType: routePathType,
          canvasPoints,
          normalizedPoints,
          pointDiameter: entryPointDiameter,
          rectangleWidth: entryRectangleWidth,
          rectangleHeight: entryRectangleHeight,
          alpha,
          medianGrade,
          gradeBarBaseHeight,
          gradeBarMaxHeight,
          gradeBarWidth,
          gradeBarTransparency,
        } = entry;

        const supportsPattern =
          isNormalizedPointPathType(routePathType) || routePathType === PATH_TYPE_RECTANGLE;
        const visiblePoints = [];
        const isFocused = !focusedRouteKey || entry.id === focusedRouteKey;
        const routeAlpha = isFocused ? 1 : alpha;

        if (Array.isArray(canvasPoints) && canvasPoints.length) {
          if (isNormalizedPointPathType(routePathType)) {
            const radius = Math.max(6, entryPointDiameter / 2);
            canvasPoints.forEach((point) => {
              if (!point) {
                return;
              }
              overlayInteractionEntries.push({
                type: 'circle',
                cx: point.x,
                cy: point.y,
                radius,
                routeKey: entry.id,
              });
            });
          } else if (routePathType === PATH_TYPE_RECTANGLE) {
            const halfWidth = Math.max(4, entryRectangleWidth / 2);
            const halfHeight = Math.max(4, entryRectangleHeight / 2);
            canvasPoints.forEach((point) => {
              if (!point) {
                return;
              }
              overlayInteractionEntries.push({
                type: 'rect',
                left: point.x - halfWidth,
                right: point.x + halfWidth,
                top: point.y - halfHeight,
                bottom: point.y + halfHeight,
                routeKey: entry.id,
              });
            });
          } else if (routePathType === PATH_TYPE_BREZER && canvasPoints.length >= 2) {
            const strokeWidth = normalizeBrezerStrokeWidth(entry.brezerStrokeWidth);
            const padding = Math.max(10, strokeWidth / 2);
            for (let i = 0; i < canvasPoints.length - 1; i += 1) {
              const start = canvasPoints[i];
              const end = canvasPoints[i + 1];
              if (!start || !end) {
                continue;
              }
              overlayInteractionEntries.push({
                type: 'segment',
                x1: start.x,
                y1: start.y,
                x2: end.x,
                y2: end.y,
                padding,
                routeKey: entry.id,
              });
            }
            canvasPoints.forEach((point) => {
              if (!point) {
                return;
              }
              overlayInteractionEntries.push({
                type: 'circle',
                cx: point.x,
                cy: point.y,
                radius: Math.max(6, strokeWidth / 2),
                routeKey: entry.id,
              });
            });
          }
        }

        canvasPoints.forEach((point, index) => {
          const normalized = Array.isArray(normalizedPoints) ? normalizedPoints[index] : null;
          const normalizedX = Number(normalized?.x);
          const normalizedY = Number(normalized?.y);
          const pointKey =
            supportsPattern && Number.isFinite(normalizedX) && Number.isFinite(normalizedY)
              ? createNormalizedPointKey(normalizedX, normalizedY)
              : null;

          if (
            supportsPattern &&
            focusPointKeys &&
            focusPointKeys.size > 0 &&
            pointKey &&
            focusPointKeys.has(pointKey)
          ) {
            return;
          }

          const overlapKey =
            pointKey && overlapGroups ? createOverlapGroupKey(routePathType, pointKey) : null;
          const overlapGroup =
            overlapKey && overlapGroups ? overlapGroups.get(overlapKey) : null;

          if (
            overlapGroup &&
            Array.isArray(overlapGroup.entries) &&
            overlapGroup.entries.length > 1 &&
            !focusPointKeys
          ) {
            if (handledOverlapKeys.has(overlapKey)) {
              return;
            }

            handledOverlapKeys.add(overlapKey);

            if (isNormalizedPointPathType(routePathType)) {
              drawOverlayPointGroup(point, overlapGroup.entries);
            } else if (routePathType === PATH_TYPE_RECTANGLE) {
              drawOverlayRectangleGroup(point, entryRectangleWidth, entryRectangleHeight, overlapGroup.entries);
            }
            return;
          }

          visiblePoints.push(point);
        });

        if (visiblePoints.length) {
          drawRouteFromCanvasPoints(
            visiblePoints,
            color,
            routeAlpha,
            routePathType,
            entryPointDiameter,
            entryRectangleWidth,
            entryRectangleHeight,
            entry.brezerStrokeWidth,
          );
        }

        queueGradeBarOverlay({
          routePoints: canvasPoints,
          color,
          alpha: routeAlpha,
          medianGrade,
          baseHeight: gradeBarBaseHeight,
          maxHeight: gradeBarMaxHeight,
          width: gradeBarWidth,
          transparency: gradeBarTransparency,
          isAscended: false,
        });
      });
    }

    function setCanvasPointsFromNormalized(normalizedPoints = []) {
      const target = Array.isArray(normalizedPoints)
        ? normalizedPoints.map((point) => ({ x: Number(point?.x), y: Number(point?.y) }))
        : [];

      const filtered = target.filter(
        ({ x, y }) => Number.isFinite(x) && Number.isFinite(y),
      );

      loadedNormalizedPoints = filtered;
      points.length = 0;
      filtered.forEach(({ x, y }) => {
        points.push({ x: x * canvas.width, y: y * canvas.height });
      });
      redraw();
    }

    function loadPointsForActivePathType() {
      const activeType = normalizePathType(pathType);
      const normalized = normalizedPointsByPathType.get(activeType) || [];
      const sanitized = sanitizeNormalizedPointsArray(normalized);
      normalizedPointsByPathType.set(activeType, sanitized);
      setCanvasPointsFromNormalized(sanitized);
    }

    function flushActivePointsToNormalized() {
      const activeType = normalizePathType(pathType);
      if (!activeType) {
        return [];
      }

      const normalized = convertPointsToNormalized();
      normalizedPointsByPathType.set(activeType, normalized);
      loadedNormalizedPoints = normalized;
      return normalized;
    }

    function synchroniseNormalizedPoints(pointsByType, activeType) {
      const normalizedActiveType = normalizePathType(activeType) || DEFAULT_PATH_TYPE;
      normalizedPointsByPathType.clear();

      const register = (type, value) => {
        const normalizedType = normalizePathType(type);
        if (!normalizedType) {
          return;
        }
        normalizedPointsByPathType.set(
          normalizedType,
          sanitizeNormalizedPointsArray(value),
        );
      };

      if (pointsByType instanceof Map) {
        pointsByType.forEach((value, key) => {
          register(key, value);
        });
      } else if (
        pointsByType &&
        typeof pointsByType === 'object' &&
        !Array.isArray(pointsByType)
      ) {
        Object.entries(pointsByType).forEach(([key, value]) => {
          register(key, value);
        });
      } else if (Array.isArray(pointsByType)) {
        register(normalizedActiveType, pointsByType);
      }

      if (!normalizedPointsByPathType.has(normalizedActiveType)) {
        normalizedPointsByPathType.set(normalizedActiveType, []);
      }

      loadPointsForActivePathType();
    }

    function convertPointsToNormalized() {
      if (!canvas.width || !canvas.height) {
        return [];
      }

      return points.map(({ x, y }) => ({
        x: Number((x / canvas.width).toFixed(6)),
        y: Number((y / canvas.height).toFixed(6)),
      }));
    }

    function getPointDetectionRadius(diameter) {
      const normalizedDiameter = normalizePointDiameter(diameter);
      return Math.max(6, normalizedDiameter / 2);
    }

    function getRectangleDetectionRadius(width, height) {
      const normalizedWidth = normalizeRectangleSize(width, DEFAULT_RECTANGLE_WIDTH);
      const normalizedHeight = normalizeRectangleSize(height, DEFAULT_RECTANGLE_HEIGHT);
      const halfWidth = Math.max(1, normalizedWidth / 2);
      const halfHeight = Math.max(1, normalizedHeight / 2);
      const diagonal = Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight);
      return Math.max(6, diagonal);
    }

    function findPointIndexNear(x, y, targetPoints = [], radius = 0) {
      if (!Array.isArray(targetPoints) || !targetPoints.length || radius <= 0) {
        return -1;
      }

      const radiusSq = radius * radius;
      for (let index = 0; index < targetPoints.length; index += 1) {
        const point = targetPoints[index];
        if (!point) {
          continue;
        }

        const dx = point.x - x;
        const dy = point.y - y;
        if (dx * dx + dy * dy <= radiusSq) {
          return index;
        }
      }

      return -1;
    }

    function findSharedPointNear(x, y) {
      if (!routesCache.size) {
        return null;
      }

      const activePathType = normalizePathType(pathType);
      if (!isNormalizedPointPathType(activePathType) && activePathType !== PATH_TYPE_RECTANGLE) {
        return null;
      }

      const activeLocationKey = getCurrentLocationKey();
      let closestPoint = null;
      let closestDistanceSq = Number.POSITIVE_INFINITY;
      const activeDetectionRadius =
        activePathType === PATH_TYPE_RECTANGLE
          ? getRectangleDetectionRadius(rectangleWidth, rectangleHeight)
          : getPointDetectionRadius(getStatePointDiameterForPathType(activePathType));

      routesCache.forEach((data, routeKey) => {
        if (!data || routeKey === currentRouteKey) {
          return;
        }

        const routeLocationKey = normalizeWallKey(
          typeof data?.locationKey === 'string'
            ? data.locationKey
            : normalizeLocationName(data?.location),
        );

        if (activeLocationKey && routeLocationKey !== activeLocationKey) {
          return;
        }

        if (normalizePathType(data.pathType) !== activePathType) {
          return;
        }

        let detectionRadius = activeDetectionRadius;

        if (isNormalizedPointPathType(activePathType)) {
          const routeDiameter = getRoutePointDiameterForPathType(data, activePathType);
          detectionRadius = Math.max(
            activeDetectionRadius,
            getPointDetectionRadius(routeDiameter),
          );
        } else {
          const routeWidth = normalizeRectangleSize(
            typeof data?.rectangleWidth === 'number' ? data.rectangleWidth : rectangleWidth,
            DEFAULT_RECTANGLE_WIDTH,
          );
          const routeHeight = normalizeRectangleSize(
            typeof data?.rectangleHeight === 'number' ? data.rectangleHeight : rectangleHeight,
            DEFAULT_RECTANGLE_HEIGHT,
          );
          detectionRadius = Math.max(
            activeDetectionRadius,
            getRectangleDetectionRadius(routeWidth, routeHeight),
          );
        }

        const detectionRadiusSq = detectionRadius * detectionRadius;
        const routePoints = convertNormalizedToCanvasPoints(data.points);

        routePoints.forEach((point) => {
          if (!point) {
            return;
          }

          const dx = point.x - x;
          const dy = point.y - y;
          const distanceSq = dx * dx + dy * dy;
          if (distanceSq <= detectionRadiusSq && distanceSq < closestDistanceSq) {
            closestDistanceSq = distanceSq;
            closestPoint = { x: point.x, y: point.y };
          }
        });
      });

      if (!closestPoint) {
        return null;
      }

      const existingIndex = findPointIndexNear(closestPoint.x, closestPoint.y, points, activeDetectionRadius);
      if (existingIndex >= 0) {
        return null;
      }

      return closestPoint;
    }

    function addPoint(event) {
      if (shouldIgnoreNextClick) {
        shouldIgnoreNextClick = false;
        return;
      }

      if (!isDrawingEnabled) {
        handlePotentialOverlayFocus(event);
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const currentPathType = normalizePathType(pathType);
      if (currentPathType === PATH_TYPE_BREZER) {
        const removalIndex = findPointIndexNear(x, y, points, BREZER_REMOVAL_RADIUS);
        if (removalIndex >= 0) {
          points.splice(removalIndex, 1);
          loadedNormalizedPoints = null;
          redraw();
          markUnsavedChange();
          return;
        }
      }
      if (isNormalizedPointPathType(currentPathType) || currentPathType === PATH_TYPE_RECTANGLE) {
        const detectionRadius =
          currentPathType === PATH_TYPE_RECTANGLE
            ? getRectangleDetectionRadius(rectangleWidth, rectangleHeight)
            : getPointDetectionRadius(getStatePointDiameterForPathType(currentPathType));
        const existingIndex = findPointIndexNear(x, y, points, detectionRadius);
        if (existingIndex >= 0) {
          points.splice(existingIndex, 1);
          loadedNormalizedPoints = null;
          redraw();
          markUnsavedChange();
          return;
        }

        const sharedPoint = findSharedPointNear(x, y);
        if (sharedPoint) {
          points.push(sharedPoint);
          loadedNormalizedPoints = null;
          redraw();
          markUnsavedChange();
          return;
        }
      }

      points.push({ x, y });
      loadedNormalizedPoints = null;
      redraw();
      markUnsavedChange();
    }

    function clearCanvas() {
      const activeType = normalizePathType(pathType);
      if (!points.length && (!loadedNormalizedPoints || !loadedNormalizedPoints.length)) {
        return;
      }

      normalizedPointsByPathType.set(activeType, []);
      setCanvasPointsFromNormalized([]);
      markUnsavedChange();
    }

    function sanitizeColor(value) {
      if (typeof value === 'string' && /^#([0-9a-f]{6})$/i.test(value)) {
        return value;
      }
      return '#ffde59';
    }

    function applyRouteToCanvas(routeKey, rawData = {}) {
      const data = normalizeRouteData(rawData);

      const targetLocation = findLocationByName(data.location) || DEFAULT_LOCATION;
      setLocation(targetLocation, {
        persist: false,
        refreshRoutes: false,
        wallFallback: {
          pointDiameter: data.pointDiameter,
          hollowPointDiameter: data.hollowPointDiameter ?? data.pointDiameter,
          filledPointDiameter: data.filledPointDiameter ?? data.pointDiameter,
          rectangleWidth: data.rectangleWidth,
          rectangleHeight: data.rectangleHeight,
          brezerStrokeWidth: data.brezerStrokeWidth,
          gradeBarBaseHeight: data.gradeBarBaseHeight,
          gradeBarMaxHeight: data.gradeBarMaxHeight,
          gradeBarWidth: data.gradeBarWidth,
          transparency: data.gradeBarTransparency,
        },
      });

      const savedPathType = normalizePathType(data.pathType) || DEFAULT_PATH_TYPE;
      const nonEmptyPointEntries = collectRoutePointEntries(data);
      const hasSavedPathPoints = nonEmptyPointEntries.some(
        (entry) => entry.pathType === savedPathType,
      );
      const fallbackEntry = hasSavedPathPoints ? null : nonEmptyPointEntries[0] || null;
      pathType = fallbackEntry?.pathType || savedPathType;
      updatePathControls();

      currentRouteKey = routeKey;
      routeSelector.value = routeKey;
      routeSetterInput.value = data.setter || currentUsername || '';
      routeTitleInput.value = data.title;
      routeDescriptionInput.value = data.description;
      routeDateSetInput.value = isoStringToInputValue(data.date_set) || '';
      strokeColor = data.strokeColor;
      currentRouteMedianGrade = data.medianGrade ?? null;
      if (routeHiddenCheckbox) {
        const isHidden = data.hiddenFromClimbers === true;
        routeHiddenCheckbox.checked = isHidden;
        routeHiddenCheckbox.setAttribute('aria-checked', isHidden ? 'true' : 'false');
      }
      colorPicker.value = strokeColor;
      syncAdvancedColorPicker(strokeColor);
      synchroniseNormalizedPoints(data.pointsByType ?? data.points, pathType);
      const activeNormalizedPoints = sanitizeNormalizedPointsArray(
        normalizedPointsByPathType.get(pathType),
      );
      const cachedPointsByType = new Map();
      normalizedPointsByPathType.forEach((value, key) => {
        cachedPointsByType.set(key, sanitizeNormalizedPointsArray(value));
      });
      deleteButton.disabled = !routeKey;
      resetUnsavedState();

      if (routeKey) {
        const cachedRouteData = {
          ...data,
          pathType,
          points: activeNormalizedPoints,
          pointsByType: cachedPointsByType,
        };
        routesCache.set(routeKey, cachedRouteData);
        const label = cachedRouteData.title || routeKey;
        setStatus(`Loaded route “${label}”.`, 'success');
      }
    }

    function prepareNewRoute(statusMessage = '') {
      currentRouteKey = '';
      routeSelector.value = '';
      routeSetterInput.value = currentUsername || '';
      routeTitleInput.value = '';
      routeDescriptionInput.value = '';
      routeDateSetInput.value = getNowInputValue();
      if (routeHiddenCheckbox) {
        routeHiddenCheckbox.checked = false;
        routeHiddenCheckbox.setAttribute('aria-checked', 'false');
      }
      strokeColor = '#ffde59';
      colorPicker.value = strokeColor;
      syncAdvancedColorPicker(strokeColor);
      setDrawingEnabled(false);
      const wallSettings = getWallSettingsForLocation(getCurrentLocationKey());
      pathType = DEFAULT_PATH_TYPE;
      pointDiameter = wallSettings.hollowPointDiameter ?? wallSettings.pointDiameter;
      filledPointDiameter = wallSettings.filledPointDiameter ?? wallSettings.pointDiameter;
      rectangleWidth = wallSettings.rectangleWidth;
      rectangleHeight = wallSettings.rectangleHeight;
      brezerStrokeWidth = wallSettings.brezerStrokeWidth;
      unfocusedTransparency = wallSettings.unfocusedTransparency;
      gradeBarBaseHeight = wallSettings.gradeBarBaseHeight;
      gradeBarMaxHeight = wallSettings.gradeBarMaxHeight;
      gradeBarWidth = wallSettings.gradeBarWidth;
      gradeBarTransparency = wallSettings.gradeBarTransparency;
      currentRouteMedianGrade = null;
      updatePathControls();
      updateAppearanceControls();
      normalizedPointsByPathType.clear();
      normalizedPointsByPathType.set(pathType, []);
      loadPointsForActivePathType();
      deleteButton.disabled = true;
      resetUnsavedState();
      if (statusMessage) {
        setStatus(statusMessage, 'info');
      } else {
        clearStatus();
      }
    }

    async function loadRoutesList(selectedRouteKey = '') {
      try {
        routeSelector.disabled = true;
        const currentLocationKey = getCurrentLocationKey();
        const previousSettings = getWallSettingsForLocation(currentLocationKey);
        await refreshWallSettingsCache();
        const resolvedSettings = getWallSettingsForLocation(currentLocationKey);
        const pathSettingsChanged =
          resolvedSettings.hollowPointDiameter !== previousSettings.hollowPointDiameter ||
          resolvedSettings.filledPointDiameter !== previousSettings.filledPointDiameter ||
          resolvedSettings.rectangleWidth !== previousSettings.rectangleWidth ||
          resolvedSettings.rectangleHeight !== previousSettings.rectangleHeight ||
          resolvedSettings.unfocusedTransparency !== previousSettings.unfocusedTransparency;

        if (pathSettingsChanged) {
          pointDiameter = resolvedSettings.hollowPointDiameter ?? resolvedSettings.pointDiameter;
          filledPointDiameter = resolvedSettings.filledPointDiameter ?? resolvedSettings.pointDiameter;
          rectangleWidth = resolvedSettings.rectangleWidth;
          rectangleHeight = resolvedSettings.rectangleHeight;
          unfocusedTransparency = resolvedSettings.unfocusedTransparency;
          updatePathControls();
        }

        const appearanceSettingsChanged =
          resolvedSettings.gradeBarBaseHeight !== previousSettings.gradeBarBaseHeight ||
          resolvedSettings.gradeBarMaxHeight !== previousSettings.gradeBarMaxHeight ||
          resolvedSettings.gradeBarWidth !== previousSettings.gradeBarWidth ||
          resolvedSettings.gradeBarTransparency !== previousSettings.gradeBarTransparency;

        if (appearanceSettingsChanged) {
          gradeBarBaseHeight = resolvedSettings.gradeBarBaseHeight;
          gradeBarMaxHeight = resolvedSettings.gradeBarMaxHeight;
          gradeBarWidth = resolvedSettings.gradeBarWidth;
          gradeBarTransparency = resolvedSettings.gradeBarTransparency;
          updateAppearanceControls();
        }

        const [routesSnapshot, medianMap] = await Promise.all([
          getDocs(collection(db, 'routes')),
          fetchMedianGrades(),
        ]);
        routeMedianGrades = medianMap instanceof Map ? medianMap : new Map();
        routesCache.clear();
        routesSnapshot.forEach((docSnap) => {
          const data = docSnap.data() ?? {};
          const rawUid = typeof data.uid === 'string' ? data.uid.trim() : '';
          const routeUid = rawUid || docSnap.id;
          routesCache.set(routeUid, normalizeRouteData({ id: routeUid, uid: routeUid, ...data }));
        });

        updateRoutesForAllWalls();

        const sortedEntries = [...routesCache.entries()].sort((a, b) => {
          const labelA = (a[1]?.title || a[0]).toLowerCase();
          const labelB = (b[1]?.title || b[0]).toLowerCase();
          return labelA.localeCompare(labelB);
        });

        const activeLocationKey = getCurrentLocationKey();
        const filteredEntries = sortedEntries.filter(([_, data]) => {
          const routeLocationKey =
            typeof data?.locationKey === 'string'
              ? data.locationKey
              : normalizeLocationName(data?.location);
          if (!activeLocationKey) {
            return true;
          }
          return routeLocationKey === activeLocationKey;
        });

        routeSelector.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Create new route…';
        routeSelector.appendChild(defaultOption);

        filteredEntries.forEach(([id, data]) => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = data?.title || id;
          routeSelector.appendChild(option);
        });

        if (selectedRouteKey && filteredEntries.some(([id]) => id === selectedRouteKey)) {
          routeSelector.value = selectedRouteKey;
        } else {
          routeSelector.value = '';
        }
      } catch (error) {
        console.error('Failed to load routes:', error);
        setStatus('Failed to load routes. Please try again.', 'error');
        throw error;
      } finally {
        routeSelector.disabled = false;
        redraw();
      }
    }

    async function saveRoute() {
      if (isSaving) {
        return;
      }

      const previousRouteKey = currentRouteKey;
      setDrawingEnabled(false);

      if (points.length < 2) {
        setStatus('Add at least two points to define the route.', 'error');
        return;
      }

      flushActivePointsToNormalized();
      const pointsPayload = serialiseNormalizedPointsByType(
        normalizedPointsByPathType,
      );
      const setter = normalizeSetterName(routeSetterInput.value);
      routeSetterInput.value = setter;
      if (!setter) {
        setStatus('Setter name is required before saving.', 'error');
        routeSetterInput.focus();
        return;
      }

      if (!isValidSetterName(setter)) {
        setStatus('Setter name must use letters, numbers, underscores, or spaces.', 'error');
        routeSetterInput.focus();
        return;
      }

      const title = routeTitleInput.value.trim();
      routeTitleInput.value = title;
      if (!title) {
        setStatus('Route title is required before saving.', 'error');
        routeTitleInput.focus();
        return;
      }

      const conflictingKey = findConflictingRouteKey(title, previousRouteKey);
      if (conflictingKey && conflictingKey !== previousRouteKey) {
        setStatus('Another route already uses this title. Choose a different title.', 'error');
        routeTitleInput.focus();
        return;
      }
      const isExistingRoute = Boolean(previousRouteKey);
      const routeKey = isExistingRoute ? previousRouteKey : generateRouteUid();

      const description = routeDescriptionInput.value.trim();
      routeDescriptionInput.value = description;
      const dateSetIso = inputValueToIsoString(routeDateSetInput.value);
      if (!dateSetIso) {
        setStatus('Enter a valid set date for the route.', 'error');
        routeDateSetInput.focus();
        return;
      }

      const currentLocationKey = getCurrentLocationKey();
      const wallSettings = getWallSettingsForLocation(currentLocationKey);
      const normalizedPathType = normalizePathType(pathType);
      const normalizedHollowPointDiameter =
        wallSettings.hollowPointDiameter ?? wallSettings.pointDiameter;
      const normalizedFilledPointDiameter =
        wallSettings.filledPointDiameter ?? wallSettings.pointDiameter;
      const normalizedPointDiameter = normalizedHollowPointDiameter;
      const normalizedRectangleWidth = wallSettings.rectangleWidth;
      const normalizedRectangleHeight = wallSettings.rectangleHeight;
      const normalizedUnfocusedTransparency = wallSettings.unfocusedTransparency;
      const hiddenFromClimbers = routeHiddenCheckbox?.checked === true;
      pathType = normalizedPathType;
      pointDiameter = normalizedHollowPointDiameter;
      filledPointDiameter = normalizedFilledPointDiameter;
      rectangleWidth = normalizedRectangleWidth;
      rectangleHeight = normalizedRectangleHeight;
      unfocusedTransparency = normalizedUnfocusedTransparency;
      updatePathControls();

      const payload = {
        uid: routeKey,
        setter,
        title,
        description: description || null,
        strokeColor,
        pathType: normalizedPathType,
        points: pointsPayload,
        date_set: dateSetIso,
        date_removed: deleteField(),
        location: currentLocation?.name || DEFAULT_LOCATION?.name || null,
        updatedAt: serverTimestamp(),
        hiddenFromClimbers: hiddenFromClimbers ? true : deleteField(),
      };

      const routeRef = doc(db, 'routes', routeKey);

      try {
        isSaving = true;
        saveButton.disabled = true;
        routeSelector.disabled = true;
        deleteButton.disabled = true;
        setStatus('Saving route…', 'info');

          const existingSnap = await getDoc(routeRef);
          const existingData = existingSnap.data();
          let usersPayload = null;

          if (!existingSnap.exists()) {
            payload.createdAt = serverTimestamp();
            usersPayload = {};
          } else if (!existingData?.users || typeof existingData.users !== 'object') {
            usersPayload = {};
          }

          if (usersPayload !== null) {
            payload.users = usersPayload;
          }

          await setDoc(routeRef, payload, { merge: true });

          currentRouteKey = routeKey;
          routesCache.set(
            routeKey,
            normalizeRouteData({
              id: routeKey,
              uid: routeKey,
              ...payload,
              users: usersPayload !== null ? usersPayload : existingData?.users,
              pointDiameter: normalizedPointDiameter,
              hollowPointDiameter: normalizedHollowPointDiameter,
              filledPointDiameter: normalizedFilledPointDiameter,
              brezerStrokeWidth: wallSettings.brezerStrokeWidth,
              rectangleWidth: normalizedRectangleWidth,
              rectangleHeight: normalizedRectangleHeight,
            }),
          );

          resetUnsavedState();

          const label = title || routeKey;
          await loadRoutesList(routeKey);
          prepareNewRoute();
          setStatus(`Route “${label}” saved successfully.`, 'success');
      } catch (error) {
        console.error('Failed to save route:', error);
        setStatus(error.message || 'Failed to save route.', 'error');
      } finally {
        isSaving = false;
        saveButton.disabled = false;
        routeSelector.disabled = false;
        deleteButton.disabled = !currentRouteKey;
      }
    }

    async function deleteCurrentRoute() {
      const targetKey = currentRouteKey;
      if (!targetKey) {
        setStatus('Select a saved route to delete.', 'error');
        return;
      }

      const cachedRoute = routesCache.get(targetKey);
      const routeLabel = cachedRoute?.title || targetKey;
      const confirmed = window.confirm(`Delete route “${routeLabel}”? This cannot be undone.`);
      if (!confirmed) {
        return;
      }

      try {
        saveButton.disabled = true;
        deleteButton.disabled = true;
        routeSelector.disabled = true;
        setStatus('Deleting route…', 'info');

        await deleteDoc(doc(db, 'routes', targetKey));
        routesCache.delete(targetKey);

        await loadRoutesList();
        prepareNewRoute('Route deleted. You can create a new one.');
        setStatus(`Route “${routeLabel}” deleted.`, 'success');
      } catch (error) {
        console.error('Failed to delete route:', error);
        setStatus(error.message || 'Failed to delete route.', 'error');
        deleteButton.disabled = false;
      } finally {
        saveButton.disabled = false;
        routeSelector.disabled = false;
      }
    }

    [routeSetterInput, routeTitleInput, routeDescriptionInput].forEach((element) => {
      if (element) {
        element.addEventListener('input', markUnsavedChange);
      }
    });

    if (routeDateSetInput) {
      routeDateSetInput.addEventListener('change', markUnsavedChange);
      routeDateSetInput.addEventListener('input', markUnsavedChange);
    }

    if (routeHiddenCheckbox) {
      routeHiddenCheckbox.addEventListener('change', (event) => {
        const isHidden = event.target.checked === true;
        event.target.setAttribute('aria-checked', isHidden ? 'true' : 'false');
        markUnsavedChange();
      });
    }

    if (saveAppearanceButton) {
      saveAppearanceButton.addEventListener('click', async () => {
        const locationKey = getCurrentLocationKey();
        if (!locationKey) {
          setStatus('Select a wall before saving appearance.', 'error');
          return;
        }

        const nextHollowPointDiameter = normalizePointDiameter(
          hollowPointDiameterSlider?.value ?? pointDiameter,
          DEFAULT_HOLLOW_POINT_DIAMETER,
        );
        const nextFilledPointDiameter = normalizePointDiameter(
          filledPointDiameterSlider?.value ?? filledPointDiameter,
          DEFAULT_FILLED_POINT_DIAMETER,
        );
        const nextGradeBarBaseHeight = normalizeGradeBarHeight(
          gradeBarBaseHeightInput?.value,
          DEFAULT_GRADE_BAR_BASE_HEIGHT,
        );
        const nextGradeBarMaxHeight = Math.max(
          nextGradeBarBaseHeight,
          normalizeGradeBarHeight(gradeBarMaxHeightInput?.value, DEFAULT_GRADE_BAR_MAX_HEIGHT),
        );
        const nextGradeBarWidth = normalizeGradeBarWidth(
          gradeBarWidthInput?.value,
        );
        const nextGradeBarTransparency = normalizeGradeBarTransparency(
          gradeBarTransparencyInput?.value,
        );

        try {
          await persistWallSettings(locationKey, {
            pointDiameter: nextHollowPointDiameter,
            hollowPointDiameter: nextHollowPointDiameter,
            filledPointDiameter: nextFilledPointDiameter,
            brezerStrokeWidth,
            gradeBarBaseHeight: nextGradeBarBaseHeight,
            gradeBarMaxHeight: nextGradeBarMaxHeight,
            gradeBarWidth: nextGradeBarWidth,
            transparency: nextGradeBarTransparency,
          });
          pointDiameter = nextHollowPointDiameter;
          filledPointDiameter = nextFilledPointDiameter;
          setStatus('Appearance saved.', 'success');
        } catch (error) {
          console.error('Failed to save appearance settings:', error);
          setStatus('Failed to save appearance. Please try again.', 'error');
        }
      });
    }

    canvas.addEventListener('click', addPoint);
    window.addEventListener('resize', resizeCanvas);

    clearButton.addEventListener('click', clearCanvas);
    saveButton.addEventListener('click', saveRoute);
    if (cancelRouteButton) {
      cancelRouteButton.addEventListener('click', () => {
        setDrawingEnabled(false);
      });
    }
    deleteButton.addEventListener('click', deleteCurrentRoute);
    routeSelector.addEventListener('change', async (event) => {
      const selectedKey = event.target.value;
      if (!selectedKey) {
        setDrawingEnabled(false);
        prepareNewRoute('Creating a new route.');
        return;
      }

      let data = routesCache.get(selectedKey);
      if (!data) {
        try {
          const snap = await getDoc(doc(db, 'routes', selectedKey));
          if (snap.exists()) {
            data = normalizeRouteData({ id: selectedKey, ...snap.data() });
            routesCache.set(selectedKey, data);
          }
        } catch (error) {
          console.error('Failed to fetch route:', error);
        }
      }

      if (!data) {
        setStatus('Unable to load the selected route.', 'error');
        return;
      }

      applyRouteToCanvas(selectedKey, data);
    });

    colorPicker.addEventListener('input', (event) => {
      strokeColor = sanitizeColor(event.target.value || '#ffde59');
      loadedNormalizedPoints = null;
      redraw();
      markUnsavedChange();
      syncAdvancedColorPicker(strokeColor);
    });

    if (pathTypeSelect) {
      pathTypeSelect.addEventListener('change', (event) => {
        const selectedType = normalizePathType(event.target.value);
        if (pathType === selectedType) {
          updatePathControls();
          return;
        }

        flushActivePointsToNormalized();
        pathType = selectedType;
        updatePathControls();

        if (!normalizedPointsByPathType.has(pathType)) {
          normalizedPointsByPathType.set(pathType, []);
        }

        loadPointsForActivePathType();

        if (currentRouteKey && routesCache.has(currentRouteKey)) {
          const cached = routesCache.get(currentRouteKey);
          routesCache.set(currentRouteKey, {
            ...cached,
            pathType: selectedType,
            pointsByType: new Map(normalizedPointsByPathType),
          });
        }
        markUnsavedChange();
      });
    }

    if (hollowPointDiameterSlider) {
      hollowPointDiameterSlider.addEventListener('input', (event) => {
        const nextValue = normalizePointDiameter(
          event.target.value,
          DEFAULT_HOLLOW_POINT_DIAMETER,
        );
        if (pointDiameter === nextValue) {
          updatePathControls();
          updateAppearanceControls();
          return;
        }

        pointDiameter = nextValue;
        updatePathControls();
        updateAppearanceControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter: nextValue,
            hollowPointDiameter: nextValue,
            filledPointDiameter,
            rectangleWidth,
            rectangleHeight,
            brezerStrokeWidth,
            unfocusedTransparency,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      hollowPointDiameterSlider.addEventListener('change', async (event) => {
        const nextValue = normalizePointDiameter(
          event.target.value,
          DEFAULT_HOLLOW_POINT_DIAMETER,
        );
        if (pointDiameter !== nextValue) {
          pointDiameter = nextValue;
          updatePathControls();
          updateAppearanceControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, {
              pointDiameter: nextValue,
              hollowPointDiameter: nextValue,
            });
          } catch (error) {
            console.error('Failed to persist hollow point diameter:', error);
          }
        }
      });
    }

    if (filledPointDiameterSlider) {
      filledPointDiameterSlider.addEventListener('input', (event) => {
        const nextValue = normalizePointDiameter(
          event.target.value,
          DEFAULT_FILLED_POINT_DIAMETER,
        );
        if (filledPointDiameter === nextValue) {
          updatePathControls();
          updateAppearanceControls();
          return;
        }

        filledPointDiameter = nextValue;
        updatePathControls();
        updateAppearanceControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter,
            hollowPointDiameter: pointDiameter,
            filledPointDiameter: nextValue,
            rectangleWidth,
            rectangleHeight,
            brezerStrokeWidth,
            unfocusedTransparency,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      filledPointDiameterSlider.addEventListener('change', async (event) => {
        const nextValue = normalizePointDiameter(
          event.target.value,
          DEFAULT_FILLED_POINT_DIAMETER,
        );
        if (filledPointDiameter !== nextValue) {
          filledPointDiameter = nextValue;
          updatePathControls();
          updateAppearanceControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { filledPointDiameter: nextValue });
          } catch (error) {
            console.error('Failed to persist filled point diameter:', error);
          }
        }
      });
    }

    if (rectangleWidthSlider) {
      rectangleWidthSlider.addEventListener('input', (event) => {
        const nextValue = normalizeRectangleSize(event.target.value, DEFAULT_RECTANGLE_WIDTH);
        if (rectangleWidth === nextValue) {
          updatePathControls();
          return;
        }

        rectangleWidth = nextValue;
        updatePathControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter,
            rectangleWidth: nextValue,
            rectangleHeight,
            brezerStrokeWidth,
            unfocusedTransparency,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      rectangleWidthSlider.addEventListener('change', async (event) => {
        const nextValue = normalizeRectangleSize(event.target.value, DEFAULT_RECTANGLE_WIDTH);
        if (rectangleWidth !== nextValue) {
          rectangleWidth = nextValue;
          updatePathControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { rectangleWidth: nextValue });
          } catch (error) {
            console.error('Failed to persist rectangle width:', error);
          }
        }
      });
    }

    if (rectangleHeightSlider) {
      rectangleHeightSlider.addEventListener('input', (event) => {
        const nextValue = normalizeRectangleSize(event.target.value, DEFAULT_RECTANGLE_HEIGHT);
        if (rectangleHeight === nextValue) {
          updatePathControls();
          return;
        }

        rectangleHeight = nextValue;
        updatePathControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter,
            rectangleWidth,
            rectangleHeight: nextValue,
            brezerStrokeWidth,
            unfocusedTransparency,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      rectangleHeightSlider.addEventListener('change', async (event) => {
        const nextValue = normalizeRectangleSize(event.target.value, DEFAULT_RECTANGLE_HEIGHT);
        if (rectangleHeight !== nextValue) {
          rectangleHeight = nextValue;
          updatePathControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { rectangleHeight: nextValue });
          } catch (error) {
            console.error('Failed to persist rectangle height:', error);
          }
        }
      });
    }

    if (brezerStrokeWidthSlider) {
      brezerStrokeWidthSlider.addEventListener('input', (event) => {
        const nextValue = normalizeBrezerStrokeWidth(event.target.value);
        if (brezerStrokeWidth === nextValue) {
          updatePathControls();
          return;
        }

        brezerStrokeWidth = nextValue;
        updatePathControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter,
            rectangleWidth,
            rectangleHeight,
            brezerStrokeWidth: nextValue,
            unfocusedTransparency,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      brezerStrokeWidthSlider.addEventListener('change', async (event) => {
        const nextValue = normalizeBrezerStrokeWidth(event.target.value);
        if (brezerStrokeWidth !== nextValue) {
          brezerStrokeWidth = nextValue;
          updatePathControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { brezerStrokeWidth: nextValue });
          } catch (error) {
            console.error('Failed to persist Brezer stroke width:', error);
          }
        }
      });
    }

    if (unfocusedTransparencySlider) {
      unfocusedTransparencySlider.addEventListener('input', (event) => {
        const nextValue = sliderValueToUnfocusedTransparency(event.target.value);
        if (unfocusedTransparency === nextValue) {
          updatePathControls();
          return;
        }

        unfocusedTransparency = nextValue;
        updatePathControls();

        const locationKey = getCurrentLocationKey();
        const normalizedKey = normalizeWallKey(locationKey);
        if (normalizedKey) {
          const previewSettings = normalizeWallSettings({
            pointDiameter,
            rectangleWidth,
            rectangleHeight,
            brezerStrokeWidth,
            unfocusedTransparency: nextValue,
            gradeBarBaseHeight,
            gradeBarMaxHeight,
            gradeBarWidth,
            gradeBarTransparency,
          });
          wallSettingsCache.set(normalizedKey, previewSettings);
          updateRoutesForWall(normalizedKey, previewSettings);
        }

        redraw();
      });

      unfocusedTransparencySlider.addEventListener('change', async (event) => {
        const nextValue = sliderValueToUnfocusedTransparency(event.target.value);
        if (unfocusedTransparency !== nextValue) {
          unfocusedTransparency = nextValue;
          updatePathControls();
        }

        const locationKey = getCurrentLocationKey();
        if (locationKey) {
          try {
            await persistWallSettings(locationKey, { unfocusedTransparency: nextValue });
          } catch (error) {
            console.error('Failed to persist unfocused transparency:', error);
          }
        }
      });
    }

    if (createWallButton) {
      createWallButton.addEventListener('click', () => {
        void handleCreateWall();
      });
    }

    if (deleteWallButton) {
      deleteWallButton.addEventListener('click', () => {
        void handleDeleteWall();
      });
    }

    [newWallNameInput, newWallImageInput].forEach((input) => {
      if (!input) {
        return;
      }
      input.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          void handleCreateWall();
        }
      });
    });

    if (backgroundImage.complete) {
      backgroundReady = true;
      if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
        const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
        if (Number.isFinite(ratio) && ratio > 0) {
          canvasAspectRatio = ratio;
        }
      }
      resizeCanvas();
    } else {
      resizeCanvas();
    }

    let authMode = 'login';

    function setAuthMode(mode) {
      authMode = mode;
      const isLogin = authMode === 'login';
      authTitle.textContent = isLogin ? 'Sign in to continue' : 'Create your account';
      authSwitchLabel.textContent = isLogin ? "Don't have an account?" : 'Already have an account?';
      toggleAuthModeButton.textContent = isLogin ? 'Create one' : 'Sign in';
      authForm.querySelector('.auth-submit').textContent = isLogin ? 'Sign In' : 'Create Account';
      authPassword.setAttribute('autocomplete', isLogin ? 'current-password' : 'new-password');
      authError.textContent = '';
    }

    toggleAuthModeButton.addEventListener('click', () => {
      setAuthMode(authMode === 'login' ? 'register' : 'login');
    });

    async function lookupUsernameByUid(uid) {
      if (!uid) {
        return '';
      }

      try {
        const userRef = doc(db, 'users', uid);
        const userSnap = await getDoc(userRef);

        if (!userSnap.exists()) {
          return '';
        }

        const data = userSnap.data() || {};
        return normalizeUsername(typeof data.username === 'string' ? data.username : '');
      } catch (error) {
        console.error('Failed to look up username by UID:', error);
        return '';
      }
    }

    async function resolveUsernameForUser(user) {
      if (!user) {
        return '';
      }

      const displayName = normalizeUsername(user.displayName);
      if (isValidUsername(displayName)) {
        return displayName;
      }

      const mapped = await lookupUsernameByUid(user.uid);
      if (isValidUsername(mapped)) {
        if (!displayName) {
          try {
            await updateProfile(user, { displayName: mapped });
          } catch (error) {
            console.warn('Unable to synchronise display name with username:', error);
          }
        }
        return mapped;
      }

      const syntheticEmail = typeof user.email === 'string' ? user.email : '';
      if (syntheticEmail.endsWith(`@${SYNTHETIC_EMAIL_DOMAIN}`)) {
        const derived = normalizeUsername(
          syntheticEmail.slice(0, -(`@${SYNTHETIC_EMAIL_DOMAIN}`.length)),
        );
        if (isValidUsername(derived)) {
          return derived;
        }
      }

      return '';
    }

    authForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      authError.textContent = '';
      const rawUsername = authUsername.value;
      const normalizedUsername = normalizeUsername(rawUsername);
      const password = authPassword.value;

      if (!normalizedUsername) {
        authError.textContent = 'Enter your username to continue.';
        return;
      }

      if (!isValidUsername(normalizedUsername)) {
        authError.textContent =
          'Usernames must be 3-20 characters using only letters, numbers, or underscores.';
        return;
      }

      const syntheticEmail = buildSyntheticEmail(normalizedUsername);

      try {
        if (authMode === 'login') {
          await signInWithEmailAndPassword(auth, syntheticEmail, password);
          return;
        }

        const credentials = await createUserWithEmailAndPassword(auth, syntheticEmail, password);
        const { user } = credentials;

        try {
          await updateProfile(user, { displayName: normalizedUsername });
        } catch (profileError) {
          console.warn('Failed to update display name:', profileError);
        }

        try {
          await ensureUserRole(user, normalizedUsername);
        } catch (error) {
          console.error('Failed to initialize user record:', error);
          try {
            await deleteUser(user);
          } catch (cleanupError) {
            console.warn('Unable to clean up user after initialization failure:', cleanupError);
          }
          if (error && typeof error === 'object' && 'code' in error) {
            throw error;
          }
          const initializationError = new Error('Username unavailable');
          initializationError.code = 'auth/username-unavailable';
          throw initializationError;
        }
      } catch (error) {
        let message = 'Unable to complete the request. Please try again.';

        switch (error?.code) {
          case 'auth/user-not-found':
          case 'auth/wrong-password':
            message = 'Invalid username or password.';
            break;
          case 'auth/email-already-in-use':
          case 'auth/username-unavailable':
          case 'permission-denied':
            message = 'That username is already taken. Choose another one.';
            break;
          case 'auth/invalid-email':
            message = 'Enter a valid username.';
            break;
          case 'auth/weak-password':
            message = 'Choose a stronger password (at least 6 characters).';
            break;
          default:
            if (error?.message) {
              message = error.message;
            }
        }

        authError.textContent = message;
      }
    });

    signOutButton.addEventListener('click', async () => {
      await signOutAndRedirectToIndex();
    });

    unauthorizedSignOut.addEventListener('click', async () => {
      await signOutAndRedirectToIndex();
    });

    async function ensureUserRole(user, username) {
      if (!user) {
        return null;
      }

      const normalizedUsername = normalizeUsername(username);

      if (!normalizedUsername) {
        return { role: null };
      }

      const userRef = doc(db, 'users', user.uid);

      try {
        const existingSnap = await getDoc(userRef);

        if (existingSnap.exists()) {
          const data = existingSnap.data() || {};
          const storedUsername = normalizeUsername(
            typeof data.username === 'string' ? data.username : '',
          );
          const trimmedRole =
            typeof data.role === 'string' ? data.role.trim().toLowerCase() : '';

          const updates = {};

          if (storedUsername !== normalizedUsername) {
            const conflictSnapshot = await getDocs(
              query(collection(db, 'users'), where('username', '==', normalizedUsername), limit(1)),
            );

            if (!conflictSnapshot.empty && conflictSnapshot.docs[0].id !== user.uid) {
              const usernameError = new Error('Username unavailable');
              usernameError.code = 'auth/username-unavailable';
              throw usernameError;
            }

            updates.username = normalizedUsername;
            updates.updatedAt = serverTimestamp();
          } else if (!data.updatedAt) {
            updates.updatedAt = serverTimestamp();
          }

          if (Object.keys(updates).length > 0) {
            await setDoc(userRef, updates, { merge: true });
          }

          return {
            ...data,
            ...(updates.username ? { username: normalizedUsername } : {}),
            ...(updates.updatedAt ? { updatedAt: updates.updatedAt } : {}),
            role: trimmedRole || null,
          };
        }

        const conflictSnapshot = await getDocs(
          query(collection(db, 'users'), where('username', '==', normalizedUsername), limit(1)),
        );

        if (!conflictSnapshot.empty) {
          const usernameError = new Error('Username unavailable');
          usernameError.code = 'auth/username-unavailable';
          throw usernameError;
        }

        const timestamp = serverTimestamp();
        const userData = {
          username: normalizedUsername,
          createdAt: timestamp,
          updatedAt: timestamp,
          role: null,
        };

        await setDoc(userRef, userData);

        return userData;
      } catch (error) {
        console.error('Failed to ensure user record:', error);
        throw error;
      }
    }

    async function resolveUserRole(user, username) {
      if (!user) {
        return null;
      }

      const normalizedUsername = normalizeUsername(username);
      if (!isValidUsername(normalizedUsername)) {
        return 'default';
      }

      try {
        const ensuredRole = await ensureUserRole(user, normalizedUsername);
        return typeof ensuredRole?.role === 'string' && ensuredRole.role.trim()
          ? ensuredRole.role.trim().toLowerCase()
          : 'default';
      } catch (error) {
        if (error && typeof error === 'object' && 'code' in error) {
          const code = String(error.code);
          if (code === 'permission-denied') {
            return 'default';
          }
        }
        console.error('Failed to fetch user role:', error);
        return 'default';
      }
    }

    function handleUnauthorized() {
      appContent.classList.add('hidden');
      unauthorizedNotice.classList.remove('hidden');
      routeSelector.disabled = true;
      deleteButton.disabled = true;
      clearStatus();
      updateAdminConsoleAccess('');
      cancelTutorialAutostart();
      void finishTutorial();
    }

    function handleAuthorized(role) {
      unauthorizedNotice.classList.add('hidden');
      appContent.classList.remove('hidden');
      routeSelector.disabled = false;
      const normalizedRole = typeof role === 'string' ? role.trim().toLowerCase() : '';
      updateAdminConsoleAccess(normalizedRole);
    }

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        currentUserId = user.uid;
        authOverlay.classList.add('hidden');

        const resolvedUsername = await resolveUsernameForUser(user);
        if (!isValidUsername(resolvedUsername)) {
          authError.textContent =
            'Unable to resolve your username. Please contact another setter for assistance.';
          await signOutAndRedirectToIndex();
          return;
        }

        currentUsername = resolvedUsername;

        const role = await resolveUserRole(user, resolvedUsername);

        if (!role) {
          authError.textContent = 'Unable to determine your role. Please try again later.';
          await signOutAndRedirectToIndex();
          return;
        }

        if (role !== 'setter' && role !== 'admin') {
          handleUnauthorized();
          return;
        }

        handleAuthorized(role);

        try {
          await loadRoutesList(currentRouteKey);
          if (currentRouteKey && routesCache.has(currentRouteKey)) {
            applyRouteToCanvas(currentRouteKey, routesCache.get(currentRouteKey));
          } else {
            prepareNewRoute('Select a saved route or start drawing a new one.');
          }
        } catch (error) {
          console.error('Unable to initialise routes:', error);
        }

        scheduleTutorialAutostart();
      } else {
        currentUsername = '';
        currentUserId = null;
        authOverlay.classList.remove('hidden');
        appContent.classList.add('hidden');
        unauthorizedNotice.classList.add('hidden');
        routeSelector.disabled = true;
        deleteButton.disabled = true;
        authForm.reset();
        prepareNewRoute();
        clearStatus();
        setAuthMode('login');
        updateAdminConsoleAccess('');
        cancelTutorialAutostart();
        void finishTutorial();
      }
    });

    refreshWallSettingsCache()
      .then(() => {
        const locationKey = getCurrentLocationKey();
        const wallSettings = getWallSettingsForLocation(locationKey);
        pointDiameter = wallSettings.hollowPointDiameter ?? wallSettings.pointDiameter;
        filledPointDiameter = wallSettings.filledPointDiameter ?? wallSettings.pointDiameter;
        unfocusedTransparency = wallSettings.unfocusedTransparency;
        updatePathControls();
        updateRoutesForAllWalls();
        redraw();
      })
      .catch((error) => {
        console.warn('Unable to initialise wall settings cache:', error);
      });

    setAuthMode('login');

    prepareNewRoute();
  </script>
</body>
</html>
