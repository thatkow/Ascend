<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ascend Admin Console</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      color-scheme: dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: radial-gradient(circle at top, #0f172a, #020617 60%);
      color: #f8fafc;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1rem;
    }

    .hidden {
      display: none !important;
    }

    .auth-overlay {
      width: min(420px, 100%);
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: 0 24px 64px rgba(15, 23, 42, 0.65);
      border-radius: 1.25rem;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .auth-overlay h1 {
      font-size: 1.4rem;
      font-weight: 700;
    }

    .auth-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .auth-field label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.35rem;
      color: rgba(226, 232, 240, 0.85);
    }

    .auth-field input {
      width: 100%;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.65);
      color: #f8fafc;
      padding: 0.7rem 1rem;
      font-size: 1rem;
    }

    .auth-error {
      min-height: 1.5rem;
      color: #fca5a5;
      font-size: 0.9rem;
    }

    .auth-submit {
      border: none;
      border-radius: 999px;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #052e16;
      font-weight: 700;
      font-size: 1rem;
      padding: 0.75rem 1.25rem;
      cursor: pointer;
      box-shadow: 0 18px 36px rgba(34, 197, 94, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .auth-submit:hover,
    .auth-submit:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 22px 42px rgba(34, 197, 94, 0.45);
      outline: none;
    }

    .admin-app {
      width: min(720px, 100%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      background: rgba(15, 23, 42, 0.78);
      border-radius: 1.5rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: 0 28px 70px rgba(2, 6, 23, 0.6);
      padding: clamp(1.5rem, 3vw, 2.5rem);
    }

    .admin-header {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .admin-header h1 {
      font-size: clamp(1.6rem, 2.5vw, 2rem);
      font-weight: 700;
    }

    .admin-header p {
      color: rgba(226, 232, 240, 0.78);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .admin-actions {
      display: grid;
      gap: 0.85rem;
    }

    .admin-actions button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      padding: 0.75rem 1.25rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }

    .admin-actions button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }

    .download-button {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.85));
      color: #e0f2fe;
      box-shadow: 0 18px 40px rgba(37, 99, 235, 0.45);
    }

    .download-button:hover:not(:disabled),
    .download-button:focus-visible:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 22px 48px rgba(37, 99, 235, 0.55);
      outline: none;
    }

    .import-button,
    .clear-button {
      background: #facc15;
      color: #1f1600;
      box-shadow: 0 18px 36px rgba(250, 204, 21, 0.45);
      border-color: rgba(202, 138, 4, 0.6);
    }

    .clear-button {
      background: #fbbf24;
    }

    .import-button:hover:not(:disabled),
    .import-button:focus-visible:not(:disabled),
    .clear-button:hover:not(:disabled),
    .clear-button:focus-visible:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 22px 46px rgba(250, 204, 21, 0.55);
      outline: none;
    }

    .secondary-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-start;
    }

    .secondary-button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(30, 41, 59, 0.75);
      color: rgba(226, 232, 240, 0.9);
      padding: 0.6rem 1rem;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .secondary-button:hover,
    .secondary-button:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 16px 34px rgba(15, 23, 42, 0.4);
      outline: none;
    }

    .role-manager {
      display: grid;
      gap: 0.75rem;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 1.25rem;
      padding: 1.25rem;
    }

    .role-manager h2 {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .role-manager label {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.95rem;
      color: rgba(226, 232, 240, 0.85);
    }

    .role-manager input {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.65);
      color: #f8fafc;
      padding: 0.6rem 1rem;
      font-size: 1rem;
    }

    .role-action-button {
      border-radius: 999px;
      border: 1px solid rgba(34, 197, 94, 0.4);
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.9), rgba(22, 163, 74, 0.9));
      color: #052e16;
      font-weight: 600;
      font-size: 1rem;
      padding: 0.65rem 1.5rem;
      cursor: pointer;
      justify-self: start;
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }

    .role-action-button:hover:not(:disabled),
    .role-action-button:focus-visible:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 18px 36px rgba(34, 197, 94, 0.35);
      outline: none;
    }

    .role-revoke-button {
      border-color: rgba(248, 113, 113, 0.5);
      background: linear-gradient(135deg, rgba(248, 113, 113, 0.9), rgba(220, 38, 38, 0.9));
      color: #450a0a;
      box-shadow: 0 18px 36px rgba(248, 113, 113, 0.35);
    }

    .role-revoke-button:hover:not(:disabled),
    .role-revoke-button:focus-visible:not(:disabled) {
      box-shadow: 0 22px 42px rgba(248, 113, 113, 0.45);
    }

    .role-action-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }

    .status-message {
      font-size: 0.95rem;
      border-radius: 0.9rem;
      padding: 0.85rem 1rem;
      background: rgba(30, 41, 59, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .status-message[data-variant='success'] {
      background: rgba(21, 128, 61, 0.2);
      border-color: rgba(34, 197, 94, 0.55);
      color: #bbf7d0;
    }

    .status-message[data-variant='error'] {
      background: rgba(185, 28, 28, 0.25);
      border-color: rgba(248, 113, 113, 0.55);
      color: #fecaca;
    }

    .status-message[data-variant='warning'] {
      background: rgba(202, 138, 4, 0.25);
      border-color: rgba(250, 204, 21, 0.5);
      color: #fef3c7;
    }

    .status-message[data-variant='info'] {
      background: rgba(37, 99, 235, 0.2);
      border-color: rgba(96, 165, 250, 0.55);
      color: #dbeafe;
    }

    .user-directory {
      display: grid;
      gap: 0.75rem;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 1.25rem;
      padding: 1.25rem;
    }

    .user-directory-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .user-directory h2 {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .user-directory .user-list-status {
      margin-top: 0.25rem;
    }

    .user-list {
      list-style: none;
      display: grid;
      gap: 0.6rem;
      margin: 0;
      padding: 0;
      max-height: 260px;
      overflow-y: auto;
    }

    .user-list::-webkit-scrollbar {
      width: 8px;
    }

    .user-list::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.35);
      border-radius: 999px;
    }

    .user-list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.65rem 0.85rem;
      border-radius: 0.9rem;
      background: rgba(30, 41, 59, 0.55);
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .user-list-name {
      font-weight: 600;
      color: #f8fafc;
    }

    .user-role-badge {
      border-radius: 999px;
      padding: 0.2rem 0.65rem;
      font-size: 0.8rem;
      font-weight: 600;
      background: rgba(96, 165, 250, 0.2);
      color: #bfdbfe;
      border: 1px solid rgba(96, 165, 250, 0.4);
      text-transform: capitalize;
      white-space: nowrap;
    }

    .user-role-badge[data-role='admin'] {
      background: rgba(248, 113, 113, 0.2);
      color: #fecaca;
      border-color: rgba(248, 113, 113, 0.5);
    }

    .user-role-badge[data-role='setter'] {
      background: rgba(34, 197, 94, 0.25);
      color: #bbf7d0;
      border-color: rgba(34, 197, 94, 0.45);
    }

    .unauthorized {
      width: min(420px, 100%);
      background: rgba(185, 28, 28, 0.12);
      border: 1px solid rgba(248, 113, 113, 0.4);
      color: #fecaca;
      border-radius: 1rem;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      text-align: center;
    }

    @media (max-width: 640px) {
      body {
        padding: 1.5rem 1rem;
      }

      .admin-app {
        border-radius: 1rem;
        padding: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div id="authOverlay" class="auth-overlay" role="dialog" aria-modal="true">
    <h1>Sign in to manage the database</h1>
    <p>Admin access is required to import, export, or clear Ascend data.</p>
    <form id="authForm" class="auth-form">
      <div class="auth-field">
        <label for="authUsername">Username</label>
        <input id="authUsername" type="text" autocomplete="username" placeholder="your_username" required />
      </div>
      <div class="auth-field">
        <label for="authPassword">Password</label>
        <input id="authPassword" type="password" autocomplete="current-password" required />
      </div>
      <div id="authError" class="auth-error" role="alert"></div>
      <button id="authSubmit" class="auth-submit" type="submit">Sign In</button>
    </form>
  </div>

  <main id="adminApp" class="admin-app hidden" aria-hidden="true">
    <header class="admin-header">
      <h1>Database Administration</h1>
      <p>Download backups, import snapshots, or clear the database for a fresh start. These actions affect all setters and climbers.</p>
    </header>

    <section class="admin-actions">
      <button id="adminDumpButton" class="download-button" type="button">
        <span aria-hidden="true">💾</span>
        <span>Download database</span>
      </button>
      <button id="adminImportButton" class="import-button" type="button">
        <span aria-hidden="true">📥</span>
        <span>Import database backup</span>
      </button>
      <input id="adminImportInput" type="file" accept="application/json,.json" hidden aria-hidden="true" />
      <button id="adminClearButton" class="clear-button" type="button">
        <span aria-hidden="true">🧹</span>
        <span>Clear database</span>
      </button>
    </section>

    <section id="roleManager" class="role-manager">
      <h2>Manage user access</h2>
      <label for="roleUsernameInput">
        <span>Username</span>
        <input id="roleUsernameInput" type="text" placeholder="username" autocomplete="off" />
      </label>
      <button id="grantSetterButton" class="role-action-button" type="button">Grant setter role</button>
      <button
        id="revokeSetterButton"
        class="role-action-button role-revoke-button"
        type="button"
      >
        Revoke setter role
      </button>
      <button
        id="deleteUserButton"
        class="role-action-button role-revoke-button"
        type="button"
      >
        Delete user account
      </button>
      <p id="roleStatusMessage" class="status-message hidden" role="status" aria-live="polite"></p>
    </section>

    <section id="userDirectory" class="user-directory">
      <div class="user-directory-header">
        <h2>Current users</h2>
        <button id="refreshUserListButton" class="secondary-button" type="button">Refresh list</button>
      </div>
      <p
        id="userListStatus"
        class="status-message hidden user-list-status"
        role="status"
        aria-live="polite"
      ></p>
      <ul id="userList" class="user-list hidden"></ul>
    </section>

    <section class="secondary-actions">
      <button id="removeOrphanedAscentsButton" class="secondary-button" type="button">
        Remove user entries for deleted accounts
      </button>
      <button id="adminSetterToolsButton" class="secondary-button" type="button">Open setter tools</button>
      <button id="adminSignOutButton" class="secondary-button" type="button">Sign out</button>
    </section>

    <p id="adminStatusMessage" class="status-message hidden" role="status" aria-live="polite"></p>
  </main>

  <div id="unauthorizedNotice" class="unauthorized hidden" role="alert">
    <strong>Access denied.</strong>
    <p>Your account does not have admin permission for the database tools.</p>
    <button id="unauthorizedSignOut" class="secondary-button" type="button">Sign out</button>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
    import {
      getAuth,
      onAuthStateChanged,
      signInWithEmailAndPassword,
      signOut,
    } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
    import {
      getFirestore,
      collection,
      doc,
      getDoc,
      getDocs,
      query,
      where,
      limit,
      setDoc,
      deleteDoc,
      serverTimestamp,
      Timestamp,
      deleteField,
    } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
    import { firebaseConfig } from './config.js';

    const firebaseApp = initializeApp(firebaseConfig);
    const auth = getAuth(firebaseApp);
    const db = getFirestore(firebaseApp);

    const WALL_COLLECTION = 'walls';
    const ROUTE_COLLECTION = 'routes';
    const USER_COLLECTION = 'users';
    const ROUTE_SCORE_COLLECTION = 'routes_users_scores';
    const ROUTE_BETATIPS_COLLECTION = 'routes_users_betatips';
    const BETATIP_UPVOTES_SUBCOLLECTION = 'upvotes';
    const SUBCOLLECTIONS_FIELD = '__subcollections';

    const authOverlay = document.getElementById('authOverlay');
    const authForm = document.getElementById('authForm');
    const authUsername = document.getElementById('authUsername');
    const authPassword = document.getElementById('authPassword');
    const authError = document.getElementById('authError');
    const adminApp = document.getElementById('adminApp');
    const adminStatusMessage = document.getElementById('adminStatusMessage');
    const unauthorizedNotice = document.getElementById('unauthorizedNotice');
    const unauthorizedSignOut = document.getElementById('unauthorizedSignOut');
    const adminDumpButton = document.getElementById('adminDumpButton');
    const adminImportButton = document.getElementById('adminImportButton');
    const adminImportInput = document.getElementById('adminImportInput');
    const adminClearButton = document.getElementById('adminClearButton');
    const adminSignOutButton = document.getElementById('adminSignOutButton');
    const adminSetterToolsButton = document.getElementById('adminSetterToolsButton');
    const removeOrphanedAscentsButton = document.getElementById('removeOrphanedAscentsButton');
    const roleUsernameInput = document.getElementById('roleUsernameInput');
    const grantSetterButton = document.getElementById('grantSetterButton');
    const revokeSetterButton = document.getElementById('revokeSetterButton');
    const deleteUserButton = document.getElementById('deleteUserButton');
    const roleStatusMessage = document.getElementById('roleStatusMessage');
    const refreshUserListButton = document.getElementById('refreshUserListButton');
    const userListElement = document.getElementById('userList');
    const userListStatus = document.getElementById('userListStatus');

    const SYNTHETIC_EMAIL_DOMAIN = 'users.anuascend.local';
    const USERNAME_PATTERN = /^[a-z0-9_]{3,20}$/;

    let currentAdminUser = null;
    let currentAdminUsername = '';

    const normalizeUsername = (value) => {
      if (typeof value !== 'string') {
        return '';
      }
      return value.trim().toLowerCase();
    };

    const isValidUsername = (value) => USERNAME_PATTERN.test(normalizeUsername(value));

    const buildSyntheticEmail = (username) => {
      const normalized = normalizeUsername(username);
      return normalized ? `${normalized}@${SYNTHETIC_EMAIL_DOMAIN}` : '';
    };

    function setAdminStatus(message, variant = 'info') {
      if (!adminStatusMessage) {
        return;
      }

      if (!message) {
        adminStatusMessage.textContent = '';
        adminStatusMessage.classList.add('hidden');
        delete adminStatusMessage.dataset.variant;
        return;
      }

      adminStatusMessage.textContent = message;
      adminStatusMessage.classList.remove('hidden');
      if (variant) {
        adminStatusMessage.dataset.variant = variant;
      } else {
        delete adminStatusMessage.dataset.variant;
      }
    }

    function clearAdminStatus() {
      setAdminStatus('');
    }

    function setRoleStatus(message, variant = 'info') {
      if (!roleStatusMessage) {
        return;
      }

      if (!message) {
        roleStatusMessage.textContent = '';
        roleStatusMessage.classList.add('hidden');
        delete roleStatusMessage.dataset.variant;
        return;
      }

      roleStatusMessage.textContent = message;
      roleStatusMessage.classList.remove('hidden');
      if (variant) {
        roleStatusMessage.dataset.variant = variant;
      } else {
        delete roleStatusMessage.dataset.variant;
      }
    }

    function clearRoleStatus() {
      setRoleStatus('');
    }

    function setRoleControlsEnabled(enabled) {
      const allow = Boolean(enabled);
      if (grantSetterButton) {
        grantSetterButton.disabled = !allow;
      }
      if (revokeSetterButton) {
        revokeSetterButton.disabled = !allow;
      }
      if (deleteUserButton) {
        deleteUserButton.disabled = !allow;
      }
      if (roleUsernameInput) {
        roleUsernameInput.disabled = !allow;
      }
    }

    function resetRoleManagementUI(message = '', variant = 'info') {
      if (roleUsernameInput) {
        roleUsernameInput.value = '';
      }

      if (message) {
        setRoleStatus(message, variant);
      } else {
        clearRoleStatus();
      }
    }

    const isLikelyUsername = (value) => isValidUsername(value);

    resetRoleManagementUI();
    setRoleControlsEnabled(false);

    function setUserListStatus(message, variant = 'info') {
      if (!userListStatus) {
        return;
      }

      if (!message) {
        userListStatus.textContent = '';
        userListStatus.classList.add('hidden');
        delete userListStatus.dataset.variant;
        return;
      }

      userListStatus.textContent = message;
      userListStatus.classList.remove('hidden');
      if (variant) {
        userListStatus.dataset.variant = variant;
      } else {
        delete userListStatus.dataset.variant;
      }
    }

    function clearUserListStatus() {
      setUserListStatus('');
    }

    function setUserListControlsEnabled(enabled) {
      if (refreshUserListButton) {
        refreshUserListButton.disabled = !enabled;
      }
    }

    function resetUserListUI(message = '', variant = 'info') {
      if (userListElement) {
        userListElement.innerHTML = '';
        userListElement.classList.add('hidden');
      }

      if (message) {
        setUserListStatus(message, variant);
      } else {
        clearUserListStatus();
      }
    }

    function renderUserList(users) {
      if (!userListElement) {
        return;
      }

      userListElement.innerHTML = '';

      if (!Array.isArray(users) || users.length === 0) {
        userListElement.classList.add('hidden');
        setUserListStatus('No user profiles found.', 'info');
        return;
      }

      const fragment = document.createDocumentFragment();

      for (const user of users) {
        const listItem = document.createElement('li');
        listItem.className = 'user-list-item';
        listItem.title = user.uid;

        const nameSpan = document.createElement('span');
        nameSpan.className = 'user-list-name';
        nameSpan.textContent = user.displayName;
        listItem.appendChild(nameSpan);

        if (user.roleLabel) {
          const roleSpan = document.createElement('span');
          roleSpan.className = 'user-role-badge';
          roleSpan.dataset.role = user.roleValue;
          roleSpan.textContent = user.roleLabel;
          listItem.appendChild(roleSpan);
        }

        fragment.appendChild(listItem);
      }

      userListElement.appendChild(fragment);
      userListElement.classList.remove('hidden');
      const label = users.length === 1 ? 'user' : 'users';
      setUserListStatus(`Showing ${users.length} ${label}.`, 'info');
    }

    async function refreshUserList() {
      if (!currentAdminUser) {
        resetUserListUI('Admin access required to view user profiles.', 'warning');
        return;
      }

      if (userListElement) {
        userListElement.innerHTML = '';
        userListElement.classList.add('hidden');
      }
      setUserListStatus('Loading user profiles…', 'info');

      const previousDisabled = refreshUserListButton ? refreshUserListButton.disabled : false;
      if (refreshUserListButton) {
        refreshUserListButton.disabled = true;
      }

      try {
        const snapshot = await getDocs(collection(db, 'users'));
        const users = snapshot.docs.map((docSnap) => {
          const data = docSnap.data() || {};
          const storedUsername =
            typeof data.username === 'string' ? data.username.trim() : '';
          const normalizedUsername = normalizeUsername(storedUsername);
          const roleValueRaw =
            typeof data.role === 'string' ? data.role.trim().toLowerCase() : '';

          let roleLabel = '';
          if (roleValueRaw === 'admin') {
            roleLabel = 'Admin';
          } else if (roleValueRaw === 'setter') {
            roleLabel = 'Setter';
          } else if (roleValueRaw && roleValueRaw !== 'default') {
            roleLabel = roleValueRaw.charAt(0).toUpperCase() + roleValueRaw.slice(1);
          }

          return {
            uid: docSnap.id,
            username: normalizedUsername,
            displayName: normalizedUsername || '(no username)',
            roleValue: roleValueRaw || 'default',
            roleLabel,
          };
        });

        users.sort((a, b) => {
          const hasAName = Boolean(a.username);
          const hasBName = Boolean(b.username);
          if (hasAName && hasBName) {
            return a.username.localeCompare(b.username);
          }
          if (hasAName) {
            return -1;
          }
          if (hasBName) {
            return 1;
          }
          return a.uid.localeCompare(b.uid);
        });

        renderUserList(users);
      } catch (error) {
        console.error('Failed to load user list:', error);
        setUserListStatus('Failed to load user list. Please try again.', 'error');
      } finally {
        if (refreshUserListButton) {
          refreshUserListButton.disabled = previousDisabled || !currentAdminUser;
        }
      }
    }

    resetUserListUI('Sign in to load user profiles.', 'info');
    setUserListControlsEnabled(false);

    function setControlsEnabled(enabled) {
      const allow = Boolean(enabled);
      [
        adminDumpButton,
        adminImportButton,
        adminClearButton,
        removeOrphanedAscentsButton,
        refreshUserListButton,
      ].forEach((button) => {
        if (button) {
          button.disabled = !allow;
        }
      });
      if (adminImportInput) {
        adminImportInput.disabled = !allow;
      }
      setRoleControlsEnabled(allow && Boolean(currentAdminUser));
      setUserListControlsEnabled(allow && Boolean(currentAdminUser));
    }

    function showAuthOverlay(message = '') {
      if (message) {
        authError.textContent = message;
      }
      authOverlay.classList.remove('hidden');
      authOverlay.removeAttribute('aria-hidden');
      adminApp.classList.add('hidden');
      adminApp.setAttribute('aria-hidden', 'true');
      unauthorizedNotice.classList.add('hidden');
      clearAdminStatus();
      resetRoleManagementUI();
      resetUserListUI('Sign in to load user profiles.', 'info');
      setControlsEnabled(false);
      setUserListControlsEnabled(false);
    }

    function showAdminApp() {
      authOverlay.classList.add('hidden');
      authOverlay.setAttribute('aria-hidden', 'true');
      unauthorizedNotice.classList.add('hidden');
      adminApp.classList.remove('hidden');
      adminApp.removeAttribute('aria-hidden');
      resetRoleManagementUI('Enter the username of the user you want to manage.', 'info');
      setRoleControlsEnabled(Boolean(currentAdminUser));
      resetUserListUI('Loading user profiles…', 'info');
      setUserListControlsEnabled(Boolean(currentAdminUser));
    }

    function showUnauthorizedNotice() {
      adminApp.classList.add('hidden');
      adminApp.setAttribute('aria-hidden', 'true');
      unauthorizedNotice.classList.remove('hidden');
      setControlsEnabled(false);
      clearAdminStatus();
      resetRoleManagementUI('Admin access required to manage roles.', 'warning');
      resetUserListUI('Admin access required to view user profiles.', 'warning');
      setUserListControlsEnabled(false);
    }

    function resetImportInput() {
      if (adminImportInput) {
        adminImportInput.value = '';
      }
    }

    function serializeFirestoreValue(value) {
      if (value === undefined) {
        return null;
      }

      if (value === null) {
        return null;
      }

      if (value instanceof Date) {
        return Number.isNaN(value.getTime()) ? null : value.toISOString();
      }

      if (Array.isArray(value)) {
        return value.map((item) => serializeFirestoreValue(item));
      }

      if (value && typeof value === 'object') {
        if (typeof value.toDate === 'function') {
          const dateValue = value.toDate();
          if (dateValue instanceof Date && !Number.isNaN(dateValue.getTime())) {
            return dateValue.toISOString();
          }
          return dateValue;
        }

        if (value instanceof Uint8Array) {
          return Array.from(value);
        }

        if (typeof value.path === 'string' && typeof value.firestore === 'object') {
          return { __ref: value.path };
        }

        const serializedObject = {};
        for (const [key, nestedValue] of Object.entries(value)) {
          serializedObject[key] = serializeFirestoreValue(nestedValue);
        }
        return serializedObject;
      }

      return value;
    }

    function serializeFirestoreDocument(docSnap) {
      if (!docSnap?.exists?.()) {
        return null;
      }

      const rawData = docSnap.data();
      const serializedData = serializeFirestoreValue(rawData);

      if (serializedData && typeof serializedData === 'object' && !Array.isArray(serializedData)) {
        return { id: docSnap.id, ...serializedData };
      }

      return { id: docSnap.id, value: serializedData };
    }

    function looksLikeIsoDateString(value) {
      if (typeof value !== 'string') {
        return false;
      }

      return /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z/.test(value);
    }

    function deserializeFirestoreValue(value) {
      if (value === undefined) {
        return null;
      }

      if (value === null) {
        return null;
      }

      if (Array.isArray(value)) {
        return value.map((item) => deserializeFirestoreValue(item));
      }

      if (typeof value === 'string' && looksLikeIsoDateString(value)) {
        const parsed = new Date(value);
        if (!Number.isNaN(parsed.getTime())) {
          return Timestamp.fromDate(parsed);
        }
      }

      if (value && typeof value === 'object') {
        if (typeof value.__ref === 'string') {
          try {
            const refPath = value.__ref.trim();
            if (refPath) {
              const segments = refPath.split('/').filter(Boolean);
              if (segments.length >= 2) {
                return doc(db, ...segments);
              }
            }
          } catch (error) {
            console.warn('Unable to restore document reference from dump:', value.__ref, error);
          }
        }

        const deserialized = {};
        for (const [key, nestedValue] of Object.entries(value)) {
          deserialized[key] = deserializeFirestoreValue(nestedValue);
        }
        return deserialized;
      }

      return value;
    }

    function buildFirestorePayloadFromDumpEntry(entry) {
      if (!entry || typeof entry !== 'object') {
        return {};
      }

      const { id: _ignoredId, [SUBCOLLECTIONS_FIELD]: _ignoredSubcollections, ...rest } = entry;
      const candidate = deserializeFirestoreValue(rest);

      if (!candidate || typeof candidate !== 'object' || Array.isArray(candidate)) {
        return { value: candidate ?? null };
      }

      return candidate;
    }

    function ensureEntryHasId(entry, fallbackId = '') {
      const normalizedFallback = typeof fallbackId === 'string' ? fallbackId.trim() : '';

      if (!entry || typeof entry !== 'object' || Array.isArray(entry)) {
        if (!normalizedFallback) {
          return { value: entry ?? null };
        }

        return { id: normalizedFallback, value: entry ?? null };
      }

      const copy = { ...entry };
      const existingId = typeof copy.id === 'string' ? copy.id.trim() : '';

      if (existingId) {
        copy.id = existingId;
        return copy;
      }

      if (!normalizedFallback) {
        return copy;
      }

      copy.id = normalizedFallback;
      return copy;
    }

    function normalizeDumpEntries(entries) {
      if (!entries) {
        return [];
      }

      const normalized = [];

      const pushNormalizedEntry = (entry, fallbackId) => {
        const prepared = ensureEntryHasId(entry, fallbackId);
        if (prepared) {
          normalized.push(prepared);
        }
      };

      if (Array.isArray(entries)) {
        for (const entry of entries) {
          pushNormalizedEntry(entry);
        }
        return normalized;
      }

      if (typeof entries === 'object') {
        for (const [key, entry] of Object.entries(entries)) {
          pushNormalizedEntry(entry, key);
        }
        return normalized;
      }

      return normalized;
    }

    async function importSubcollections(parentRef, subcollections) {
      if (!parentRef || !subcollections || typeof subcollections !== 'object') {
        return { imported: 0, failed: 0 };
      }

      let imported = 0;
      let failed = 0;

      for (const [subKey, entries] of Object.entries(subcollections)) {
        if (!subKey) {
          continue;
        }

        const normalizedEntries = normalizeDumpEntries(entries);

        for (const entry of normalizedEntries) {
          if (!entry || typeof entry !== 'object') {
            failed += 1;
            continue;
          }

          const rawId = typeof entry.id === 'string' ? entry.id.trim() : '';
          if (!rawId) {
            failed += 1;
            continue;
          }

          try {
            const payload = buildFirestorePayloadFromDumpEntry(entry);
            const targetRef = doc(collection(parentRef, subKey), rawId);
            await setDoc(targetRef, payload);
            imported += 1;

            const nestedSubcollections = entry[SUBCOLLECTIONS_FIELD];
            if (nestedSubcollections && typeof nestedSubcollections === 'object') {
              const { imported: nestedImported, failed: nestedFailed } = await importSubcollections(
                targetRef,
                nestedSubcollections,
              );
              imported += nestedImported;
              failed += nestedFailed;
            }
          } catch (error) {
            console.error(`Failed to import document ${rawId} in ${parentRef.path}/${subKey}:`, error);
            failed += 1;
          }
        }
      }

      return { imported, failed };
    }

    const isPlainObject = (value) => Boolean(value && typeof value === 'object' && !Array.isArray(value));

    function buildRouteScoreSubcollection(entries) {
      if (!entries) {
        return null;
      }

      const normalized = {};

      const appendScore = (userId, value) => {
        const normalizedUserId = typeof userId === 'string' ? userId.trim() : '';
        if (!normalizedUserId) {
          return;
        }

        if (value === null || value === undefined) {
          return;
        }

        let candidate;

        if (isPlainObject(value)) {
          const { id: _ignoredId, userId: _ignoredUserId, uid: _ignoredUid, ...rest } = value;

          candidate = {};
          for (const [key, nestedValue] of Object.entries(rest)) {
            if (nestedValue !== undefined) {
              candidate[key] = nestedValue;
            }
          }
        } else if (typeof value === 'number' || typeof value === 'boolean') {
          candidate = { value };
        } else if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) {
            return;
          }
          candidate = { value: trimmed };
        } else {
          return;
        }

        if (!isPlainObject(candidate) || Object.keys(candidate).length === 0) {
          return;
        }

        normalized[normalizedUserId] = candidate;
      };

      if (Array.isArray(entries)) {
        for (const entry of entries) {
          if (!isPlainObject(entry)) {
            continue;
          }

          const candidateId =
            (typeof entry.id === 'string' && entry.id.trim()) ||
            (typeof entry.userId === 'string' && entry.userId.trim()) ||
            (typeof entry.uid === 'string' && entry.uid.trim()) ||
            '';

          const { id: _ignoredId, userId: _ignoredUserId, uid: _ignoredUid, ...rest } = entry;

          appendScore(candidateId, rest);
        }
      } else if (isPlainObject(entries)) {
        for (const [userId, value] of Object.entries(entries)) {
          if (isPlainObject(value)) {
            const { id: _ignoredId, userId: _ignoredUserId, uid: _ignoredUid, ...rest } = value;
            appendScore(userId, rest);
          } else {
            appendScore(userId, value);
          }
        }
      }

      return Object.keys(normalized).length > 0 ? normalized : null;
    }

    function moveRouteScoresToSubcollection(entry) {
      if (!isPlainObject(entry) || !('scores' in entry)) {
        return entry;
      }

      const existingSubcollections = entry[SUBCOLLECTIONS_FIELD];
      if (isPlainObject(existingSubcollections) && existingSubcollections.scores) {
        delete entry.scores;
        return entry;
      }

      const subcollectionEntries = buildRouteScoreSubcollection(entry.scores);
      delete entry.scores;

      if (!subcollectionEntries) {
        return entry;
      }

      if (!isPlainObject(entry[SUBCOLLECTIONS_FIELD])) {
        entry[SUBCOLLECTIONS_FIELD] = {};
      }

      entry[SUBCOLLECTIONS_FIELD].scores = subcollectionEntries;

      return entry;
    }

    async function importCollectionEntries(collectionKey, entries) {
      const normalizedEntries = normalizeDumpEntries(entries);

      let imported = 0;
      let failed = 0;

      for (const entry of normalizedEntries) {
        if (!entry || typeof entry !== 'object') {
          failed += 1;
          continue;
        }

        const rawId = typeof entry.id === 'string' ? entry.id.trim() : '';
        if (!rawId) {
          failed += 1;
          continue;
        }

        try {
          if (collectionKey === ROUTE_COLLECTION) {
            moveRouteScoresToSubcollection(entry);
          }

          const payload = buildFirestorePayloadFromDumpEntry(entry);

          if (shouldPreserveAdminIdentity(collectionKey, rawId, payload)) {
            console.info(
              `Skipping ${collectionKey}/${rawId} because it belongs to the currently authenticated admin.`,
            );
            continue;
          }

          const targetRef = doc(db, collectionKey, rawId);
          await setDoc(targetRef, payload);
          imported += 1;

          const subcollections = entry[SUBCOLLECTIONS_FIELD];
          if (subcollections && typeof subcollections === 'object') {
            const { imported: subImported, failed: subFailed } = await importSubcollections(
              targetRef,
              subcollections,
            );
            imported += subImported;
            failed += subFailed;
          }
        } catch (error) {
          console.error(`Failed to import document ${rawId} in ${collectionKey}:`, error);
          failed += 1;
        }
      }

      return { imported, failed };
    }

    function extractCollectionsFromDump(dump) {
      if (!dump || typeof dump !== 'object') {
        throw new Error('Invalid database dump.');
      }

      if (dump.collections && typeof dump.collections === 'object') {
        return dump.collections;
      }

      if (dump.data && typeof dump.data === 'object') {
        return dump.data;
      }

      throw new Error('Database dump is missing collection data.');
    }

    async function importDatabaseDump(dump) {
      const collections = extractCollectionsFromDump(dump);

      let processedCollections = 0;
      let totalImported = 0;
      let totalFailed = 0;

      for (const [collectionKey, entries] of Object.entries(collections)) {
        if (!collectionKey || !entries || (typeof entries === 'object' && entries.error)) {
          continue;
        }

        const { imported, failed } = await importCollectionEntries(collectionKey, entries);
        if (imported || failed) {
          processedCollections += 1;
          totalImported += imported;
          totalFailed += failed;
        }
      }

      return { processedCollections, totalImported, totalFailed };
    }

    async function demoteImportedAdmins() {
      const result = { demoted: 0, skipped: 0, failed: 0 };

      if (!currentAdminUser) {
        return result;
      }

      try {
        const adminQuery = query(collection(db, 'users'), where('role', '==', 'admin'));
        const snapshot = await getDocs(adminQuery);

        for (const docSnap of snapshot.docs) {
          if (!docSnap) {
            continue;
          }

          const targetUid = docSnap.id;
          if (targetUid === currentAdminUser.uid) {
            result.skipped += 1;
            continue;
          }

          try {
            await setDoc(
              doc(db, 'users', targetUid),
              {
                role: 'setter',
                updatedAt: serverTimestamp(),
              },
              { merge: true },
            );
            result.demoted += 1;
          } catch (docError) {
            console.error(`Failed to demote admin ${targetUid}:`, docError);
            result.failed += 1;
          }
        }
      } catch (error) {
        console.error('Failed to resolve admin roles after import:', error);
        result.failed += 1;
      }

      return result;
    }

    function normalizeDocDataCandidate(docData) {
      if (!docData || typeof docData !== 'object' || Array.isArray(docData)) {
        return {};
      }

      if (docData.value && typeof docData.value === 'object' && !Array.isArray(docData.value)) {
        return docData.value;
      }

      return docData;
    }

    function shouldPreserveAdminIdentity(collectionKey, docId, docData) {
      if (!docId) {
        return false;
      }

      const adminUid = currentAdminUser?.uid || '';
      const normalizedAdminUsername = normalizeUsername(currentAdminUsername);

      if (collectionKey === 'users') {
        if (adminUid && docId === adminUid) {
          return true;
        }

        try {
          const candidate = normalizeDocDataCandidate(docData);
          const storedUsername = normalizeUsername(
            typeof candidate.username === 'string' ? candidate.username : '',
          );

          if (normalizedAdminUsername && storedUsername === normalizedAdminUsername) {
            return true;
          }
        } catch (error) {
          console.warn('Unable to evaluate user document for preservation:', error);
        }
      }

      return false;
    }

    async function lookupUsernameByUid(uid) {
      if (!uid) {
        return '';
      }

      try {
        const userSnap = await getDoc(doc(db, 'users', uid));

        if (!userSnap.exists()) {
          return '';
        }

        const data = userSnap.data() || {};
        return normalizeUsername(typeof data.username === 'string' ? data.username : '');
      } catch (error) {
        console.error('Failed to look up username by UID:', error);
        return '';
      }
    }

    async function resolveUsernameForUser(user) {
      if (!user) {
        return '';
      }

      const displayName = normalizeUsername(user.displayName);
      if (isValidUsername(displayName)) {
        return displayName;
      }

      const mapped = await lookupUsernameByUid(user.uid);
      if (isValidUsername(mapped)) {
        return mapped;
      }

      const syntheticEmail = typeof user.email === 'string' ? user.email : '';
      if (syntheticEmail.endsWith(`@${SYNTHETIC_EMAIL_DOMAIN}`)) {
        const derived = normalizeUsername(
          syntheticEmail.slice(0, -(`@${SYNTHETIC_EMAIL_DOMAIN}`.length)),
        );
        if (isValidUsername(derived)) {
          return derived;
        }
      }

      return '';
    }

    async function fetchUserRole(user, username) {
      if (!user) {
        return 'default';
      }

      const normalizedUsername = normalizeUsername(username);
      if (!isValidUsername(normalizedUsername)) {
        return 'default';
      }

      try {
        const userRef = doc(db, 'users', user.uid);
        const userSnap = await getDoc(userRef);

        if (!userSnap.exists()) {
          return 'default';
        }

        const data = userSnap.data() || {};
        const storedRole = typeof data.role === 'string' ? data.role.trim().toLowerCase() : '';
        const storedUsername = normalizeUsername(
          typeof data.username === 'string' ? data.username : '',
        );

        if (storedUsername !== normalizedUsername) {
          try {
            const conflictSnapshot = await getDocs(
              query(collection(db, 'users'), where('username', '==', normalizedUsername), limit(1)),
            );

            if (conflictSnapshot.empty || conflictSnapshot.docs[0].id === user.uid) {
              await setDoc(
                userRef,
                {
                  username: normalizedUsername,
                  updatedAt: serverTimestamp(),
                },
                { merge: true },
              );
            }
          } catch (metadataError) {
            console.warn('Unable to update user metadata for role lookup:', metadataError);
          }
        } else if (!data.updatedAt) {
          try {
            await setDoc(
              userRef,
              { updatedAt: serverTimestamp() },
              { merge: true },
            );
          } catch (timestampError) {
            console.warn('Unable to update user timestamp for role lookup:', timestampError);
          }
        }

        return storedRole ? storedRole : 'default';
      } catch (error) {
        console.error('Failed to resolve user role:', error);
        return 'default';
      }
    }

    async function handleSignOut() {
      try {
        await signOut(auth);
      } catch (error) {
        console.error('Failed to sign out:', error);
      }
      currentAdminUser = null;
      currentAdminUsername = '';
      showAuthOverlay();
    }

    adminSignOutButton?.addEventListener('click', () => {
      void handleSignOut();
    });

    unauthorizedSignOut?.addEventListener('click', () => {
      void handleSignOut();
    });

    adminSetterToolsButton?.addEventListener('click', () => {
      window.location.href = 'setter.html';
    });

    refreshUserListButton?.addEventListener('click', () => {
      void refreshUserList();
    });

    function ensureImportIntentHandled() {
      const hash = window.location.hash.replace('#', '').toLowerCase();
      if (hash === 'import' && adminImportButton && !adminImportButton.disabled) {
        adminImportButton.focus();
      }
      if (hash === 'clear' && adminClearButton && !adminClearButton.disabled) {
        adminClearButton.focus();
      }
    }

    function downloadJson(filename, payload) {
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const tempLink = document.createElement('a');
      tempLink.href = url;
      tempLink.download = filename;
      document.body.appendChild(tempLink);
      tempLink.click();
      document.body.removeChild(tempLink);
      URL.revokeObjectURL(url);
    }

    if (grantSetterButton && roleUsernameInput) {
      grantSetterButton.addEventListener('click', async () => {
        const rawUsername = roleUsernameInput.value;
        const trimmedUsername = typeof rawUsername === 'string' ? rawUsername.trim() : '';

        if (!trimmedUsername) {
          setRoleStatus("Enter the user's username.", 'info');
          return;
        }

        if (!isLikelyUsername(trimmedUsername)) {
          setRoleStatus('Enter a valid username (letters, numbers, underscores).', 'error');
          return;
        }

        const normalizedUsername = normalizeUsername(trimmedUsername);

        try {
          setRoleControlsEnabled(false);
          setRoleStatus(`Granting setter role to ${trimmedUsername}…`, 'info');

          const snapshot = await getDocs(
            query(collection(db, 'users'), where('username', '==', normalizedUsername), limit(1)),
          );

          if (snapshot.empty) {
            setRoleStatus('No user found with that username.', 'error');
            return;
          }

          const userDoc = snapshot.docs[0];
          const userData = userDoc.data() || {};
          const targetUid = userDoc.id;

          if (!targetUid) {
            setRoleStatus('Unable to resolve that username to a user account.', 'error');
            return;
          }

          const existingRole =
            typeof userData.role === 'string' ? userData.role.trim().toLowerCase() : '';
          const existingUsername = normalizeUsername(
            typeof userData.username === 'string' ? userData.username : '',
          );

          if (existingRole === 'setter' && existingUsername === normalizedUsername) {
            setRoleStatus(`${trimmedUsername} is already a setter.`, 'success');
            roleUsernameInput.value = '';
            return;
          }

          await setDoc(
            doc(db, 'users', targetUid),
            {
              role: 'setter',
              username: normalizedUsername,
              updatedAt: serverTimestamp(),
            },
            { merge: true },
          );

          setRoleStatus(`Setter role granted to ${trimmedUsername}.`, 'success');
          roleUsernameInput.value = '';
          void refreshUserList();
        } catch (error) {
          console.error('Failed to grant setter role:', error);
          setRoleStatus('Unable to grant setter role. Please try again.', 'error');
        } finally {
          setRoleControlsEnabled(Boolean(currentAdminUser));
          if (roleUsernameInput && !roleUsernameInput.disabled) {
            roleUsernameInput.focus();
          }
        }
      });
    }

    if (revokeSetterButton && roleUsernameInput) {
      revokeSetterButton.addEventListener('click', async () => {
        const rawUsername = roleUsernameInput.value;
        const trimmedUsername = typeof rawUsername === 'string' ? rawUsername.trim() : '';

        if (!trimmedUsername) {
          setRoleStatus("Enter the user's username.", 'info');
          return;
        }

        if (!isLikelyUsername(trimmedUsername)) {
          setRoleStatus('Enter a valid username (letters, numbers, underscores).', 'error');
          return;
        }

        const normalizedUsername = normalizeUsername(trimmedUsername);

        try {
          setRoleControlsEnabled(false);
          setRoleStatus(`Revoking setter role from ${trimmedUsername}…`, 'info');

          const snapshot = await getDocs(
            query(collection(db, 'users'), where('username', '==', normalizedUsername), limit(1)),
          );

          if (snapshot.empty) {
            setRoleStatus('No user found with that username.', 'error');
            return;
          }

          const userDoc = snapshot.docs[0];
          const userData = userDoc.data() || {};
          const targetUid = userDoc.id;

          if (!targetUid) {
            setRoleStatus('Unable to resolve that username to a user account.', 'error');
            return;
          }

          if (currentAdminUser && targetUid === currentAdminUser.uid) {
            setRoleStatus('You cannot revoke your own setter role.', 'warning');
            return;
          }

          const existingRole =
            typeof userData.role === 'string' ? userData.role.trim().toLowerCase() : '';

          if (existingRole === 'admin') {
            setRoleStatus(
              `${trimmedUsername} is an admin. Admin roles must be managed separately.`,
              'warning',
            );
            return;
          }

          if (existingRole !== 'setter') {
            setRoleStatus(`${trimmedUsername} does not have setter access.`, 'info');
            return;
          }

          await setDoc(
            doc(db, 'users', targetUid),
            {
              role: deleteField(),
              updatedAt: serverTimestamp(),
            },
            { merge: true },
          );

          setRoleStatus(`Setter role revoked for ${trimmedUsername}.`, 'success');
          roleUsernameInput.value = '';
          void refreshUserList();
        } catch (error) {
          console.error('Failed to revoke setter role:', error);
          setRoleStatus('Unable to revoke setter role. Please try again.', 'error');
        } finally {
          setRoleControlsEnabled(Boolean(currentAdminUser));
          if (roleUsernameInput && !roleUsernameInput.disabled) {
            roleUsernameInput.focus();
          }
        }
      });
    }

    if (deleteUserButton && roleUsernameInput) {
      deleteUserButton.addEventListener('click', async () => {
        const rawUsername = roleUsernameInput.value;
        const trimmedUsername = typeof rawUsername === 'string' ? rawUsername.trim() : '';

        if (!trimmedUsername) {
          setRoleStatus("Enter the user's username.", 'info');
          return;
        }

        if (!isLikelyUsername(trimmedUsername)) {
          setRoleStatus('Enter a valid username (letters, numbers, underscores).', 'error');
          return;
        }

        const normalizedUsername = normalizeUsername(trimmedUsername);

        try {
          setRoleControlsEnabled(false);
          setRoleStatus(`Deleting account for ${trimmedUsername}…`, 'info');

          const snapshot = await getDocs(
            query(collection(db, 'users'), where('username', '==', normalizedUsername), limit(1)),
          );

          if (snapshot.empty) {
            setRoleStatus('No user found with that username.', 'error');
            return;
          }

          const userDoc = snapshot.docs[0];
          const userData = userDoc.data() || {};
          const targetUid = userDoc.id;

          if (!targetUid) {
            setRoleStatus('Unable to resolve that username to a user account.', 'error');
            return;
          }

          if (currentAdminUser && targetUid === currentAdminUser.uid) {
            setRoleStatus('You cannot delete your own admin account.', 'warning');
            return;
          }

          const existingRole =
            typeof userData.role === 'string' ? userData.role.trim().toLowerCase() : '';

          if (existingRole === 'admin') {
            setRoleStatus('Admin accounts cannot be deleted. Demote the user first.', 'warning');
            return;
          }

          const confirmed = window.confirm(
            `Delete the user profile for "${trimmedUsername}"? This action cannot be undone.`,
          );

          if (!confirmed) {
            setRoleStatus('User deletion cancelled.', 'info');
            return;
          }

          await deleteDoc(doc(db, 'users', targetUid));

          setRoleStatus(`Deleted user profile for ${trimmedUsername}.`, 'success');
          roleUsernameInput.value = '';
          void refreshUserList();
        } catch (error) {
          console.error('Failed to delete user:', error);
          setRoleStatus('Unable to delete user. Please try again.', 'error');
        } finally {
          setRoleControlsEnabled(Boolean(currentAdminUser));
          if (roleUsernameInput && !roleUsernameInput.disabled) {
            roleUsernameInput.focus();
          }
        }
      });
    }

    adminDumpButton?.addEventListener('click', async () => {
      if (adminDumpButton.disabled) {
        return;
      }

      setAdminStatus('Preparing database dump…', 'info');
      setControlsEnabled(false);

      try {
        const collectionsToExport = [
          { key: WALL_COLLECTION, ref: collection(db, WALL_COLLECTION) },
          { key: ROUTE_COLLECTION, ref: collection(db, ROUTE_COLLECTION) },
          { key: USER_COLLECTION, ref: collection(db, USER_COLLECTION) },
          { key: ROUTE_SCORE_COLLECTION, ref: collection(db, ROUTE_SCORE_COLLECTION) },
          {
            key: ROUTE_BETATIPS_COLLECTION,
            ref: collection(db, ROUTE_BETATIPS_COLLECTION),
            includeUpvotes: true,
          },
        ];

        const exportPayload = {
          metadata: {
            exportedAt: new Date().toISOString(),
            collections: collectionsToExport.map((entry) => entry.key),
          },
          data: {},
        };

        let hadCollectionError = false;

        for (const { key, ref, includeUpvotes } of collectionsToExport) {
          try {
            const snapshot = await getDocs(ref);
            if (includeUpvotes) {
              const documents = [];
              for (const docSnap of snapshot.docs) {
                const serialized = serializeFirestoreDocument(docSnap);
                if (!serialized) {
                  continue;
                }

                try {
                  const upvotesSnapshot = await getDocs(
                    collection(docSnap.ref, BETATIP_UPVOTES_SUBCOLLECTION),
                  );
                  const upvoteEntries = upvotesSnapshot.docs
                    .map((upvoteDoc) => serializeFirestoreDocument(upvoteDoc))
                    .filter(Boolean);

                  if (!serialized[SUBCOLLECTIONS_FIELD]) {
                    serialized[SUBCOLLECTIONS_FIELD] = {};
                  }
                  serialized[SUBCOLLECTIONS_FIELD][BETATIP_UPVOTES_SUBCOLLECTION] = upvoteEntries;
                } catch (subError) {
                  hadCollectionError = true;
                  console.error(
                    `Failed to export ${BETATIP_UPVOTES_SUBCOLLECTION} for betatip ${docSnap.id}:`,
                    subError,
                  );
                  if (!serialized[SUBCOLLECTIONS_FIELD]) {
                    serialized[SUBCOLLECTIONS_FIELD] = {};
                  }
                  serialized[SUBCOLLECTIONS_FIELD][BETATIP_UPVOTES_SUBCOLLECTION] = [];
                }

                documents.push(serialized);
              }
              exportPayload.data[key] = documents;
            } else {
              exportPayload.data[key] = snapshot.docs
                .map((docSnap) => serializeFirestoreDocument(docSnap))
                .filter(Boolean);
            }
          } catch (error) {
            hadCollectionError = true;
            console.error(`Failed to export ${key}:`, error);
            exportPayload.data[key] = {
              error: true,
              code: typeof error?.code === 'string' ? error.code : null,
              message: error?.message || 'Unable to export this collection.',
            };
          }
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `ascend-database-${timestamp}.json`;
        downloadJson(filename, exportPayload);

        if (hadCollectionError) {
          setAdminStatus('Database dump downloaded with some missing collections. Check console for details.', 'warning');
        } else {
          setAdminStatus('Database dump downloaded successfully.', 'success');
        }
      } catch (error) {
        console.error('Failed to generate database dump:', error);
        setAdminStatus('Failed to create database dump. Please try again.', 'error');
      } finally {
        setControlsEnabled(true);
      }
    });

    adminImportButton?.addEventListener('click', () => {
      if (adminImportButton.disabled) {
        return;
      }

      resetImportInput();
      adminImportInput?.click();
    });

    adminImportInput?.addEventListener('change', async (event) => {
      const file = event.target.files && event.target.files[0] ? event.target.files[0] : null;
      if (!file) {
        resetImportInput();
        return;
      }

      const sanitizedName = typeof file.name === 'string' && file.name.trim() ? file.name.trim() : 'selected file';
      setAdminStatus(`Importing database from “${sanitizedName}”…`, 'info');
      setControlsEnabled(false);

      try {
        const text = await file.text();
        let parsed;
        try {
          parsed = JSON.parse(text);
        } catch (error) {
          throw new Error('The selected file is not valid JSON.');
        }

        const { processedCollections, totalImported, totalFailed } = await importDatabaseDump(parsed);

        let statusVariant = 'info';
        let statusMessage = '';

        if (!processedCollections) {
          statusVariant = 'warning';
          statusMessage = 'No collections were imported from the selected file.';
        } else if (totalFailed > 0) {
          statusVariant = 'error';
          statusMessage = `Imported ${totalImported} documents with ${totalFailed} errors. Check the console for details.`;
        } else {
          statusVariant = 'success';
          statusMessage = `Imported ${totalImported} documents from ${processedCollections} collections.`;
        }

        const demotionSummary = await demoteImportedAdmins();
        if (demotionSummary) {
          if (demotionSummary.demoted > 0) {
            const demotedSuffix =
              demotionSummary.demoted === 1
                ? 'Demoted 1 admin role to setter.'
                : `Demoted ${demotionSummary.demoted} admin roles to setter.`;
            statusMessage = statusMessage ? `${statusMessage} ${demotedSuffix}` : demotedSuffix;
          }

          if (demotionSummary.failed > 0) {
            const failureSuffix =
              demotionSummary.failed === 1
                ? 'Failed to demote 1 admin role. Check the console for details.'
                : `Failed to demote ${demotionSummary.failed} admin roles. Check the console for details.`;
            statusMessage = statusMessage ? `${statusMessage} ${failureSuffix}` : failureSuffix;
            statusVariant = 'error';
          }
        }

        setAdminStatus(statusMessage, statusVariant);

      } catch (error) {
        console.error('Failed to import database dump:', error);
        const fallbackMessage = 'Failed to import database dump. Please try again.';
        const message = error && typeof error.message === 'string' && error.message.trim()
          ? error.message.trim()
          : fallbackMessage;
        setAdminStatus(message, 'error');
      } finally {
        resetImportInput();
        setControlsEnabled(true);
      }
    });

    removeOrphanedAscentsButton?.addEventListener('click', async () => {
      if (removeOrphanedAscentsButton.disabled) {
        return;
      }

      setAdminStatus(
        'Scanning route score records for user entries linked to missing accounts…',
        'info',
      );
      setControlsEnabled(false);

      try {
        const [usersSnapshot, routeScoresSnapshot] = await Promise.all([
          getDocs(collection(db, USER_COLLECTION)),
          getDocs(collection(db, ROUTE_SCORE_COLLECTION)),
        ]);

        const existingUserIds = new Set();
        usersSnapshot.forEach((userDoc) => {
          if (userDoc?.id) {
            existingUserIds.add(userDoc.id);
          }
        });

        let checkedScoreDocs = 0;
        let cleanedScoreDocs = 0;
        let removedEntries = 0;

        for (const scoreDoc of routeScoresSnapshot.docs) {
          checkedScoreDocs += 1;
          const scoresData = scoreDoc.data();

          if (!scoresData || typeof scoresData !== 'object' || Array.isArray(scoresData)) {
            continue;
          }

          const updates = {};
          let hasChanges = false;

          for (const [userId, userEntry] of Object.entries(scoresData)) {
            if (typeof userId !== 'string' || !userId) {
              continue;
            }

            const entryIsScore =
              userEntry === null ||
              (userEntry &&
                typeof userEntry === 'object' &&
                !Array.isArray(userEntry) &&
                ('grade' in userEntry || 'ascended' in userEntry));

            if (!entryIsScore) {
              continue;
            }

            if (!existingUserIds.has(userId)) {
              updates[userId] = deleteField();
              hasChanges = true;
              removedEntries += 1;
            }
          }

          if (hasChanges) {
            await setDoc(scoreDoc.ref, updates, { merge: true });
            cleanedScoreDocs += 1;
          }
        }

        if (removedEntries === 0) {
          setAdminStatus(
            `Checked ${checkedScoreDocs} route score documents. No orphaned user entries found.`,
            'info',
          );
        } else {
          const docLabel = cleanedScoreDocs === 1 ? 'route score document' : 'route score documents';
          const entryLabel = removedEntries === 1 ? 'entry' : 'entries';
          setAdminStatus(
            `Removed ${removedEntries} orphaned user ${entryLabel} across ${cleanedScoreDocs} ${docLabel}.`,
            'success',
          );
        }
      } catch (error) {
        console.error('Failed to remove orphaned user entries:', error);
        setAdminStatus('Failed to remove orphaned user entries. Check console for details.', 'error');
      } finally {
        setControlsEnabled(true);
      }
    });

    adminClearButton?.addEventListener('click', async () => {
      if (adminClearButton.disabled) {
        return;
      }

      const confirmed = window.confirm(
        'Clear the database? This will permanently delete walls, routes, and user accounts. This cannot be undone.',
      );

      if (!confirmed) {
        return;
      }

      setAdminStatus('Clearing database…', 'info');
      setControlsEnabled(false);

      try {
        const collectionsToClear = [
          { key: WALL_COLLECTION, ref: collection(db, WALL_COLLECTION) },
          { key: ROUTE_COLLECTION, ref: collection(db, ROUTE_COLLECTION) },
          { key: USER_COLLECTION, ref: collection(db, USER_COLLECTION) },
          { key: ROUTE_SCORE_COLLECTION, ref: collection(db, ROUTE_SCORE_COLLECTION) },
          {
            key: ROUTE_BETATIPS_COLLECTION,
            ref: collection(db, ROUTE_BETATIPS_COLLECTION),
            hasUpvotes: true,
          },
        ];

        let deletedCount = 0;
        let failureCount = 0;

        for (const { key, ref, hasUpvotes } of collectionsToClear) {
          try {
            const snapshot = await getDocs(ref);
            for (const docSnap of snapshot.docs) {
              if (shouldPreserveAdminIdentity(key, docSnap.id, docSnap.data ? docSnap.data() : {})) {
                continue;
              }
              try {
                if (hasUpvotes) {
                  try {
                    const upvotesSnapshot = await getDocs(
                      collection(docSnap.ref, BETATIP_UPVOTES_SUBCOLLECTION),
                    );
                    for (const upvoteDoc of upvotesSnapshot.docs) {
                      try {
                        await deleteDoc(upvoteDoc.ref);
                        deletedCount += 1;
                      } catch (upvoteError) {
                        console.error(
                          `Failed to delete upvote ${upvoteDoc.id} for betatip ${docSnap.id}:`,
                          upvoteError,
                        );
                        failureCount += 1;
                      }
                    }
                  } catch (subcollectionError) {
                    console.error(
                      `Failed to fetch upvotes for betatip ${docSnap.id}:`,
                      subcollectionError,
                    );
                    failureCount += 1;
                  }
                }

                await deleteDoc(docSnap.ref);
                deletedCount += 1;
              } catch (docError) {
                console.error(`Failed to delete ${docSnap.id} in ${key}:`, docError);
                failureCount += 1;
              }
            }
          } catch (collectionError) {
            console.error(`Failed to clear ${key}:`, collectionError);
            failureCount += 1;
          }
        }

        if (deletedCount === 0 && failureCount === 0) {
          setAdminStatus('Database was already empty.', 'info');
        } else if (failureCount > 0) {
          setAdminStatus(
            `Cleared ${deletedCount} documents with ${failureCount} errors. Check the console for details.`,
            'error',
          );
        } else {
          setAdminStatus(`Cleared ${deletedCount} documents from the database.`, 'success');
        }
      } catch (error) {
        console.error('Failed to clear database:', error);
        setAdminStatus('Failed to clear database. Please try again.', 'error');
      } finally {
        setControlsEnabled(true);
      }
    });

    authForm?.addEventListener('submit', async (event) => {
      event.preventDefault();
      const normalizedUsername = normalizeUsername(authUsername.value);
      const password = authPassword.value;

      if (!isValidUsername(normalizedUsername)) {
        authError.textContent = 'Enter a valid username (letters, numbers, underscores).';
        return;
      }

      if (!password) {
        authError.textContent = 'Enter your password to continue.';
        return;
      }

      authError.textContent = '';

      try {
        const email = buildSyntheticEmail(normalizedUsername);
        await signInWithEmailAndPassword(auth, email, password);
      } catch (error) {
        let message = 'Unable to sign in. Please try again.';
        switch (error?.code) {
          case 'auth/user-not-found':
          case 'auth/wrong-password':
            message = 'Invalid username or password.';
            break;
          case 'auth/too-many-requests':
            message = 'Too many attempts. Try again later.';
            break;
          default:
            if (error?.message) {
              message = error.message;
            }
        }
        authError.textContent = message;
      }
    });

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        currentAdminUser = null;
        currentAdminUsername = '';
        showAuthOverlay();
        authForm?.reset();
        return;
      }

      const resolvedUsername = await resolveUsernameForUser(user);
      if (!isValidUsername(resolvedUsername)) {
        await handleSignOut();
        authError.textContent = 'Unable to resolve your username. Please contact an admin.';
        return;
      }

      const role = await fetchUserRole(user, resolvedUsername);
      if (role !== 'admin') {
        currentAdminUser = null;
        currentAdminUsername = '';
        showUnauthorizedNotice();
        return;
      }

      currentAdminUser = user;
      currentAdminUsername = resolvedUsername;
      showAdminApp();
      setControlsEnabled(true);
      void refreshUserList();
      clearAdminStatus();
      ensureImportIntentHandled();
    });
  </script>
</body>
</html>
