<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ascend</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #000;
        --wall-background: url('./location/New Wall.jpg');
        background-image: var(--wall-background);
        background-position: center;
        background-size: 100% 100%;
        background-repeat: no-repeat;
        background-attachment: fixed;
        color: #fff;
        overflow: hidden;
      }

      .hidden {
        display: none !important;
      }

      .canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .canvas-container.scrollable {
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
      }

      .focus-footer {
        position: absolute;
        left: 50%;
        bottom: 1.25rem;
        transform: translateX(-50%);
        z-index: 7;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .clear-focus-button {
        pointer-events: auto;
        border-radius: 999px;
        border: 1px solid rgba(126, 217, 87, 0.75);
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.95), rgba(126, 217, 87, 0.7));
        color: #0c1905;
        font-weight: 600;
        padding: 0.6rem 1.5rem;
        font-size: 0.95rem;
        cursor: pointer;
        box-shadow: 0 14px 30px rgba(126, 217, 87, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          border-color 0.2s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        letter-spacing: 0.01em;
      }

      .clear-focus-button:hover,
      .clear-focus-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 18px 36px rgba(126, 217, 87, 0.4);
        outline: none;
        border-color: rgba(126, 217, 87, 0.9);
        background: linear-gradient(135deg, rgba(126, 217, 87, 1), rgba(126, 217, 87, 0.82));
      }

      .tutorial-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
        background: rgba(8, 12, 9, 0);
        z-index: 30;
        pointer-events: none;
      }

      .tutorial-overlay.is-bottom-aligned {
        align-items: flex-end;
      }

      .tutorial-overlay.is-bottom-aligned .tutorial-card {
        margin-bottom: clamp(1.5rem, 8vh, 4rem);
      }

      .tutorial-card {
        width: min(520px, 100%);
        background: rgba(12, 18, 15, 0.95);
        border-radius: 1rem;
        padding: 1.75rem;
        display: flex;
        flex-direction: column;
        gap: 1.15rem;
        box-shadow: 0 30px 60px rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(126, 217, 87, 0.2);
        pointer-events: auto;
      }

      .tutorial-illustration {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
        width: 100%;
        margin-top: 0.35rem;
      }

      .tutorial-portrait-graphic {
        width: 130px;
        display: flex;
        justify-content: center;
      }

      .tutorial-portrait-graphic svg {
        width: 100%;
        height: auto;
        display: block;
      }

      .tutorial-portrait-graphic .tutorial-portrait-finger {
        animation: tutorial-portrait-finger-swipe 2.6s ease-in-out infinite;
        transform-box: fill-box;
        transform-origin: center;
      }

      @keyframes tutorial-portrait-finger-swipe {
        0% {
          transform: translateX(-14px);
        }
        50% {
          transform: translateX(14px);
        }
        100% {
          transform: translateX(-14px);
        }
      }

      .tutorial-portrait-graphic .tutorial-portrait-arrow {
        stroke: rgba(126, 217, 87, 0.85);
        stroke-width: 4;
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
        opacity: 0.85;
      }

      .tutorial-portrait-graphic .tutorial-portrait-arrow--left,
      .tutorial-portrait-graphic .tutorial-portrait-arrow--right {
        animation: tutorial-portrait-arrow 2.6s ease-in-out infinite;
      }

      .tutorial-portrait-graphic .tutorial-portrait-arrow--right {
        animation-delay: 0.1s;
      }

      @keyframes tutorial-portrait-arrow {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 1;
        }
      }

      .tutorial-illustration-caption {
        font-size: 0.78rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(226, 232, 240, 0.75);
      }

      .tutorial-phone {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.85));
        border-radius: 1.9rem;
        padding: 0.85rem;
        box-shadow: 0 16px 36px rgba(15, 23, 42, 0.5);
        border: 1px solid rgba(148, 163, 184, 0.35);
      }

      .tutorial-phone--portrait {
        width: 120px;
        height: 220px;
      }

      .tutorial-phone--landscape {
        width: 110px;
        height: 60px;
        border-radius: 1.4rem;
      }

      .tutorial-phone-screen {
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 1.35rem;
        background: radial-gradient(circle at 20% 20%, rgba(148, 163, 184, 0.35), transparent 60%),
          radial-gradient(circle at 80% 25%, rgba(59, 130, 246, 0.32), transparent 65%),
          linear-gradient(160deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.6));
        border: 1px solid rgba(100, 116, 139, 0.4);
        overflow: hidden;
      }

      .tutorial-phone-screen::before,
      .tutorial-phone-screen::after {
        content: '';
        position: absolute;
        border-radius: 50%;
        background: rgba(126, 217, 87, 0.45);
        opacity: 0.85;
      }

      .tutorial-phone-screen::before {
        width: 36%;
        height: 36%;
        top: 16%;
        left: 20%;
        box-shadow: 0 0 24px rgba(126, 217, 87, 0.35);
      }

      .tutorial-phone-screen::after {
        width: 28%;
        height: 28%;
        bottom: 18%;
        right: 22%;
        background: rgba(59, 130, 246, 0.45);
        box-shadow: 0 0 22px rgba(59, 130, 246, 0.35);
      }

      .tutorial-progress {
        font-size: 0.85rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(126, 217, 87, 0.8);
      }

      .tutorial-title {
        font-size: 1.35rem;
        font-weight: 700;
        line-height: 1.3;
      }

      .tutorial-description {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        color: rgba(248, 250, 252, 0.92);
        font-size: 0.98rem;
        line-height: 1.55;
      }

      .tutorial-description p {
        margin: 0;
      }

      .tutorial-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: flex-end;
      }

      .tutorial-button {
        border-radius: 999px;
        border: none;
        padding: 0.65rem 1.4rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          color 0.2s ease, border-color 0.2s ease;
      }

      .tutorial-primary {
        background: #7ed957;
        color: #0c1a07;
        box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
      }

      .tutorial-primary:hover,
      .tutorial-primary:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 18px 30px rgba(126, 217, 87, 0.35);
        outline: none;
      }

      .tutorial-secondary {
        background: transparent;
        color: rgba(248, 250, 252, 0.9);
        border: 1px solid rgba(248, 250, 252, 0.3);
      }

      .tutorial-secondary:hover,
      .tutorial-secondary:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        outline: none;
        border-color: rgba(248, 250, 252, 0.6);
      }

      .tutorial-highlight {
        box-shadow: 0 0 0 5px rgba(126, 217, 87, 0.75), 0 0 26px rgba(126, 217, 87, 0.6);
      }

      .tutorial-illuminated {
        animation: tutorial-illuminate 1.2s ease-in-out infinite;
        box-shadow: 0 0 0 7px rgba(126, 217, 87, 0.85), 0 0 36px rgba(126, 217, 87, 0.7);
      }

      .tutorial-pointer {
        position: fixed;
        width: 102px;
        height: 162px;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        z-index: 60;
        transform: translate(-50%, 0);
      }

      .tutorial-pointer.hidden {
        display: none;
      }

      .tutorial-pointer svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 10px 18px rgba(0, 0, 0, 0.45));
        animation: tutorial-pointer-bounce 1.05s ease-in-out infinite;
      }

      @media (max-width: 768px) {
        .tutorial-pointer {
          width: 51px;
          height: 81px;
        }
      }

      @keyframes tutorial-pointer-bounce {
        0%,
        100% {
          transform: translateY(4px);
        }
        50% {
          transform: translateY(-6px);
        }
      }

      @keyframes tutorial-illuminate {
        0%,
        100% {
          box-shadow: 0 0 0 6px rgba(126, 217, 87, 0.7), 0 0 28px rgba(126, 217, 87, 0.55);
        }
        50% {
          box-shadow: 0 0 0 10px rgba(255, 140, 66, 0.85), 0 0 42px rgba(255, 140, 66, 0.75);
        }
      }

      .tutorial-route-pulse {
        animation: tutorial-route-pulse 1.8s ease-in-out infinite;
      }

      @keyframes tutorial-route-pulse {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.35);
        }
      }

      .is-tutorial-disabled {
        pointer-events: none !important;
      }

      canvas {
        display: block;
        height: 100%;
        width: auto;
        min-width: 100%;
      }

      .auth-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        padding: 1.5rem;
        backdrop-filter: blur(2px);
        z-index: 10;
      }

      .auth-card {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1rem;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: min(90vw, 360px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      }

      .auth-card h1 {
        font-size: 1.4rem;
        text-align: center;
      }

      .auth-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.95rem;
      }

      .auth-field input {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        padding: 0.65rem 1rem;
        font-size: 1rem;
      }

      .auth-submit {
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1rem;
        background: #7ed957;
        color: #111;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .auth-submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
      }

      .auth-switch {
        font-size: 0.9rem;
        text-align: center;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        justify-content: center;
        align-items: center;
      }

      .auth-switch button {
        background: none;
        border: none;
        color: #7ed957;
        font-weight: 600;
        cursor: pointer;
        text-decoration: underline;
      }

      .auth-error {
        min-height: 1.25rem;
        color: #ff7a7a;
        text-align: center;
        font-size: 0.85rem;
      }

      .app-header {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 5;
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      .header-icon-button {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
        color: #fff;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          border-color 0.2s ease;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        padding: 0;
      }

      .header-icon-button svg {
        width: 20px;
        height: 20px;
        display: block;
      }

      .header-icon-button:hover,
      .header-icon-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
        outline: none;
      }

      .view-mode-toggle-group {
        display: inline-flex;
        align-items: center;
        gap: 0.45rem;
      }

      .view-mode-toggle-group .view-toggle-option {
        position: relative;
      }

      .view-mode-toggle-group .view-toggle-option .view-toggle-icon {
        display: none;
        width: 20px;
        height: 20px;
      }

      .view-mode-toggle-group .view-toggle-option[data-view-mode='grade-colors']
        .view-toggle-icon--grades,
      .view-mode-toggle-group .view-toggle-option[data-view-mode='hold-colors']
        .view-toggle-icon--holds {
        display: block;
      }

      .view-mode-toggle-group .view-toggle-option .view-toggle-icon svg {
        width: 100%;
        height: 100%;
      }

      .view-mode-toggle-group .view-toggle-option.is-active {
        background: linear-gradient(135deg, rgba(148, 163, 184, 0.45), rgba(30, 41, 59, 0.65));
        color: #fff;
        border-color: rgba(148, 163, 184, 0.55);
        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.4);
      }

      .location-modal {
        position: fixed;
        inset: 0;
        background: transparent;
        backdrop-filter: none;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        z-index: 20;
      }

      .location-modal.hidden {
        display: none !important;
      }

      .location-modal.is-top-aligned {
        align-items: flex-start;
        padding-top: clamp(4.5rem, 14vh, 7.5rem);
      }

      .location-modal.is-top-aligned .location-modal-content {
        margin-top: 0;
      }

      .progression-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(3px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        z-index: 20;
      }

      .progression-modal.hidden {
        display: none !important;
      }

      .location-modal-content {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1.25rem;
        width: min(720px, 92vw);
        max-height: 90vh;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .progression-modal-content {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1.25rem;
        width: min(540px, 92vw);
        max-height: 90vh;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .location-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .location-modal-title {
        font-size: 1.35rem;
        font-weight: 700;
      }

      .progression-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .progression-modal-title {
        font-size: 1.35rem;
        font-weight: 700;
      }

      .location-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.4rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .location-modal-close:hover,
      .location-modal-close:focus-visible {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .progression-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.4rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .progression-modal-close:hover,
      .progression-modal-close:focus-visible {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .location-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
      }

      .progression-description {
        color: rgba(255, 255, 255, 0.75);
        font-size: 0.95rem;
      }

      .progression-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        overflow-y: auto;
        padding-right: 0.25rem;
      }

      .progression-entry {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border-radius: 0.85rem;
        background: rgba(255, 255, 255, 0.08);
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      }

      .progression-entry:hover {
        background: rgba(255, 255, 255, 0.14);
        transform: translateY(-1px);
      }

      .progression-entry:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.16);
      }

      .progression-entry.is-focused {
        background: rgba(255, 255, 255, 0.18);
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.45);
      }

      .progression-entry-grade {
        font-variant-numeric: tabular-nums;
        font-weight: 600;
        min-width: 3ch;
        text-align: right;
      }

      .progression-entry-name {
        font-size: 1rem;
        font-weight: 600;
      }

      .progression-entry-status {
        font-size: 1.15rem;
        width: 1.5rem;
        text-align: center;
        color: rgba(255, 255, 255, 0.45);
      }

      .progression-entry-status.is-ascended {
        color: #7ed957;
      }

      .progression-empty-message {
        text-align: center;
        color: rgba(255, 255, 255, 0.75);
        font-size: 0.95rem;
        padding: 2rem 0;
      }

      .location-option {
        border: none;
        border-radius: 1rem;
        padding: 0;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        cursor: pointer;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        text-align: left;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .location-option:hover,
      .location-option:focus-visible {
        transform: translateY(-4px);
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.4);
        outline: none;
        background: rgba(255, 255, 255, 0.18);
      }

      .location-option[aria-current='true'] {
        box-shadow: 0 0 0 3px rgba(126, 217, 87, 0.75);
        background: rgba(126, 217, 87, 0.18);
      }

      .location-option-preview {
        position: relative;
        width: 100%;
        padding-top: 66%;
        background-size: cover;
        background-position: center;
      }

      .location-option-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.9rem 1rem;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      .location-option-name {
        flex: 1;
      }

      .info-wrapper {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 6;
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
      }

      .info-button {
        width: 40px;
        height: 40px;
        border: 2px solid rgba(255, 255, 255, 0.35);
        background: linear-gradient(135deg, rgba(36, 36, 36, 0.9), rgba(92, 92, 92, 0.45));
        color: #f8fafc;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease,
          background 0.2s ease, color 0.2s ease;
      }

      .info-button.is-active {
        border-color: rgba(126, 217, 87, 0.65);
        background: #7ed957;
        color: #0c1905;
        box-shadow: 0 8px 22px rgba(126, 217, 87, 0.35);
      }

      .info-button:hover,
      .info-button:focus-visible {
        transform: translateY(-2px);
      }

      .info-button:not(.is-active):hover,
      .info-button:not(.is-active):focus-visible {
        border-color: rgba(255, 255, 255, 0.55);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.5);
        outline: none;
      }

      .info-button.is-active:hover,
      .info-button.is-active:focus-visible {
        box-shadow: 0 12px 28px rgba(126, 217, 87, 0.45);
        border-color: rgba(126, 217, 87, 0.9);
        outline: none;
      }

      .info-button.is-active:focus-visible {
        box-shadow: 0 0 0 4px rgba(126, 217, 87, 0.25), 0 12px 28px rgba(126, 217, 87, 0.45);
      }

      .setter-link {
        text-decoration: none;
        color: inherit;
      }

      .setter-link.header-icon-button {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.82), rgba(255, 255, 255, 0.4));
        color: #0c1905;
        border-color: rgba(255, 255, 255, 0.6);
      }

      .walls-button {
        backdrop-filter: blur(6px);
      }

      .login-link {
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.85), rgba(126, 217, 87, 0.55));
        color: #0f1a08;
        border-color: rgba(183, 244, 153, 0.65);
      }

      .login-link:hover,
      .login-link:focus-visible {
        border-color: rgba(206, 248, 178, 0.9);
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.95), rgba(126, 217, 87, 0.65));
      }

      .info-popover {
        position: absolute;
        top: calc(100% + 0.75rem);
        left: 0;
        width: min(280px, 70vw);
        padding: 0.9rem 1rem;
        border-radius: 0.75rem;
        background: rgba(0, 0, 0, 0.85);
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.85rem;
        line-height: 1.4;
        text-align: left;
        pointer-events: auto;
      }

      .info-popover p {
        color: rgba(255, 255, 255, 0.85);
      }

      .info-popover p + p {
        margin-top: 0.5rem;
      }

      .info-highlights {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 40;
      }

      .info-callout {
        --info-callout-bg: rgba(10, 16, 11, 0.94);
        --info-callout-border: rgba(126, 217, 87, 0.55);
        position: absolute;
        min-width: 200px;
        max-width: 260px;
        padding: 0.85rem 1rem;
        border-radius: 0.85rem;
        background: var(--info-callout-bg);
        border: 1px solid var(--info-callout-border);
        color: rgba(255, 255, 255, 0.94);
        box-shadow: 0 18px 42px rgba(0, 0, 0, 0.45);
        transform: translate(-50%, 0);
        pointer-events: none;
        line-height: 1.45;
      }

      .info-callout::before {
        content: '';
        position: absolute;
        width: 0;
        height: 0;
        border: 10px solid transparent;
        left: var(--callout-arrow-offset, 50%);
        transform: translateX(-50%);
      }

      .info-callout[data-arrow='top']::before {
        top: -18px;
        border-bottom-color: var(--info-callout-bg);
      }

      .info-callout[data-arrow='bottom']::before {
        bottom: -18px;
        border-top-color: var(--info-callout-bg);
      }

      .info-callout strong {
        display: block;
        font-weight: 600;
        letter-spacing: 0.01em;
        margin-bottom: 0.35rem;
      }

      .info-callout p {
        font-size: 0.82rem;
        color: rgba(255, 255, 255, 0.88);
      }

      .info-callout p + p {
        margin-top: 0.4rem;
      }

      .info-callout-chart-wrapper {
        margin-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .info-callout-chart {
        display: flex;
        align-items: flex-end;
        gap: 0.18rem;
        height: 52px;
        padding: 0 0.15rem;
      }

      .info-callout-chart-bar {
        flex: 1;
        min-width: 0.15rem;
        border-radius: 0.4rem 0.4rem 0 0;
        background: #2f9e44;
        height: 45%;
        opacity: 0.95;
      }

      .info-callout-chart-bar:first-child {
        border-top-left-radius: 0.45rem;
      }

      .info-callout-chart-bar:last-child {
        border-top-right-radius: 0.45rem;
      }

      .info-callout-chart-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.7rem;
        color: rgba(255, 255, 255, 0.75);
        padding: 0 0.15rem;
        letter-spacing: 0.02em;
      }

      .nav-links {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .nav-links a {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.55));
        color: #0c1905;
        border-color: rgba(255, 255, 255, 0.65);
        box-shadow: 0 10px 22px rgba(255, 255, 255, 0.25);
      }

      .nav-links a:hover,
      .nav-links a:focus-visible {
        box-shadow: 0 14px 28px rgba(255, 255, 255, 0.35);
      }

      .login-link {
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.85), rgba(126, 217, 87, 0.6));
        border-color: rgba(183, 244, 153, 0.7);
      }

      .route-tooltip {
        --tooltip-accent: #7ed957;
        --tooltip-accent-rgb: 126, 217, 87;
        --tooltip-accent-soft: rgba(126, 217, 87, 0.18);
        --tooltip-accent-strong: rgba(126, 217, 87, 0.85);
        --tooltip-on-accent: #000;
        --tooltip-foreground: #fff;
        --tooltip-soft-foreground: #000;
        --tooltip-muted-foreground: #d1d5db;
        --tooltip-surface: #0e150f;
        --tooltip-border-color: #7ed957;
        --tooltip-grade-size: 4.5rem;
        position: fixed;
        pointer-events: none;
        color: var(--tooltip-foreground, #fff);
        padding: 1.25rem;
        border-radius: 0.75rem;
        font-size: 0.85rem;
        line-height: 1.4;
        width: 50vw;
        max-width: 90vw;
        max-height: calc(90vh - 2rem);
        z-index: 6;
        opacity: 0;
        transform: translate(-50%, -12px);
        transition: opacity 0.12s ease, transform 0.12s ease;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        overflow: hidden;
        background-color: var(--tooltip-surface, #0e150f);
        background: var(--tooltip-surface, #0e150f);
        border: 1px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.45);
      }

      .route-tooltip .tooltip-content {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        overflow-y: auto;
        padding-right: 0.25rem;
        flex: 1;
        min-height: 0;
      }

      .route-tooltip .tooltip-content::-webkit-scrollbar {
        width: 0.5rem;
      }

      .route-tooltip .tooltip-content::-webkit-scrollbar-thumb {
        background: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.4);
        border-radius: 999px;
      }

      .route-tooltip .tooltip-content::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.25);
      }

      .route-tooltip.pinned {
        pointer-events: auto;
      }

      .route-tooltip.visible {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      .route-tooltip .tooltip-header {
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
        gap: 0.5rem;
        margin-bottom: 0.35rem;
        padding-right: calc(var(--tooltip-grade-size, 3.75rem) + 1.25rem);
      }

      .route-tooltip .tooltip-title {
        display: block;
        font-size: 0.95rem;
        font-weight: 600;
      }

      .route-tooltip .tooltip-lines {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        white-space: pre-line;
      }

      .route-tooltip .tooltip-betatips {
        margin-top: 1.25rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.25);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .route-tooltip .tooltip-betatips-heading {
        font-size: 1rem;
        font-weight: 600;
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-betatips-list {
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }

      .route-tooltip .betatip-entry {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        background: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.1);
        border-radius: 0.75rem;
        padding: 0.75rem 0.9rem;
        border: 1px solid rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.2);
      }

      .route-tooltip .betatip-entry.is-current-user {
        border-color: var(--tooltip-accent, #7ed957);
        background: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.18);
      }

      .route-tooltip .betatip-body {
        display: flex;
        align-items: flex-start;
        gap: 0.55rem;
      }

      .route-tooltip .betatip-upvote-count {
        font-weight: 600;
        font-variant-numeric: tabular-nums;
        min-width: 1.5rem;
        text-align: right;
        color: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.8);
        position: relative;
      }

      .route-tooltip .betatip-actions {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        align-items: center;
      }

      .route-tooltip .betatip-username {
        font-weight: 600;
        letter-spacing: 0.01em;
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .betatip-entry.is-current-user .betatip-username {
        color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .betatip-text {
        font-size: 0.95rem;
        line-height: 1.5;
        color: var(--tooltip-muted-foreground, #d1d5db);
        white-space: pre-line;
        flex: 1;
      }

      .route-tooltip .betatip-delete-button {
        border: none;
        background: none;
        color: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.75);
        font-size: 0.75rem;
        font-weight: 600;
        text-decoration: underline;
        cursor: pointer;
        padding: 0.1rem 0.25rem;
        transition: color 0.2s ease, opacity 0.2s ease;
      }

      .route-tooltip .betatip-delete-button:hover,
      .route-tooltip .betatip-delete-button:focus-visible {
        color: var(--tooltip-accent, #7ed957);
        outline: none;
      }

      .route-tooltip .betatip-delete-button:disabled {
        color: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
        cursor: not-allowed;
        text-decoration: none;
      }

      .route-tooltip .tooltip-betatips-empty {
        font-size: 0.95rem;
        color: var(--tooltip-muted-foreground, #d1d5db);
        font-style: italic;
      }

      .route-tooltip .tooltip-betatips-form {
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }

      .route-tooltip .tooltip-betatips-label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.95rem;
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-betatips-textarea {
        width: 100%;
        min-height: 4.5rem;
        resize: vertical;
        border-radius: 0.75rem;
        border: 1px solid rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
        background: rgba(14, 21, 15, 0.9);
        color: var(--tooltip-foreground, #fff);
        padding: 0.75rem 0.85rem;
        font-size: 0.95rem;
        line-height: 1.5;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .route-tooltip .tooltip-betatips-textarea:focus {
        outline: none;
        border-color: var(--tooltip-accent, #7ed957);
        box-shadow: 0 0 0 2px rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
      }

      .route-tooltip .tooltip-betatips-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .route-tooltip .tooltip-betatips-actions button {
        border-radius: 999px;
        border: 1px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        padding: 0.5rem 1.1rem;
        font-size: 0.9rem;
        font-weight: 600;
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }

      .route-tooltip .tooltip-betatips-actions button:hover,
      .route-tooltip .tooltip-betatips-actions button:focus-visible {
        transform: translateY(-1px);
        outline: none;
        box-shadow: 0 10px 24px rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
      }

      .route-tooltip .tooltip-betatips-actions button.is-quiet {
        background: transparent;
        color: var(--tooltip-muted-foreground, #d1d5db);
        border-color: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
      }

      .route-tooltip .tooltip-betatips-actions button.is-quiet:hover,
      .route-tooltip .tooltip-betatips-actions button.is-quiet:focus-visible {
        border-color: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-betatips-status {
        font-size: 0.85rem;
        min-height: 1rem;
        color: #fca5a5;
      }

      .route-tooltip .tooltip-line {
        display: block;
      }

      .route-tooltip .tooltip-grade-cluster {
        position: absolute;
        top: 1rem;
        right: 1rem;
        transform: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        min-width: var(--tooltip-grade-size, 3.75rem);
        z-index: 1;
        pointer-events: none;
      }

      .route-tooltip .tooltip-grade-badge {
        width: var(--tooltip-grade-size, 3.75rem);
        height: var(--tooltip-grade-size, 3.75rem);
        border-radius: 50%;
        border: var(--tooltip-grade-stroke-width, 2px) solid var(--tooltip-accent, #7ed957);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: var(--tooltip-grade-font-size, 2.4rem);
        line-height: 1;
        color: var(--tooltip-on-accent, #000);
        background: rgb(var(--tooltip-accent-rgb, 126, 217, 87));
        pointer-events: none;
        overflow: hidden;
      }

      .route-tooltip .tooltip-actions {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        margin-top: 0.5rem;
        width: 100%;
        pointer-events: auto;
      }

      .route-tooltip .tooltip-action-button {
        width: 100%;
        border-radius: 999px;
        padding: 0.6rem 0.9rem;
        font-size: 0.82rem;
        font-weight: 600;
        border: 2px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
        text-align: center;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease,
          color 0.15s ease, border-color 0.15s ease;
      }

      .route-tooltip .tooltip-action-button:hover,
      .route-tooltip .tooltip-action-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        outline: none;
      }

      .route-tooltip .tooltip-action-button.is-quiet {
        background: var(--tooltip-surface, #0e150f);
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-action-button.is-quiet:hover,
      .route-tooltip .tooltip-action-button.is-quiet:focus-visible {
        border-color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .tooltip-action-button[aria-pressed='true'] {
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      }

      .route-tooltip .ascend-toggle[aria-pressed='true'] {
        background: var(--tooltip-on-accent, #000);
        color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .focus-toggle {
        text-align: center;
      }

      .route-tooltip .focus-toggle[aria-pressed='true'] {
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
      }

      .route-tooltip .tooltip-grade-value {
        position: relative;
        z-index: 1;
      }

      .route-tooltip .tooltip-grade-badge.ascended {
        box-shadow: 0 0 0 0.35rem rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
      }

      .grade-section {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        margin-top: 0.75rem;
      }

      .grade-form {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .grade-form label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.8rem;
        font-weight: 600;
      }

      .grade-input-row {
        display: flex;
        gap: 0.5rem;
        align-items: stretch;
      }

      .grade-input-row label {
        flex: 1;
      }

      .grade-input-row input[type='number'] {
        flex: 1;
      }

      .grade-form input[type='number'] {
        border-radius: 0.65rem;
        border: 1px solid #fff;
        background: #fff;
        color: #111;
        padding: 0.45rem 0.6rem;
        font-size: 0.85rem;
      }

      .grade-form input[type='number']:disabled {
        cursor: not-allowed;
      }

      .grade-note {
        font-size: 0.75rem;
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-close-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.2rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: rgba(0, 0, 0, 0.25);
        color: var(--tooltip-foreground, #fff);
        font-size: 1rem;
        line-height: 1;
        min-width: 0;
        transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease,
          box-shadow 0.2s ease;
      }

      .route-tooltip .tooltip-close-button:hover,
      .route-tooltip .tooltip-close-button:focus-visible {
        border-color: rgba(255, 255, 255, 0.6);
        background: rgba(255, 255, 255, 0.2);
        color: #0b0f03;
        box-shadow: 0 0 0 0.15rem rgba(255, 255, 255, 0.2);
      }

      .route-tooltip .tooltip-close-button svg {
        width: 1.1em;
        height: 1.1em;
        display: block;
      }

      @media (max-width: 768px) {
        .route-tooltip {
          width: 90vw;
          max-height: calc(90vh - 1.5rem);
        }
      }

    </style>
  </head>
  <body>
    <div
      id="authOverlay"
      class="auth-overlay hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="authTitle"
    >
      <form id="authForm" class="auth-card">
        <h1 id="authTitle">Sign in to continue</h1>
        <label class="auth-field">
          <span>Username</span>
          <input id="authUsername" type="text" name="username" autocomplete="username" required />
        </label>
        <label class="auth-field">
          <span>Password</span>
          <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="6" required />
        </label>
        <p id="authError" class="auth-error" role="alert" aria-live="assertive"></p>
        <button type="submit" class="auth-submit">Sign In</button>
        <p class="auth-switch">
          <span id="authSwitchLabel">Don't have an account?</span>
          <button type="button" id="toggleAuthMode">Create one</button>
        </p>
      </form>
    </div>
    <div id="appContent" class="app" aria-live="polite">
      <div class="info-wrapper">
        <button
          id="infoButton"
          class="header-icon-button info-button"
          type="button"
          aria-label="Learn about Ascend"
          aria-haspopup="dialog"
          aria-pressed="false"
          aria-expanded="false"
          aria-controls="infoPopover"
          title="Learn about Ascend"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2" />
            <rect x="11" y="10" width="2" height="7" rx="1" />
            <circle cx="12" cy="7" r="1.5" />
          </svg>
        </button>
        <div
          id="infoPopover"
          class="info-popover hidden"
          role="dialog"
          aria-modal="false"
          aria-hidden="true"
          aria-label="About Ascend"
          tabindex="-1"
        >
          <p>Tap a header button to learn what it does.</p>
          <p>The next button you press will open its tooltip and close this message.</p>
        </div>
      </div>
      <header class="app-header">
        <div
          id="viewToggleGroup"
          class="view-mode-toggle-group"
          role="group"
          aria-label="Route coloring mode"
        >
          <button
            type="button"
            id="viewModeCycleButton"
            class="header-icon-button view-toggle-option"
            data-view-mode="hold-colors"
            data-view-mode-cycle="grade-colors hold-colors"
            data-tooltip="Showing by Color of Holds"
            aria-pressed="true"
            aria-label="Showing by Color of Holds"
            title="Showing by Color of Holds"
          >
            <span class="sr-only" data-view-toggle-label>Showing by Color of Holds</span>
            <span class="view-toggle-icon view-toggle-icon--grades" aria-hidden="true">
              <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
                <rect x="5" y="13.5" width="3.5" height="6" rx="1.75" fill="#2f9e44" />
                <rect x="10.25" y="9.5" width="3.5" height="10" rx="1.75" fill="#facc15" />
                <rect x="15.5" y="5" width="3.5" height="14.5" rx="1.75" fill="#ef4444" />
                <rect x="4" y="20" width="16" height="1.5" rx="0.75" fill="#ffffff" fill-opacity="0.55" />
              </svg>
            </span>
            <span class="view-toggle-icon view-toggle-icon--holds" aria-hidden="true">
              <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
                <path
                  d="M6 19a3 3 0 0 1 0-6h12a2 2 0 0 0 0-4H8a4 4 0 0 1 0-8h10v2H8a2 2 0 0 0 0 4h10a4 4 0 0 1 0 8H6a1 1 0 0 0 0 2h12v2H6a3 3 0 0 1-3-3Z"
                  fill="currentColor"
                />
              </svg>
            </span>
          </button>
        </div>
        <button
          id="locationButton"
          class="header-icon-button walls-button"
          type="button"
          aria-haspopup="dialog"
          aria-label="Select wall"
          title="Select wall"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M12 2a7 7 0 0 1 7 7c0 4.42-4.56 9.52-6.38 11.34a0.88 0.88 0 0 1-1.24 0C9.56 18.52 5 13.42 5 9a7 7 0 0 1 7-7Zm0 4a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <a
          id="loginButton"
          class="header-icon-button login-link"
          href="personal.html"
          aria-label="Log in"
          title="Log in"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M11 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-3h2v2h5V5h-5v2h-2V4Z"
              fill="currentColor"
            />
            <path
              d="m5.7 11.3 2.3-2.3 1.4 1.4L8.83 11H14v2H8.83l0.57 0.59-1.4 1.41-2.3-2.3a1 1 0 0 1 0-1.4Z"
              fill="currentColor"
            />
          </svg>
        </a>
      </header>
      <div class="canvas-container">
        <canvas id="previewCanvas" aria-hidden="true"></canvas>
        <div class="focus-footer">
          <button
            id="clearFocusButton"
            class="clear-focus-button hidden"
            type="button"
            data-info-target="route-focus"
            aria-hidden="true"
          >
            Clear Focus
          </button>
        </div>
      </div>
    </div>
    <div
      id="tutorialOverlay"
      class="tutorial-overlay hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="tutorialTitle"
      aria-describedby="tutorialDescription"
    >
      <div id="tutorialDialogCard" class="tutorial-card" role="document" tabindex="-1">
        <div id="tutorialProgress" class="tutorial-progress hidden" aria-live="polite"></div>
        <h2 id="tutorialTitle" class="tutorial-title"></h2>
        <div id="tutorialDescription" class="tutorial-description"></div>
        <div class="tutorial-actions">
          <button
            id="tutorialSecondaryAction"
            class="tutorial-button tutorial-secondary hidden"
            type="button"
            data-tutorial-exempt="true"
          ></button>
          <button
            id="tutorialPrimaryAction"
            class="tutorial-button tutorial-primary"
            type="button"
            data-tutorial-exempt="true"
          ></button>
        </div>
      </div>
    </div>
    <div
      id="routeTooltip"
      class="route-tooltip"
      role="status"
      aria-live="polite"
      aria-hidden="true"
    ></div>
    <div
      id="locationModal"
      class="location-modal hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="locationModalTitle"
    >
      <div class="location-modal-content">
        <div class="location-modal-header">
          <h2 id="locationModalTitle" class="location-modal-title">Select a wall</h2>
          <button id="locationModalClose" class="location-modal-close" type="button" aria-label="Close wall selector">
            ×
          </button>
        </div>
        <div id="locationOptions" class="location-options" role="listbox"></div>
      </div>
    </div>
    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
        updateProfile,
        deleteUser,
        getIdTokenResult,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        addDoc,
        deleteDoc,
        serverTimestamp,
        collection,
        getDocs,
        query,
        limit,
        where,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
      import { firebaseConfig } from './config.js';

      const firebaseApp = initializeApp(firebaseConfig);
      const auth = getAuth(firebaseApp);

      const db = getFirestore(firebaseApp);

      const authOverlay = document.getElementById('authOverlay');
      const appContent = document.getElementById('appContent');
      const authForm = document.getElementById('authForm');
      const authUsername = document.getElementById('authUsername');
      const authPassword = document.getElementById('authPassword');
      const authError = document.getElementById('authError');
      const authTitle = document.getElementById('authTitle');
      const authSwitchLabel = document.getElementById('authSwitchLabel');
      const toggleAuthModeButton = document.getElementById('toggleAuthMode');
      const loginButton = document.getElementById('loginButton');
      const setterLink = document.getElementById('setterLink');
      const setterLinkBaseHref = setterLink?.getAttribute('href') || 'setter.html';
      const tooltip = document.getElementById('routeTooltip');
      const infoButton = document.getElementById('infoButton');
      const infoPopover = document.getElementById('infoPopover');
      const locationButton = document.getElementById('locationButton');
      const viewToggleGroup = document.getElementById('viewToggleGroup');
      const viewToggleButtons = Array.from(
        viewToggleGroup?.querySelectorAll('[data-view-mode]') ?? [],
      );
      const viewToggleButtonMap = new Map();
      viewToggleButtons.forEach((button) => {
        const mode = button?.dataset?.viewMode;
        if (mode) {
          viewToggleButtonMap.set(mode, button);
        }

        const cycle = button?.dataset?.viewModeCycle;
        if (cycle) {
          cycle
            .split(/\s+/)
            .map((value) => value.trim())
            .filter(Boolean)
            .forEach((cycleMode) => {
              viewToggleButtonMap.set(cycleMode, button);
            });
        }
      });

      function getViewToggleButtonForMode(mode) {
        if (!mode) {
          return null;
        }
        return viewToggleButtonMap.get(mode) ?? null;
      }

      function isViewToggleElement(element) {
        if (!element) {
          return false;
        }
        return viewToggleButtons.includes(element);
      }
      const progressionButton = document.getElementById('progressionButton');
      const locationModal = document.getElementById('locationModal');
      const locationOptions = document.getElementById('locationOptions');
      const locationModalClose = document.getElementById('locationModalClose');
      const progressionModal = document.getElementById('progressionModal');
      const progressionModalClose = document.getElementById('progressionModalClose');
      const progressionList = document.getElementById('progressionList');
      const tutorialOverlay = document.getElementById('tutorialOverlay');
      const tutorialDialogCard = document.getElementById('tutorialDialogCard');
      const tutorialTitle = document.getElementById('tutorialTitle');
      const tutorialDescription = document.getElementById('tutorialDescription');
      const tutorialPrimaryAction = document.getElementById('tutorialPrimaryAction');
      const tutorialSecondaryAction = document.getElementById('tutorialSecondaryAction');
      const tutorialProgress = document.getElementById('tutorialProgress');

      let infoHighlightsContainer = null;
      let infoModeActive = false;
      let awaitingInfoTargetSelection = false;
      let activeInfoCallout = null;
      let pendingInfoRepositionFrame = null;
      let ephemeralCalloutDismissTimer = null;
      let tutorialInviteOpen = false;
      let tutorialActive = false;
      let tutorialStepIndex = -1;
      let tutorialTransitionInProgress = false;
      let tutorialHighlightedRouteId = null;
      let tutorialHighlightedElement = null;
      let tutorialHighlightedElementOptions = { illuminate: false };
      let tutorialPreviousFocus = null;
      let tutorialOverlayMode = 'hidden';
      let tutorialPreviousViewMode = null;

      const LOCATIONS = [
        { key: 'new-wall', name: 'New Wall', image: './location/New Wall.jpg', hidden: false },
        { key: 'old-wall', name: 'Old Wall', image: './location/Old Wall.jpg', hidden: false },
      ];

      const isLocationVisible = (location) => !!location && location.hidden !== true;

      const getDefaultLocation = () => LOCATIONS.find(isLocationVisible) || null;

      const LOCATION_STORAGE_KEY = 'ascend.selectedWall';
      const WALL_QUERY_PARAM = 'wall';

      function ensureInfoHighlightsContainer() {
        if (infoHighlightsContainer && document.body?.contains(infoHighlightsContainer)) {
          return infoHighlightsContainer;
        }

        if (!document.body) {
          return null;
        }

        const container = document.createElement('div');
        container.id = 'infoHighlights';
        container.className = 'info-highlights hidden';
        document.body.appendChild(container);
        infoHighlightsContainer = container;
        return container;
      }

      function clearInfoHighlights() {
        const container = ensureInfoHighlightsContainer();
        if (!container) {
          return;
        }

        if (pendingInfoRepositionFrame) {
          cancelAnimationFrame(pendingInfoRepositionFrame);
          pendingInfoRepositionFrame = null;
        }

        if (ephemeralCalloutDismissTimer) {
          clearTimeout(ephemeralCalloutDismissTimer);
          ephemeralCalloutDismissTimer = null;
        }

        container.innerHTML = '';
        container.classList.add('hidden');
        activeInfoCallout = null;
      }

      function createBasicCallout(title, lines = []) {
        const callout = document.createElement('div');
        callout.className = 'info-callout';

        if (title) {
          const heading = document.createElement('strong');
          heading.textContent = title;
          callout.appendChild(heading);
        }

        lines
          .filter((line) => typeof line === 'string' && line.trim().length)
          .forEach((line) => {
            const paragraph = document.createElement('p');
            paragraph.textContent = line;
            callout.appendChild(paragraph);
          });

        return callout;
      }

      function createGradeChartElement() {
        const wrapper = document.createElement('div');
        wrapper.className = 'info-callout-chart-wrapper';
        wrapper.setAttribute('aria-hidden', 'true');

        const chart = document.createElement('div');
        chart.className = 'info-callout-chart';
        wrapper.appendChild(chart);

        const gradeEntries = Array.from(GRADE_COLOR_MAP.entries());
        const totalGrades = gradeEntries.length;
        const minimumHeight = 22;
        const maximumHeight = 100;
        const heightRange = maximumHeight - minimumHeight;

        gradeEntries.forEach(([grade, color], index) => {
          const bar = document.createElement('span');
          bar.className = 'info-callout-chart-bar';
          const relative = totalGrades > 1 ? index / (totalGrades - 1) : 0;
          const heightPercent = minimumHeight + relative * heightRange;
          bar.style.height = `${heightPercent}%`;
          bar.style.backgroundColor = color;
          bar.dataset.grade = String(grade);
          chart.appendChild(bar);
        });

        if (gradeEntries.length) {
          const labels = document.createElement('div');
          labels.className = 'info-callout-chart-labels';

          const middleIndex = Math.round((gradeEntries.length - 1) / 2);

          const startLabel = document.createElement('span');
          startLabel.textContent = formatGradeDisplay(Number(gradeEntries[0]?.[0] ?? NaN));

          const middleLabel = document.createElement('span');
          middleLabel.textContent = formatGradeDisplay(Number(gradeEntries[middleIndex]?.[0] ?? NaN));

          const endLabel = document.createElement('span');
          endLabel.textContent = formatGradeDisplay(Number(gradeEntries[gradeEntries.length - 1]?.[0] ?? NaN));

          labels.appendChild(startLabel);
          labels.appendChild(middleLabel);
          labels.appendChild(endLabel);

          wrapper.appendChild(labels);
        }

        return wrapper;
      }

      function isMobileDevice() {
        if (typeof window === 'undefined') {
          return false;
        }

        const coarsePointer =
          typeof window.matchMedia === 'function' && window.matchMedia('(pointer: coarse)').matches;
        const narrowViewport =
          typeof window.matchMedia === 'function'
            ? window.matchMedia('(max-width: 820px)').matches
            : window.innerWidth <= 820;
        const touchPoints =
          typeof navigator !== 'undefined' && typeof navigator.maxTouchPoints === 'number'
            ? navigator.maxTouchPoints > 1
            : false;
        const userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';
        const mobileAgentPattern = /(Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Windows Phone)/i;

        return Boolean(coarsePointer || narrowViewport || touchPoints || mobileAgentPattern.test(userAgent));
      }

      function createTutorialPhoneElement(orientation) {
        const phone = document.createElement('div');
        phone.className = `tutorial-phone tutorial-phone--${orientation}`;
        phone.setAttribute('role', 'presentation');
        phone.setAttribute('aria-hidden', 'true');

        const screen = document.createElement('div');
        screen.className = 'tutorial-phone-screen';
        phone.appendChild(screen);

        return phone;
      }

      function createPortraitSwipeIllustration() {
        const container = document.createElement('div');
        container.className = 'tutorial-portrait-graphic';
        container.setAttribute('role', 'presentation');
        container.setAttribute('aria-hidden', 'true');

        container.innerHTML = `
          <svg viewBox="0 0 160 220" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="tutorialPortraitScreenGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#60a5fa" stop-opacity="0.55" />
                <stop offset="50%" stop-color="#1e293b" stop-opacity="0.95" />
                <stop offset="100%" stop-color="#0f172a" stop-opacity="0.8" />
              </linearGradient>
            </defs>
            <g class="tutorial-portrait-phone">
              <rect x="30" y="8" width="100" height="204" rx="20" fill="#0f172a" stroke="#94a3b8" stroke-opacity="0.4" stroke-width="3" />
              <rect x="44" y="30" width="72" height="152" rx="14" fill="url(#tutorialPortraitScreenGradient)" stroke="#94a3b8" stroke-opacity="0.45" stroke-width="2" />
              <circle cx="80" cy="20" r="4" fill="#94a3b8" fill-opacity="0.6" />
            </g>
            <g class="tutorial-portrait-arrows">
              <path class="tutorial-portrait-arrow tutorial-portrait-arrow--left" d="M60 112 L48 124 L60 136" />
              <path class="tutorial-portrait-arrow tutorial-portrait-arrow--right" d="M100 112 L112 124 L100 136" />
              <line x1="60" y1="124" x2="100" y2="124" stroke="#7ed957" stroke-opacity="0.6" stroke-width="3" stroke-linecap="round" stroke-dasharray="6 10" />
            </g>
            <g class="tutorial-portrait-finger">
              <circle cx="82" cy="140" r="13" fill="#fde68a" stroke="#b45309" stroke-width="2" />
              <rect x="75" y="140" width="14" height="60" rx="7" fill="#fbbf24" stroke="#b45309" stroke-width="2" />
              <path d="M72 192v-12c0-4.97 4.03-9 9-9s9 4.03 9 9v12" fill="#f97316" stroke="#b45309" stroke-width="2" stroke-linejoin="round" />
              <path d="M70 192h22c10.5 0 19 8.5 19 19s-8.5 19-19 19H70c-10.5 0-19-8.5-19-19s8.5-19 19-19z" fill="#f59e0b" stroke="#b45309" stroke-width="2" stroke-linejoin="round" />
              <circle cx="86" cy="134" r="5" fill="#fff" fill-opacity="0.35" />
            </g>
          </svg>
        `;

        return container;
      }

      function createMobileOrientationIllustration(orientation) {
        const wrapper = document.createElement('div');
        wrapper.className = `tutorial-illustration tutorial-illustration--${orientation}`;

        if (orientation === 'portrait') {
          wrapper.appendChild(createPortraitSwipeIllustration());
        } else {
          wrapper.appendChild(createTutorialPhoneElement('landscape'));
        }

        const caption = document.createElement('span');
        caption.className = 'tutorial-illustration-caption';
        caption.textContent = orientation === 'portrait' ? 'Portrait view' : 'Landscape view';
        wrapper.appendChild(caption);

        return wrapper;
      }

      function isElementVisible(element) {
        if (!element) {
          return false;
        }

        if (element.classList?.contains('hidden')) {
          return false;
        }

        const rect = element.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0;
      }

      function buildViewModeCallout(context = {}) {
        let target = null;
        if (context?.button instanceof Element && isElementVisible(context.button)) {
          target = context.button;
        } else {
          target =
            getViewToggleButtonForMode(viewMode) ||
            getViewToggleButtonForMode(VIEW_MODE_HOLD_COLORS) ||
            viewToggleButtons[0] ||
            null;
          if (!isElementVisible(target)) {
            target = null;
          }
        }

        if (!target) {
          return null;
        }

        const mode = target.dataset?.viewMode || viewMode;
        let title = 'Route colors';
        let lines = [];

        if (mode === VIEW_MODE_GRADE_COLORS) {
          title = 'Show by Grade';
          lines = [
            'Routes are tinted by consensus difficulty right now.',
            'Problems without a community grade stay bright white until someone logs one.',
            'Swap back to hold colours any time if you want to match the actual tape.',
          ];
        } else {
          title = 'Show by Color of Holds';
          lines = [
            'Routes are showing the colour of each hold set.',
            'Switch to Show by Grade when you want quick difficulty cues.',
          ];
        }

        const callout = createBasicCallout(title, lines);
        if (mode === VIEW_MODE_GRADE_COLORS) {
          callout.appendChild(createGradeChartElement());
        }

        return {
          target,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildSetterCallout() {
        if (!setterLink || !isElementVisible(setterLink)) {
          return null;
        }

        const callout = createBasicCallout('Setter tools', [
          'Open the route-setting workspace to draw climbs for this wall.',
        ]);

        return {
          target: setterLink,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildLocationCallout() {
        if (!locationButton) {
          return null;
        }

        const callout = createBasicCallout('Wall selector', [
          'Choose a different wall or angle to load its background and routes.',
        ]);

        return {
          target: locationButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildProgressionCallout() {
        if (!progressionButton) {
          return null;
        }

        const callout = createBasicCallout('Progression tracker', [
          'Open a sortable list of every visible climb.',
          'Completed routes show a green tick beside their grade.',
        ]);

        return {
          target: progressionButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildLoginCallout() {
        if (!loginButton || !isElementVisible(loginButton)) {
          return null;
        }

        const callout = createBasicCallout('Log in', [
          'Visit your personal dashboard to sign in or manage ascents.',
        ]);

        return {
          target: loginButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildRouteAscentCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const isMarkedAscended = target.getAttribute('aria-pressed') === 'true';
        const title = isMarkedAscended ? 'Marked ascended' : 'Not ascended';
        const callout = createBasicCallout(title, [
          'Toggle this when you send the climb to track your personal ascents.',
          'Turn it off again to keep projects on your list.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function buildRouteFocusCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const hasFocusedRoute = Boolean(focusedRouteId);
        const callout = createBasicCallout('Focus view', [
          'Double-click any route to isolate it and study its holds without distractions.',
          hasFocusedRoute
            ? 'Select Clear Focus to bring the rest of the wall back into view.'
            : 'When a route is focused, a Clear Focus button appears here to restore the full wall.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function buildRouteGradeCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const callout = createBasicCallout('Your grade', [
          'This is your personal grade — how you think the climb feels.',
          'Your grade helps shape the community average shown in the top right.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function positionCallout(entry) {
        if (!entry?.target || !entry?.element) {
          return;
        }

        const targetRect = entry.target.getBoundingClientRect();
        if (targetRect.width === 0 && targetRect.height === 0) {
          entry.element.style.opacity = '0';
          return;
        }

        entry.element.style.opacity = '1';

        const placement = entry.options?.placement === 'top' ? 'top' : 'bottom';
        const offset = Number.isFinite(entry.options?.offset) ? entry.options.offset : 14;
        const margin = Number.isFinite(entry.options?.margin) ? entry.options.margin : 16;
        const targetCenterX = targetRect.left + targetRect.width / 2;

        if (placement === 'top') {
          entry.element.dataset.arrow = 'bottom';
          entry.element.style.top = `${targetRect.top - offset}px`;
          entry.element.style.transform = 'translate(-50%, -100%)';
        } else {
          entry.element.dataset.arrow = 'top';
          entry.element.style.top = `${targetRect.bottom + offset}px`;
          entry.element.style.transform = 'translate(-50%, 0)';
        }

        const calloutRect = entry.element.getBoundingClientRect();
        const calloutWidth = calloutRect.width;
        const minCenter = margin + calloutWidth / 2;
        const maxCenter = window.innerWidth - margin - calloutWidth / 2;
        const clampedCenter = clamp(targetCenterX, minCenter, maxCenter);
        entry.element.style.left = `${clampedCenter}px`;

        const updatedRect = entry.element.getBoundingClientRect();
        const arrowOffset = clamp(targetCenterX - updatedRect.left, 12, updatedRect.width - 12);
        entry.element.style.setProperty('--callout-arrow-offset', `${arrowOffset}px`);
      }

      function scheduleInfoHighlightsReposition() {
        if (!activeInfoCallout) {
          return;
        }

        if (pendingInfoRepositionFrame) {
          cancelAnimationFrame(pendingInfoRepositionFrame);
        }

        pendingInfoRepositionFrame = requestAnimationFrame(() => {
          pendingInfoRepositionFrame = null;
          if (activeInfoCallout) {
            positionCallout(activeInfoCallout);
          }
        });
      }

      function showInfoCallout(entry) {
        if (!entry?.element) {
          return;
        }

        const container = ensureInfoHighlightsContainer();
        if (!container) {
          return;
        }

        container.innerHTML = '';
        container.classList.remove('hidden');
        container.appendChild(entry.element);
        activeInfoCallout = entry;

        requestAnimationFrame(() => {
          if (activeInfoCallout === entry) {
            positionCallout(entry);
          }
        });
      }

      function showTemporaryInfoCallout(entry, duration = 8000) {
        if (!entry) {
          return;
        }

        showInfoCallout(entry);

        if (ephemeralCalloutDismissTimer) {
          clearTimeout(ephemeralCalloutDismissTimer);
        }

        const timeout = Number.isFinite(duration) && duration > 0 ? duration : 8000;
        ephemeralCalloutDismissTimer = window.setTimeout(() => {
          ephemeralCalloutDismissTimer = null;
          if (activeInfoCallout === entry) {
            clearInfoHighlights();
          }
        }, timeout);
      }

      function setInfoButtonActiveState(active) {
        if (!infoButton) {
          return;
        }

        infoButton.setAttribute('aria-pressed', active ? 'true' : 'false');
        infoButton.setAttribute('aria-expanded', active ? 'true' : 'false');
        infoButton.classList.toggle('is-active', active);
      }

      function hideInfoPopover() {
        if (!infoPopover) {
          return;
        }

        infoPopover.classList.add('hidden');
        infoPopover.setAttribute('aria-hidden', 'true');
      }

      function activateInfoMode() {
        infoModeActive = true;
        awaitingInfoTargetSelection = true;
        setInfoButtonActiveState(true);
        clearInfoHighlights();

        if (infoPopover) {
          infoPopover.classList.remove('hidden');
          infoPopover.setAttribute('aria-hidden', 'false');
          if (typeof infoPopover.focus === 'function') {
            infoPopover.focus({ preventScroll: true });
          }
        }
      }

      function deactivateInfoMode({ clearCallout = false } = {}) {
        awaitingInfoTargetSelection = false;

        if (infoModeActive) {
          infoModeActive = false;
        }

        setInfoButtonActiveState(false);
        hideInfoPopover();

        if (clearCallout) {
          clearInfoHighlights();
        }

      }

      function toggleInfoMode() {
        if (infoModeActive) {
          deactivateInfoMode({ clearCallout: true });
        } else {
          activateInfoMode();
        }
      }

      function handleInfoRequestFor(targetKey, event, context = {}) {
        if (!infoModeActive || !awaitingInfoTargetSelection) {
          return false;
        }

        awaitingInfoTargetSelection = false;

        if (event) {
          if (typeof event.preventDefault === 'function') {
            event.preventDefault();
          }
          if (typeof event.stopPropagation === 'function') {
            event.stopPropagation();
          }
        }

        let entry = null;
        switch (targetKey) {
          case 'view-toggle':
            entry = buildViewModeCallout(context);
            break;
          case 'setter-link':
            entry = buildSetterCallout();
            break;
          case 'location':
            entry = buildLocationCallout();
            break;
          case 'progression':
            entry = buildProgressionCallout();
            break;
          case 'log-in':
            entry = buildLoginCallout();
            break;
          case 'route-ascent':
            entry = buildRouteAscentCallout(context);
            break;
          case 'route-focus':
            entry = buildRouteFocusCallout(context);
            break;
          case 'route-grade':
            entry = buildRouteGradeCallout(context);
            break;
          default:
            break;
        }

        if (entry) {
          showInfoCallout(entry);
          deactivateInfoMode({ clearCallout: false });
        } else {
          deactivateInfoMode({ clearCallout: true });
        }

        return true;
      }

      const PATH_TYPE_BREZER = 'brezer';
      const PATH_TYPE_HOLLOW_POINT = 'hollow-point';
      const PATH_TYPE_FILLED_POINT = 'filled-point';
      const PATH_TYPE_RECTANGLE = 'rectangle';
      const DEFAULT_PATH_TYPE = PATH_TYPE_BREZER;
      const MIN_POINT_DIAMETER = 12;
      const MAX_POINT_DIAMETER = 160;
      const DEFAULT_HOLLOW_POINT_DIAMETER = 48;
      const DEFAULT_FILLED_POINT_DIAMETER = 48;
      const DEFAULT_POINT_DIAMETER = DEFAULT_HOLLOW_POINT_DIAMETER;
      const MIN_RECTANGLE_SIZE = 12;
      const MAX_RECTANGLE_SIZE = 200;
      const DEFAULT_RECTANGLE_WIDTH = 80;
      const DEFAULT_RECTANGLE_HEIGHT = 60;
      const MIN_GRADE_VALUE = 1;
      const MAX_GRADE_VALUE = 31;
      const MAX_BETATIP_LENGTH = 600;
      const MIN_GRADE_BAR_BASE_HEIGHT = 0;
      const MAX_GRADE_BAR_HEIGHT = 1000;
      const DEFAULT_GRADE_BAR_BASE_HEIGHT = 40;
      const DEFAULT_GRADE_BAR_MAX_HEIGHT = 220;
      const MIN_GRADE_BAR_WIDTH = 4;
      const MAX_GRADE_BAR_WIDTH = 160;
      const DEFAULT_GRADE_BAR_WIDTH = 24;
      const DEFAULT_GRADE_BAR_TRANSPARENCY = 0.85;
      const MIN_UNFOCUSED_TRANSPARENCY = 0;
      const MAX_UNFOCUSED_TRANSPARENCY = 1;
      const DEFAULT_UNFOCUSED_TRANSPARENCY = 0.25;
      const WALL_COLLECTION = 'walls';
      const GRADE_COLOR_MAP = new Map([
        [1, '#2F7E13'],
        [2, '#378B14'],
        [3, '#3E9015'],
        [4, '#459616'],
        [5, '#4BA218'],
        [6, '#50AE1A'],
        [7, '#59B51A'],
        [8, '#60BA19'],
        [9, '#68BF16'],
        [10, '#71C314'],
        [11, '#87C112'],
        [12, '#92C510'],
        [13, '#C6D208'],
        [14, '#DDD805'],
        [15, '#F3DF01'],
        [16, '#F6C20E'],
        [17, '#EEA21C'],
        [18, '#EA9621'],
        [19, '#E78A27'],
        [20, '#E37B27'],
        [21, '#E06A23'],
        [22, '#DC5A1E'],
        [23, '#D94A1B'],
        [24, '#D63F18'],
        [25, '#D33314'],
        [26, '#D02711'],
        [27, '#CE1A0D'],
        [28, '#C90E0B'],
        [29, '#C50809'],
        [30, '#C10407'],
        [31, '#BD0306'],
      ]);
      const DEFAULT_GRADELESS_COLOR = '#ffffff';
      const MIN_BREZER_STROKE_WIDTH = 2;
      const MAX_BREZER_STROKE_WIDTH = 40;
      const DEFAULT_BREZER_STROKE_WIDTH = 10;
      const VIEW_MODE_HOLD_COLORS = 'hold-colors';
      const VIEW_MODE_GRADE_COLORS = 'grade-colors';
      const VIEW_MODE_SEQUENCE = [VIEW_MODE_HOLD_COLORS, VIEW_MODE_GRADE_COLORS];
      const VIEW_MODE_META = {
        [VIEW_MODE_GRADE_COLORS]: {
          label: 'Showing by Grade',
          next: VIEW_MODE_HOLD_COLORS,
        },
        [VIEW_MODE_HOLD_COLORS]: {
          label: 'Showing by Color of Holds',
          next: VIEW_MODE_GRADE_COLORS,
        },
      };

      function normalizePathType(value) {
        if (typeof value === 'string') {
          const normalized = value.trim().toLowerCase().replace(/\s+/g, '-');
          if (normalized === PATH_TYPE_BREZER) {
            return PATH_TYPE_BREZER;
          }
          if (normalized === PATH_TYPE_RECTANGLE) {
            return PATH_TYPE_RECTANGLE;
          }
          if (normalized === PATH_TYPE_FILLED_POINT) {
            return PATH_TYPE_FILLED_POINT;
          }
          if (normalized === PATH_TYPE_HOLLOW_POINT || normalized === 'point') {
            return PATH_TYPE_HOLLOW_POINT;
          }
        }
        return DEFAULT_PATH_TYPE;
      }

      function isNormalizedPointPathType(value) {
        return value === PATH_TYPE_HOLLOW_POINT || value === PATH_TYPE_FILLED_POINT;
      }

      function getDefaultPointDiameterForPathType(pathTypeValue) {
        const normalized = normalizePathType(pathTypeValue);
        if (normalized === PATH_TYPE_FILLED_POINT) {
          return DEFAULT_FILLED_POINT_DIAMETER;
        }
        if (normalized === PATH_TYPE_HOLLOW_POINT) {
          return DEFAULT_HOLLOW_POINT_DIAMETER;
        }
        return DEFAULT_POINT_DIAMETER;
      }

      function normalizePointDiameter(value, fallback = DEFAULT_POINT_DIAMETER) {
        const numeric = Number(value);
        let candidate = numeric;
        if (!Number.isFinite(candidate)) {
          const fallbackNumeric = Number(fallback);
          candidate = Number.isFinite(fallbackNumeric) ? fallbackNumeric : DEFAULT_POINT_DIAMETER;
        }
        const clamped = Math.min(
          Math.max(Math.round(candidate), MIN_POINT_DIAMETER),
          MAX_POINT_DIAMETER,
        );
        return clamped;
      }

      function normalizeRectangleSize(value, fallback = DEFAULT_RECTANGLE_WIDTH) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallback;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_RECTANGLE_SIZE),
          MAX_RECTANGLE_SIZE,
        );
        return clamped;
      }

      function normalizeBrezerStrokeWidth(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_BREZER_STROKE_WIDTH;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_BREZER_STROKE_WIDTH),
          MAX_BREZER_STROKE_WIDTH,
        );
        return clamped;
      }

      function normalizeGradeBarHeight(value, fallback) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallback;
        }
        const clamped = Math.min(
          Math.max(numeric, MIN_GRADE_BAR_BASE_HEIGHT),
          MAX_GRADE_BAR_HEIGHT,
        );
        return Math.round(clamped);
      }

      function normalizeGradeBarWidth(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_WIDTH;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_GRADE_BAR_WIDTH),
          MAX_GRADE_BAR_WIDTH,
        );
        return clamped;
      }

      function normalizeGradeBarTransparency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_TRANSPARENCY;
        }
        const clamped = Math.min(Math.max(numeric, 0), 1);
        return Math.round(clamped * 1000) / 1000;
      }

      function normalizeUnfocusedTransparency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_UNFOCUSED_TRANSPARENCY;
        }
        const clamped = Math.min(
          Math.max(numeric, MIN_UNFOCUSED_TRANSPARENCY),
          MAX_UNFOCUSED_TRANSPARENCY,
        );
        return Math.round(clamped * 1000) / 1000;
      }

      function normalizeWallSettings(raw = {}) {
        if (!raw || typeof raw !== 'object') {
          return {
            pointDiameter: DEFAULT_HOLLOW_POINT_DIAMETER,
            hollowPointDiameter: DEFAULT_HOLLOW_POINT_DIAMETER,
            filledPointDiameter: DEFAULT_FILLED_POINT_DIAMETER,
            rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
            rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
            gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
            gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
            gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
            gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
            unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
          };
        }

        const hollowPointDiameter = normalizePointDiameter(
          raw.hollowPointDiameter ?? raw.pointDiameter,
          DEFAULT_HOLLOW_POINT_DIAMETER,
        );
        const filledPointDiameter = normalizePointDiameter(
          raw.filledPointDiameter ?? raw.pointDiameter,
          DEFAULT_FILLED_POINT_DIAMETER,
        );
        const pointDiameter = hollowPointDiameter;
        const rectangleWidth = normalizeRectangleSize(
          raw.rectangleWidth,
          DEFAULT_RECTANGLE_WIDTH,
        );
        const rectangleHeight = normalizeRectangleSize(
          raw.rectangleHeight,
          DEFAULT_RECTANGLE_HEIGHT,
        );
        const brezerStrokeWidth = normalizeBrezerStrokeWidth(raw.brezerStrokeWidth);
        const gradeBarBaseHeight = normalizeGradeBarHeight(
          raw.gradeBarBaseHeight,
          DEFAULT_GRADE_BAR_BASE_HEIGHT,
        );
        const gradeBarMaxHeight = Math.max(
          gradeBarBaseHeight,
          normalizeGradeBarHeight(raw.gradeBarMaxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
        );
        const gradeBarWidth = normalizeGradeBarWidth(raw.gradeBarWidth);
        const gradeBarTransparency = normalizeGradeBarTransparency(
          raw.gradeBarTransparency ?? raw.transparency,
        );
        const unfocusedTransparency = normalizeUnfocusedTransparency(
          raw.unfocusedTransparency ?? raw.unfocused_transparency,
        );

        return {
          pointDiameter,
          hollowPointDiameter,
          filledPointDiameter,
          rectangleWidth,
          rectangleHeight,
          brezerStrokeWidth,
          gradeBarBaseHeight,
          gradeBarMaxHeight,
          gradeBarWidth,
          gradeBarTransparency,
          unfocusedTransparency,
        };
      }

      function getWallPointDiameterForPathType(settings, pathTypeValue) {
        const normalized = normalizePathType(pathTypeValue);
        if (!settings || typeof settings !== 'object') {
          return getDefaultPointDiameterForPathType(normalized);
        }
        if (normalized === PATH_TYPE_FILLED_POINT) {
          return normalizePointDiameter(
            settings.filledPointDiameter ?? settings.pointDiameter,
            DEFAULT_FILLED_POINT_DIAMETER,
          );
        }
        if (normalized === PATH_TYPE_HOLLOW_POINT) {
          return normalizePointDiameter(
            settings.hollowPointDiameter ?? settings.pointDiameter,
            DEFAULT_HOLLOW_POINT_DIAMETER,
          );
        }
        return getDefaultPointDiameterForPathType(normalized);
      }

      function getRoutePointDiameterForPathType(route, pathTypeValue) {
        const normalized = normalizePathType(pathTypeValue ?? route?.pathType);
        if (!route || typeof route !== 'object') {
          return getDefaultPointDiameterForPathType(normalized);
        }
        if (normalized === PATH_TYPE_FILLED_POINT) {
          return normalizePointDiameter(
            route.filledPointDiameter ?? route.pointDiameter,
            DEFAULT_FILLED_POINT_DIAMETER,
          );
        }
        if (normalized === PATH_TYPE_HOLLOW_POINT) {
          return normalizePointDiameter(
            route.hollowPointDiameter ?? route.pointDiameter,
            DEFAULT_HOLLOW_POINT_DIAMETER,
          );
        }
        return getDefaultPointDiameterForPathType(normalized);
      }

      const wallSettingsCache = new Map();

      const normalizeLocationName = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      const normalizeWallKey = (value) => normalizeLocationName(value);

      function resolveWallSettings(locationKey, fallback = null) {
        const key = normalizeWallKey(locationKey);
        if (key) {
          const cached = wallSettingsCache.get(key);
          if (cached) {
            return { ...cached };
          }
        }

        if (fallback) {
          const normalized = normalizeWallSettings(fallback);
          if (key) {
            wallSettingsCache.set(key, normalized);
          }
          return normalized;
        }

        return {
          pointDiameter: DEFAULT_POINT_DIAMETER,
          hollowPointDiameter: DEFAULT_HOLLOW_POINT_DIAMETER,
          filledPointDiameter: DEFAULT_FILLED_POINT_DIAMETER,
          rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
          rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
          brezerStrokeWidth: DEFAULT_BREZER_STROKE_WIDTH,
          gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
          gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
          gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
          gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
          unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
        };
      }

      const findLocationByKey = (key) =>
        LOCATIONS.find((location) => location.key === key && isLocationVisible(location));

      const findLocationByName = (name) => {
        const normalized = normalizeLocationName(name);
        return (
          LOCATIONS.find(
            (location) => normalizeLocationName(location.name) === normalized && isLocationVisible(location),
          ) || null
        );
      };

      function buildWallAwareHref(baseHref, wallKey) {
        const normalizedKey = normalizeWallKey(wallKey);
        if (typeof baseHref !== 'string' || !baseHref) {
          return '';
        }

        try {
          const url = new URL(baseHref, window.location.origin);
          if (normalizedKey) {
            url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
          } else {
            url.searchParams.delete(WALL_QUERY_PARAM);
          }
          url.hash = '';
          const relativePath = `${url.pathname.replace(/^\//, '')}${url.search}`;
          return relativePath || baseHref;
        } catch (error) {
          if (!normalizedKey) {
            return baseHref;
          }

          const separator = baseHref.includes('?') ? '&' : '?';
          return `${baseHref}${separator}${encodeURIComponent(WALL_QUERY_PARAM)}=${encodeURIComponent(normalizedKey)}`;
        }
      }

      function getWallKeyFromQuery() {
        try {
          const params = new URLSearchParams(window.location.search);
          const raw = params.get(WALL_QUERY_PARAM);
          return normalizeWallKey(raw);
        } catch (error) {
          console.warn('Unable to read wall from query string:', error);
          return '';
        }
      }

      function updateWallQueryParam(wallKey) {
        try {
          const normalizedKey = normalizeWallKey(wallKey);
          const url = new URL(window.location.href);
          if (normalizedKey) {
            url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
          } else {
            url.searchParams.delete(WALL_QUERY_PARAM);
          }
          url.hash = '';
          const next = url.toString();
          if (next !== window.location.href) {
            window.history.replaceState({}, '', next);
          }
        } catch (error) {
          console.warn('Unable to update wall query parameter:', error);
        }
      }

      function persistSelectedWall(wallKey) {
        const normalizedKey = normalizeWallKey(wallKey);
        try {
          if (normalizedKey) {
            window.localStorage?.setItem(LOCATION_STORAGE_KEY, normalizedKey);
          } else {
            window.localStorage?.removeItem(LOCATION_STORAGE_KEY);
          }
        } catch (error) {
          console.warn('Unable to persist location preference:', error);
        }
      }

      function upsertLocation({
        key = '',
        name = '',
        image = '',
        fallbackName = '',
        hidden = false,
      } = {}) {
        const trimmedName = typeof name === 'string' && name.trim() ? name.trim() : '';
        const fallback =
          trimmedName || (typeof fallbackName === 'string' && fallbackName.trim() ? fallbackName.trim() : '');
        const keySource = typeof key === 'string' && key.trim() ? key.trim() : fallback;
        const normalizedKey = normalizeWallKey(keySource);
        const displayName = fallback;
        if (!normalizedKey || !displayName) {
          return { entry: null, changed: false };
        }

        const normalizedImage = typeof image === 'string' ? image.trim() : '';
        const normalizedHidden = Boolean(hidden);
        const existingIndex = LOCATIONS.findIndex((location) => {
          if (!location) {
            return false;
          }
          if (location.key === normalizedKey) {
            return true;
          }
          return normalizeLocationName(location.name) === normalizeLocationName(displayName);
        });

        if (existingIndex >= 0) {
          const existing = LOCATIONS[existingIndex];
          const needsUpdate =
            existing.key !== normalizedKey || existing.name !== displayName || existing.image !== normalizedImage;

          if (!needsUpdate) {
            const hiddenChanged = Boolean(existing.hidden) !== normalizedHidden;
            if (hiddenChanged) {
              existing.hidden = normalizedHidden;
              return { entry: existing, changed: true };
            }
            return { entry: existing, changed: false };
          }

          const updated = {
            ...existing,
            key: normalizedKey,
            name: displayName,
            image: normalizedImage,
            hidden: normalizedHidden,
          };
          LOCATIONS[existingIndex] = updated;
          return { entry: updated, changed: true };
        }

        const created = {
          key: normalizedKey,
          name: displayName,
          image: normalizedImage,
          hidden: normalizedHidden,
        };
        LOCATIONS.push(created);
        return { entry: created, changed: true };
      }

      function ensureCurrentLocationVisible() {
        if (isLocationVisible(currentLocation)) {
          return;
        }

        const fallback = getDefaultLocation();
        if (fallback) {
          const changed = !currentLocation || currentLocation.key !== fallback.key;
          currentLocation = fallback;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          updateBackgroundForCurrentLocation();
          const fallbackKey = getCurrentLocationKey();
          if (fallbackKey) {
            persistSelectedWall(fallbackKey);
            updateWallQueryParam(fallbackKey);
          } else {
            persistSelectedWall('');
            updateWallQueryParam('');
          }
          updateSetterLinkHref();
          if (changed) {
            applyLocationFilter();
          }
          return;
        }

        currentLocation = null;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();
        persistSelectedWall('');
        updateWallQueryParam('');
        updateSetterLinkHref();
        applyLocationFilter();
      }

      function synchronizeCurrentLocationReference() {
        if (!currentLocation) {
          ensureCurrentLocationVisible();
          return;
        }

        const normalizedKey = normalizeWallKey(currentLocation.key || currentLocation.name);
        const refreshed =
          (normalizedKey && findLocationByKey(normalizedKey)) ||
          findLocationByName(currentLocation.name);

        if (refreshed && refreshed !== currentLocation) {
          currentLocation = refreshed;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          updateBackgroundForCurrentLocation();
          const refreshedKey = getCurrentLocationKey();
          if (refreshedKey) {
            persistSelectedWall(refreshedKey);
            updateWallQueryParam(refreshedKey);
          } else {
            persistSelectedWall('');
            updateWallQueryParam('');
          }
          updateSetterLinkHref();
        }

        ensureCurrentLocationVisible();
      }

      let currentLocation = getDefaultLocation();

      function getCurrentLocationKey() {
        return normalizeWallKey(currentLocation?.key || currentLocation?.name);
      }

      function updateSetterLinkHref() {
        if (!setterLink) {
          return;
        }

        const wallKey = getCurrentLocationKey();
        setterLink.href = buildWallAwareHref(setterLinkBaseHref, wallKey);
      }

      let backgroundReady = false;
      let backgroundImageSource = '';
      let viewMode = VIEW_MODE_HOLD_COLORS;

      const backgroundImage = new Image();

      function getViewModeMetadata(mode) {
        if (mode && VIEW_MODE_META[mode]) {
          return VIEW_MODE_META[mode];
        }
        return VIEW_MODE_META[VIEW_MODE_HOLD_COLORS];
      }

      function getNextViewMode(mode) {
        const currentIndex = VIEW_MODE_SEQUENCE.indexOf(mode);
        if (currentIndex === -1) {
          return VIEW_MODE_SEQUENCE[0];
        }
        return VIEW_MODE_SEQUENCE[(currentIndex + 1) % VIEW_MODE_SEQUENCE.length];
      }

      function updateLocationButtonLabel() {
        const labelText = currentLocation?.name || 'Select wall';
        if (locationButton) {
          locationButton.setAttribute('aria-label', `Select wall: ${labelText}`);
          locationButton.setAttribute('title', labelText);
        }
      }

      function syncViewModeState() {
        if (!document.body) {
          return;
        }
        document.body.classList.toggle('view-mode-grade-colors', viewMode === VIEW_MODE_GRADE_COLORS);
        document.body.classList.toggle('view-mode-hold-colors', viewMode === VIEW_MODE_HOLD_COLORS);
      }

      function updateViewToggleButtons() {
        if (!viewToggleButtons.length) {
          return;
        }

        viewToggleButtons.forEach((button) => {
          if (!button) {
            return;
          }
          if (button.dataset?.viewModeCycle) {
            const metadata = getViewModeMetadata(viewMode);
            const label = metadata?.label ?? '';
            const tooltipText = label || 'Showing routes';
            const nextMode = metadata?.next ?? getNextViewMode(viewMode);

            button.dataset.viewMode = viewMode;
            button.dataset.tooltip = tooltipText;
            button.dataset.nextViewMode = nextMode;

            if (tooltipText) {
              button.setAttribute('title', tooltipText);
              button.setAttribute('aria-label', tooltipText);
            } else {
              button.removeAttribute('title');
              button.removeAttribute('aria-label');
            }

            button.setAttribute('aria-pressed', 'true');
            button.classList.add('is-active');

            const srLabel = button.querySelector('[data-view-toggle-label]');
            if (srLabel) {
              srLabel.textContent = tooltipText;
            }

            return;
          }

          const mode = button.dataset?.viewMode;
          const tooltip = button.dataset?.tooltip;
          if (tooltip) {
            button.setAttribute('title', tooltip);
            button.setAttribute('aria-label', tooltip);
          }

          const isActive = mode === viewMode;
          button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          button.classList.toggle('is-active', isActive);
        });
      }

      function setViewMode(mode) {
        const allowedModes = new Set([VIEW_MODE_GRADE_COLORS, VIEW_MODE_HOLD_COLORS]);
        const normalized = allowedModes.has(mode) ? mode : VIEW_MODE_HOLD_COLORS;
        if (viewMode === normalized) {
          return;
        }

        viewMode = normalized;
        syncViewModeState();
        updateViewToggleButtons();
        hideTooltip({ force: true });
        if (canvas) {
          canvas.style.cursor = '';
        }
        redraw();
      }

      function updateLocationOptionsState() {
        if (!locationOptions) {
          return;
        }

        const buttons = locationOptions.querySelectorAll('[data-location-key]');
        buttons.forEach((button) => {
          const key = button?.dataset?.locationKey;
          if (key && currentLocation && key === currentLocation.key) {
            button.setAttribute('aria-current', 'true');
          } else {
            button.removeAttribute('aria-current');
          }
        });
      }

      function applyBodyBackground(imagePath) {
        if (!document.body) {
          return;
        }

        if (imagePath) {
          document.body.style.setProperty('--wall-background', `url('${imagePath}')`);
        } else {
          document.body.style.removeProperty('--wall-background');
        }
      }

      function updateBackgroundForCurrentLocation() {
        const imagePath = currentLocation?.image || '';
        applyBodyBackground(imagePath);

        if (imagePath && imagePath !== backgroundImageSource) {
          backgroundImageSource = imagePath;
          backgroundReady = false;
          backgroundImage.src = imagePath;
        } else if (!imagePath) {
          backgroundImageSource = '';
          backgroundReady = false;
        }
      }

      backgroundImage.onload = () => {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      };

      backgroundImage.onerror = () => {
        backgroundReady = false;
        resizeCanvas();
      };

      function closeLocationModal() {
        if (!locationModal) {
          return;
        }

        if (!locationModal.classList.contains('hidden')) {
          locationModal.classList.add('hidden');
          locationModal.setAttribute('aria-hidden', 'true');
          locationButton?.setAttribute('aria-expanded', 'false');
        }

        locationModal.classList.remove('is-top-aligned');
      }

      function openLocationModal() {
        if (!locationModal) {
          return;
        }

        locationModal.classList.remove('hidden');
        locationModal.setAttribute('aria-hidden', 'false');
        locationButton?.setAttribute('aria-expanded', 'true');
        updateLocationOptionsState();
      }

      function handleLocationSelection(locationKey) {
        const location = findLocationByKey(locationKey);
        if (!location) {
          return;
        }

        const changed = !currentLocation || currentLocation.key !== location.key;
        currentLocation = location;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();

        const nextLocationKey = getCurrentLocationKey();
        if (nextLocationKey) {
          persistSelectedWall(nextLocationKey);
        }
        updateWallQueryParam(nextLocationKey);
        updateSetterLinkHref();

        if (changed) {
          applyLocationFilter();
        }

        closeLocationModal();
      }

      function renderLocationOptions() {
        if (!locationOptions) {
          return;
        }

        locationOptions.replaceChildren();

        LOCATIONS.filter(isLocationVisible).forEach((location) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'location-option';
          button.dataset.locationKey = location.key;
          button.setAttribute('role', 'option');

          const preview = document.createElement('div');
          preview.className = 'location-option-preview';
          preview.style.backgroundImage = `url('${location.image}')`;
          button.appendChild(preview);

          const label = document.createElement('span');
          label.className = 'location-option-label';
          label.textContent = location.name;
          button.appendChild(label);

          button.addEventListener('click', () => {
            handleLocationSelection(location.key);
          });

          locationOptions.appendChild(button);
        });

        updateLocationOptionsState();
      }

      const SYNTHETIC_EMAIL_DOMAIN = 'users.anuascend.local';
      const USERNAME_PATTERN = /^[a-z0-9_]{3,20}$/;

      const normalizeUsername = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      function cacheAuthenticatedUsername(username) {
        const normalized = normalizeUsername(username);
        authenticatedUsernameClaim = isValidUsername(normalized) ? normalized : '';
        return authenticatedUsernameClaim;
      }

      async function resolveAuthenticatedUsername(options = {}) {
        const { forceRefresh = false } = options;

        if (!currentUser) {
          authenticatedUsernameClaim = '';
          return isValidUsername(currentUsername) ? normalizeUsername(currentUsername) : '';
        }

        if (!forceRefresh) {
          const cachedClaim = normalizeUsername(authenticatedUsernameClaim);
          if (isValidUsername(cachedClaim)) {
            return cachedClaim;
          }
        }

        const fallbackUsername = isValidUsername(currentUsername)
          ? normalizeUsername(currentUsername)
          : '';

        try {
          const tokenResult = await getIdTokenResult(currentUser, forceRefresh);
          const claimUsername = normalizeUsername(tokenResult?.claims?.username);

          if (isValidUsername(claimUsername)) {
            return cacheAuthenticatedUsername(claimUsername);
          }
        } catch (error) {
          console.warn(
            forceRefresh
              ? 'Failed to refresh authenticated username claim:'
              : 'Failed to read authenticated username claim:',
            error,
          );
        }

        if (!forceRefresh) {
          return resolveAuthenticatedUsername({ forceRefresh: true });
        }

        if (fallbackUsername) {
          return cacheAuthenticatedUsername(fallbackUsername);
        }

        return '';
      }

      async function ensureUidUsernameMapping(user, username) {
        if (!user) {
          return;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!isValidUsername(normalizedUsername)) {
          return;
        }

        try {
          const userRef = doc(db, 'users', user.uid);
          const snapshot = await getDoc(userRef);

          if (!snapshot.exists()) {
            try {
              await ensureUserRole(user, normalizedUsername);
            } catch (creationError) {
              console.warn(
                'Failed to create user record while synchronising username mapping:',
                creationError,
              );
              return;
            }
          }

          await setDoc(
            userRef,
            {
              username: normalizedUsername,
              updatedAt: serverTimestamp(),
            },
            { merge: true },
          );
          uidUsernameCache.set(user.uid, normalizedUsername);
        } catch (error) {
          console.warn('Failed to synchronise username mapping for betatips:', error);
        }
      }

      const buildSyntheticEmail = (username) => {
        const normalized = normalizeUsername(username);
        return normalized ? `${normalized}@${SYNTHETIC_EMAIL_DOMAIN}` : '';
      };

      const isValidUsername = (value) => USERNAME_PATTERN.test(normalizeUsername(value));

      const tooltipColorCanvas = document.createElement('canvas');
      const tooltipColorContext = tooltipColorCanvas.getContext('2d');

      function getTextColor(bgColor) {
        const context = document.createElement('canvas').getContext('2d');
        if (!context) {
          return '#fff';
        }

        context.fillStyle = '#000';
        context.fillStyle = bgColor;
        const values = context.fillStyle.match(/\d+/g);

        if (!values || values.length < 3) {
          return '#fff';
        }

        const [r, g, b] = values.map(Number);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        return luminance > 0.5 ? '#000' : '#fff';
      }

      function parseTooltipColor(color) {
        if (!tooltipColorContext || typeof color !== 'string') {
          return null;
        }

        let normalized;
        try {
          tooltipColorContext.fillStyle = '#000000';
          tooltipColorContext.fillStyle = color;
          normalized = tooltipColorContext.fillStyle;
        } catch (error) {
          return null;
        }

        if (typeof normalized !== 'string' || !normalized) {
          return null;
        }

        if (/^#[0-9a-f]{6}$/i.test(normalized)) {
          const r = parseInt(normalized.slice(1, 3), 16);
          const g = parseInt(normalized.slice(3, 5), 16);
          const b = parseInt(normalized.slice(5, 7), 16);
          return { r, g, b, hex: normalized };
        }

        const rgbaMatch = normalized
          .replace(/\s+/g, '')
          .match(/^rgba?\((\d+),(\d+),(\d+)(?:,(0|1|0?\.\d+))?\)$/i);

        if (rgbaMatch) {
          const [, r, g, b] = rgbaMatch;
          return {
            r: Number.parseInt(r, 10),
            g: Number.parseInt(g, 10),
            b: Number.parseInt(b, 10),
            hex: null,
          };
        }

        return null;
      }

      function deriveTooltipColorScheme(color) {
        const parsed = parseTooltipColor(color);

        if (!parsed) {
          return null;
        }

        const clamp = (value) => Math.max(0, Math.min(255, value));
        const r = clamp(parsed.r);
        const g = clamp(parsed.g);
        const b = clamp(parsed.b);
        const rgbString = `${r}, ${g}, ${b}`;
        const accent = parsed.hex ? parsed.hex : `rgb(${rgbString})`;
        const soft = `rgba(${rgbString}, 0.18)`;
        const strong = `rgba(${rgbString}, 0.85)`;
        const surfaceFactor = 0.22;
        const surfaceOffset = 18;
        const mixChannel = (channel) => clamp(Math.round(channel * surfaceFactor + surfaceOffset));
        const surface = `rgb(${mixChannel(r)}, ${mixChannel(g)}, ${mixChannel(b)})`;
        const onAccent = getTextColor(strong);
        const foreground = getTextColor(surface);
        const softForeground = foreground;
        const mutedForeground = foreground === '#000' ? '#333333' : '#d1d5db';

        return {
          accent,
          rgb: rgbString,
          soft,
          strong,
          onAccent,
          foreground,
          softForeground,
          mutedForeground,
          surface,
          border: accent,
        };
      }

      const FALLBACK_TOOLTIP_SCHEME = (() => {
        const defaultRgb = '126, 217, 87';
        const soft = 'rgba(126, 217, 87, 0.18)';
        const strong = 'rgba(126, 217, 87, 0.85)';
        const surface = 'rgb(43, 71, 47)';
        const foreground = getTextColor(surface);

        return {
          accent: '#7ed957',
          rgb: defaultRgb,
          soft,
          strong,
          onAccent: getTextColor(strong),
          foreground,
          softForeground: foreground,
          mutedForeground: foreground === '#000' ? '#333333' : '#d1d5db',
          surface,
          border: '#7ed957',
        };
      })();

      const DEFAULT_TOOLTIP_SCHEME =
        deriveTooltipColorScheme('#7ed957') ?? FALLBACK_TOOLTIP_SCHEME;

      function applyTooltipColorScheme(route) {
        if (!tooltip) {
          return;
        }

        const base = DEFAULT_TOOLTIP_SCHEME;
        const scheme = deriveTooltipColorScheme(getRouteDisplayColor(route)) ?? base;

        const accent = scheme.accent ?? base.accent;
        const rgb = scheme.rgb ?? base.rgb;
        const soft = scheme.soft ?? base.soft;
        const strong = scheme.strong ?? base.strong;
        const onAccent = scheme.onAccent ?? base.onAccent;
        const foreground = scheme.foreground ?? base.foreground;
        const softForeground = scheme.softForeground ?? base.softForeground;
        const mutedForeground = scheme.mutedForeground ?? base.mutedForeground;
        const surface = scheme.surface ?? base.surface;
        const border = scheme.border ?? base.border ?? accent;

        tooltip.style.setProperty('--tooltip-accent', accent);
        tooltip.style.setProperty('--tooltip-accent-rgb', rgb);
        tooltip.style.setProperty('--tooltip-accent-soft', soft);
        tooltip.style.setProperty('--tooltip-accent-strong', strong);
        tooltip.style.setProperty('--tooltip-on-accent', onAccent);
        tooltip.style.setProperty('--tooltip-foreground', foreground);
        tooltip.style.setProperty('--tooltip-soft-foreground', softForeground);
        tooltip.style.setProperty('--tooltip-muted-foreground', mutedForeground);
        tooltip.style.setProperty('--tooltip-surface', surface);
        tooltip.style.setProperty('--tooltip-border-color', border);
      }

      if (infoButton) {
        infoButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleInfoMode();
        });
      }

      if (infoPopover) {
        infoPopover.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }

      document.addEventListener(
        'pointerdown',
        (event) => {
          if (!infoModeActive || !awaitingInfoTargetSelection) {
            return;
          }

          const targetElement =
            event.target instanceof Element ? event.target.closest('[data-info-target]') : null;
          if (!targetElement) {
            return;
          }

          const infoKey = targetElement.getAttribute('data-info-target');
          if (!infoKey) {
            return;
          }

          handleInfoRequestFor(infoKey, event, { target: targetElement });
        },
        true,
      );

      document.addEventListener(
        'keydown',
        (event) => {
          if (!infoModeActive || !awaitingInfoTargetSelection) {
            return;
          }

          const key = event.key;
          if (key !== 'Enter' && key !== ' ' && key !== 'Spacebar') {
            return;
          }

          const targetElement =
            event.target instanceof Element ? event.target.closest('[data-info-target]') : null;
          if (!targetElement) {
            return;
          }

          const infoKey = targetElement.getAttribute('data-info-target');
          if (!infoKey) {
            return;
          }

          handleInfoRequestFor(infoKey, event, { target: targetElement });
        },
        true,
      );

      renderLocationOptions();

      const wallKeyFromQuery = getWallKeyFromQuery();
      let initialLocation = wallKeyFromQuery
        ? findLocationByKey(wallKeyFromQuery) || findLocationByName(wallKeyFromQuery)
        : null;

      let storedLocationKey = null;
      if (!initialLocation) {
        try {
          storedLocationKey = window.localStorage?.getItem(LOCATION_STORAGE_KEY) || null;
        } catch (error) {
          console.warn('Unable to read location preference:', error);
        }

        if (storedLocationKey) {
          const normalizedStoredKey = normalizeWallKey(storedLocationKey);
          initialLocation =
            findLocationByKey(normalizedStoredKey) || findLocationByName(normalizedStoredKey);
        }
      }

      if (initialLocation) {
        currentLocation = initialLocation;
      }

      ensureCurrentLocationVisible();

      const currentLocationKey = getCurrentLocationKey();
      if (currentLocationKey) {
        persistSelectedWall(currentLocationKey);
      }
      updateWallQueryParam(currentLocationKey);
      updateSetterLinkHref();

      updateLocationButtonLabel();
      updateLocationOptionsState();
      if (locationButton) {
        locationButton.setAttribute('aria-expanded', 'false');
      }
      updateBackgroundForCurrentLocation();

      if (locationButton) {
        locationButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('location', event)) {
            return;
          }
          if (activeInfoCallout?.target === locationButton) {
            clearInfoHighlights();
          }
          event.preventDefault();
          openLocationModal();
        });
      }

      if (viewToggleButtons.length) {
        viewToggleButtons.forEach((button) => {
          if (!button) {
            return;
          }

          button.addEventListener('click', (event) => {
            if (handleInfoRequestFor('view-toggle', event, { button })) {
              return;
            }
            if (activeInfoCallout?.target && isViewToggleElement(activeInfoCallout.target)) {
              clearInfoHighlights();
            }

            const targetMode = button.dataset?.viewModeCycle
              ? button.dataset?.nextViewMode || getNextViewMode(viewMode)
              : button.dataset?.viewMode;
            setViewMode(targetMode);
          });
        });
      }

      if (progressionButton) {
        progressionButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('progression', event)) {
            return;
          }
          if (activeInfoCallout?.target === progressionButton) {
            clearInfoHighlights();
          }
          event.preventDefault();
          if (isProgressionModalOpen()) {
            closeProgressionModal();
          } else {
            openProgressionModal();
          }
        });
      }

      if (setterLink) {
        setterLink.addEventListener('click', (event) => {
          if (handleInfoRequestFor('setter-link', event)) {
            return;
          }
          if (activeInfoCallout?.target === setterLink) {
            clearInfoHighlights();
          }
        });
      }

      if (locationModalClose) {
        locationModalClose.addEventListener('click', (event) => {
          event.preventDefault();
          closeLocationModal();
        });
      }

      if (locationModal) {
        locationModal.addEventListener('click', (event) => {
          if (event.target === locationModal) {
            closeLocationModal();
          }
        });
      }

      if (progressionModalClose) {
        progressionModalClose.addEventListener('click', (event) => {
          event.preventDefault();
          closeProgressionModal();
        });
      }

      if (progressionModal) {
        progressionModal.addEventListener('click', (event) => {
          if (event.target === progressionModal) {
            closeProgressionModal();
          }
        });
      }

      window.addEventListener('resize', scheduleInfoHighlightsReposition);
      window.addEventListener('scroll', scheduleInfoHighlightsReposition, true);

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeLocationModal();
          closeProgressionModal();
          if (infoModeActive) {
            deactivateInfoMode({ clearCallout: true });
            if (infoButton) {
              infoButton.focus();
            }
          } else if (activeInfoCallout) {
            clearInfoHighlights();
            if (infoButton) {
              infoButton.focus();
            }
          }
        }
      });

      let authMode = 'login';
      let currentUser = null;
      let currentUsername = '';
      let authenticatedUsernameClaim = '';
      
      function setAuthMode(mode) {
        authMode = mode;
        const isLogin = authMode === 'login';
        authTitle.textContent = isLogin ? 'Sign in to continue' : 'Create your account';
        authSwitchLabel.textContent = isLogin ? "Don't have an account?" : 'Already have an account?';
        toggleAuthModeButton.textContent = isLogin ? 'Create one' : 'Sign in';
        authForm.querySelector('.auth-submit').textContent = isLogin ? 'Sign In' : 'Create Account';
        authPassword.setAttribute('autocomplete', isLogin ? 'current-password' : 'new-password');
        authError.textContent = '';
      }

      toggleAuthModeButton.addEventListener('click', () => {
        setAuthMode(authMode === 'login' ? 'register' : 'login');
      });

      async function lookupUsernameByUid(uid) {
        const normalizedUid = typeof uid === 'string' ? uid.trim() : '';
        if (!normalizedUid) {
          return '';
        }

        const cached = uidUsernameCache.get(normalizedUid);
        if (typeof cached === 'string') {
          return cached;
        }

        try {
          const userSnap = await getDoc(doc(db, 'users', normalizedUid));

          if (!userSnap.exists()) {
            uidUsernameCache.set(normalizedUid, '');
            return '';
          }

          const data = userSnap.data() || {};
          const resolved = normalizeUsername(typeof data.username === 'string' ? data.username : '');
          const normalizedUsername = isValidUsername(resolved) ? resolved : '';
          uidUsernameCache.set(normalizedUid, normalizedUsername);
          return normalizedUsername;
        } catch (error) {
          console.error('Failed to look up username by UID:', error);
          uidUsernameCache.set(normalizedUid, '');
          return '';
        }
      }

      async function resolveUsernameForUser(user) {
        if (!user) {
          return '';
        }

        const displayName = normalizeUsername(user.displayName);
        if (isValidUsername(displayName)) {
          return displayName;
        }

        const mapped = await lookupUsernameByUid(user.uid);
        if (isValidUsername(mapped)) {
          if (!displayName) {
            try {
              await updateProfile(user, { displayName: mapped });
            } catch (error) {
              console.warn('Unable to synchronise display name with username:', error);
            }
          }
          return mapped;
        }

        const syntheticEmail = typeof user.email === 'string' ? user.email : '';
        if (syntheticEmail.endsWith(`@${SYNTHETIC_EMAIL_DOMAIN}`)) {
          const derived = normalizeUsername(
            syntheticEmail.slice(0, -(`@${SYNTHETIC_EMAIL_DOMAIN}`.length)),
          );
          if (isValidUsername(derived)) {
            return derived;
          }
        }

        return '';
      }

      authForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        authError.textContent = '';

        const rawUsername = authUsername.value;
        const normalizedUsername = normalizeUsername(rawUsername);
        const password = authPassword.value;

        if (!normalizedUsername) {
          authError.textContent = 'Enter your username to continue.';
          return;
        }

        if (!isValidUsername(normalizedUsername)) {
          authError.textContent =
            'Usernames must be 3-20 characters using only letters, numbers, or underscores.';
          return;
        }

        const syntheticEmail = buildSyntheticEmail(normalizedUsername);

        try {
          if (authMode === 'login') {
            await signInWithEmailAndPassword(auth, syntheticEmail, password);
            return;
          }

          const credentials = await createUserWithEmailAndPassword(auth, syntheticEmail, password);
          const { user } = credentials;

          try {
            await updateProfile(user, { displayName: normalizedUsername });
          } catch (profileError) {
            console.warn('Failed to update display name:', profileError);
          }

          try {
            await ensureUserRole(user, normalizedUsername);
          } catch (error) {
            console.error('Failed to initialize user record:', error);
            try {
              await deleteUser(user);
            } catch (cleanupError) {
              console.warn('Unable to clean up user after initialization failure:', cleanupError);
            }
            if (error && typeof error === 'object' && 'code' in error) {
              throw error;
            }
            const initializationError = new Error('Username unavailable');
            initializationError.code = 'auth/username-unavailable';
            throw initializationError;
          }
        } catch (error) {
          let message = 'Unable to complete the request. Please try again.';

          switch (error?.code) {
            case 'auth/user-not-found':
            case 'auth/wrong-password':
              message = 'Invalid username or password.';
              break;
            case 'auth/email-already-in-use':
            case 'auth/username-unavailable':
            case 'permission-denied':
              message = 'That username is already taken. Choose another one.';
              break;
            case 'auth/invalid-email':
              message = 'Enter a valid username.';
              break;
            case 'auth/weak-password':
              message = 'Choose a stronger password (at least 6 characters).';
              break;
            default:
              if (error?.message) {
                message = error.message;
              }
          }

          authError.textContent = message;
        }
      });

      if (loginButton) {
        loginButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('log-in', event)) {
            return;
          }
          if (activeInfoCallout?.target === loginButton) {
            clearInfoHighlights();
          }
          // Allow default navigation to the personal dashboard.
        });
      }

      async function ensureUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);

        if (!normalizedUsername) {
          return { role: null };
        }

        const userRef = doc(db, 'users', user.uid);

        try {
          const existingSnap = await getDoc(userRef);

          if (existingSnap.exists()) {
            const data = existingSnap.data() || {};
            const storedUsername = normalizeUsername(
              typeof data.username === 'string' ? data.username : '',
            );
            const trimmedRole =
              typeof data.role === 'string' ? data.role.trim().toLowerCase() : '';

            const updates = {};

            if (storedUsername !== normalizedUsername) {
              const conflictSnapshot = await getDocs(
                query(collection(db, 'users'), where('username', '==', normalizedUsername), limit(1)),
              );

              if (!conflictSnapshot.empty && conflictSnapshot.docs[0].id !== user.uid) {
                const usernameError = new Error('Username unavailable');
                usernameError.code = 'auth/username-unavailable';
                throw usernameError;
              }

              updates.username = normalizedUsername;
              updates.updatedAt = serverTimestamp();
            } else if (!data.updatedAt) {
              updates.updatedAt = serverTimestamp();
            }

            if (Object.keys(updates).length > 0) {
              await setDoc(userRef, updates, { merge: true });
            }

            return {
              ...data,
              ...(updates.username ? { username: normalizedUsername } : {}),
              ...(updates.updatedAt ? { updatedAt: updates.updatedAt } : {}),
              role: trimmedRole || null,
            };
          }

          const conflictSnapshot = await getDocs(
            query(collection(db, 'users'), where('username', '==', normalizedUsername), limit(1)),
          );

          if (!conflictSnapshot.empty) {
            const usernameError = new Error('Username unavailable');
            usernameError.code = 'auth/username-unavailable';
            throw usernameError;
          }

          const timestamp = serverTimestamp();
          const userData = {
            username: normalizedUsername,
            createdAt: timestamp,
            updatedAt: timestamp,
            role: null,
          };

          await setDoc(userRef, userData);

          return userData;
        } catch (error) {
          console.error('Failed to ensure user record:', error);
          throw error;
        }
      }

      async function resolveUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return 'default';
        }

        try {
          const ensuredRole = await ensureUserRole(user, normalizedUsername);
          return typeof ensuredRole?.role === 'string' && ensuredRole.role.trim()
            ? ensuredRole.role.trim().toLowerCase()
            : 'default';
        } catch (error) {
          if (error && typeof error === 'object' && 'code' in error) {
            const code = String(error.code);
            if (code === 'permission-denied') {
              return 'default';
            }
          }
          console.error('Failed to fetch user role:', error);
          return 'default';
        }
      }

      function updateNavigationForRole(role) {
        updateSetterLinkHref();
        if (!setterLink) {
          return;
        }

        const normalizedRole = typeof role === 'string' ? role.trim().toLowerCase() : '';
        const shouldHideSetterLink =
          normalizedRole !== 'setter' && normalizedRole !== 'admin';
        setterLink.classList.toggle('hidden', shouldHideSetterLink);

        if (shouldHideSetterLink && activeInfoCallout?.target === setterLink) {
          clearInfoHighlights();
        }
      }

      async function presentGuestExperience() {
        if (authOverlay) {
          authOverlay.classList.add('hidden');
          authOverlay.setAttribute('aria-hidden', 'true');
        }

        appContent.classList.remove('hidden');
        updateNavigationForRole('default');

        if (setterLink) {
          setterLink.classList.add('hidden');
        }

        if (infoModeActive) {
          deactivateInfoMode({ clearCallout: true });
        } else if (activeInfoCallout) {
          clearInfoHighlights();
        }

        authForm?.reset();
        if (authError) {
          authError.textContent = '';
        }
        setAuthMode('login');

        focusedRouteId = null;
        updateClearFocusButton();
        currentUser = null;
        currentUsername = '';
        authenticatedUsernameClaim = '';
        ascendedRoutes.clear();
        userAscentDetails = new Map();
        routeScoresCache.clear();
        routeBetatipsCache.clear();
        uidUsernameCache.clear();
        hideTooltip({ force: true });

        await loadRoutes();
      }

      function openTutorialOverlay() {
        if (!tutorialOverlay || !tutorialDialogCard) {
          return;
        }

        tutorialPreviousFocus =
          document.activeElement instanceof HTMLElement ? document.activeElement : null;

        tutorialOverlay.classList.remove('hidden');
        tutorialOverlay.setAttribute('aria-hidden', 'false');

        window.setTimeout(() => {
          tutorialDialogCard.focus();
        }, 0);
      }

      function closeTutorialOverlay() {
        if (!tutorialOverlay) {
          return;
        }

        tutorialOverlay.classList.add('hidden');
        tutorialOverlay.setAttribute('aria-hidden', 'true');

        if (tutorialPreviousFocus && typeof tutorialPreviousFocus.focus === 'function') {
          tutorialPreviousFocus.focus();
        }

        tutorialPreviousFocus = null;
      }

      function setTutorialDescriptionContent(lines) {
        if (!tutorialDescription) {
          return;
        }

        tutorialDescription.innerHTML = '';

        if (!Array.isArray(lines)) {
          return;
        }

        const fragment = document.createDocumentFragment();

        lines.forEach((item) => {
          if (typeof item === 'string') {
            const trimmed = item.trim();
            if (trimmed.length === 0) {
              return;
            }
            const paragraph = document.createElement('p');
            paragraph.textContent = trimmed;
            fragment.appendChild(paragraph);
            return;
          }

          let node = null;

          if (typeof item === 'function') {
            try {
              node = item();
            } catch (error) {
              console.warn('Unable to render tutorial content item:', error);
            }
          } else if (item instanceof Node) {
            node = item;
          }

          if (node instanceof Node) {
            fragment.appendChild(node);
          }
        });

        tutorialDescription.appendChild(fragment);
      }

      let tutorialPointer = null;
      let tutorialPointerTarget = null;

      function ensureTutorialPointer() {
        if (tutorialPointer) {
          return tutorialPointer;
        }

        tutorialPointer = document.createElement('div');
        tutorialPointer.className = 'tutorial-pointer hidden';
        tutorialPointer.setAttribute('aria-hidden', 'true');
        tutorialPointer.innerHTML =
          '<svg viewBox="0 0 64 96" role="presentation" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><path fill="#27b4db" d="M32 0l32 36H44v56H20V36H0z"/></svg>';
        document.body.appendChild(tutorialPointer);

        return tutorialPointer;
      }

      function updateTutorialPointerPosition() {
        if (!tutorialPointer || tutorialPointer.classList.contains('hidden')) {
          return;
        }

        if (!tutorialPointerTarget || !isElementVisible(tutorialPointerTarget)) {
          hideTutorialPointer();
          return;
        }

        const rect = tutorialPointerTarget.getBoundingClientRect();
        const verticalOffset = 12;

        tutorialPointer.style.left = `${rect.left + rect.width / 2}px`;
        tutorialPointer.style.top = `${rect.bottom + verticalOffset}px`;
      }

      function showTutorialPointerFor(element) {
        if (!(element instanceof HTMLElement) || !isElementVisible(element)) {
          hideTutorialPointer();
          return;
        }

        ensureTutorialPointer();

        tutorialPointerTarget = element;
        tutorialPointer.classList.remove('hidden');
        tutorialPointer.setAttribute('aria-hidden', 'false');
        updateTutorialPointerPosition();
      }

      function hideTutorialPointer() {
        if (!tutorialPointer) {
          tutorialPointerTarget = null;
          return;
        }

        tutorialPointerTarget = null;
        tutorialPointer.classList.add('hidden');
        tutorialPointer.setAttribute('aria-hidden', 'true');
      }

      window.addEventListener('resize', updateTutorialPointerPosition);
      window.addEventListener('scroll', updateTutorialPointerPosition, true);

      function highlightTutorialElement(element, options = {}) {
        const shouldIlluminate = options?.illuminate === true;

        if (tutorialHighlightedElement) {
          if (tutorialHighlightedElement !== element || !element) {
            tutorialHighlightedElement.classList.remove('tutorial-highlight');
            tutorialHighlightedElement.classList.remove('tutorial-illuminated');
            tutorialHighlightedElementOptions = { illuminate: false };
          } else if (tutorialHighlightedElementOptions.illuminate !== shouldIlluminate) {
            tutorialHighlightedElement.classList.toggle('tutorial-illuminated', shouldIlluminate);
            tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
            return;
          }
        }

        if (element && element.classList) {
          element.classList.add('tutorial-highlight');
          element.classList.toggle('tutorial-illuminated', shouldIlluminate);
          tutorialHighlightedElement = element;
          tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
        } else {
          tutorialHighlightedElement = null;
          tutorialHighlightedElementOptions = { illuminate: false };
        }
      }

      function disableInteractiveElementsForTutorial() {
        const interactiveElements = document.querySelectorAll('button, a, [role="button"]');

        interactiveElements.forEach((element) => {
          if (!(element instanceof HTMLElement)) {
            return;
          }

          if (element.dataset.tutorialExempt === 'true') {
            return;
          }

          if (element instanceof HTMLButtonElement) {
            element.dataset.tutorialWasDisabled = element.disabled ? 'true' : 'false';
            element.disabled = true;
          } else {
            const alreadyDisabled = element.getAttribute('aria-disabled') === 'true';
            element.dataset.tutorialWasDisabled = alreadyDisabled ? 'true' : 'false';
            element.setAttribute('aria-disabled', 'true');
          }

          element.classList.add('is-tutorial-disabled');
        });
      }

      function restoreInteractiveElementsAfterTutorial() {
        const interactiveElements = document.querySelectorAll('button, a, [role="button"]');

        interactiveElements.forEach((element) => {
          if (!(element instanceof HTMLElement)) {
            return;
          }

          if (element.dataset.tutorialExempt === 'true') {
            return;
          }

          const wasDisabled = element.dataset.tutorialWasDisabled === 'true';

          if (element instanceof HTMLButtonElement) {
            if (!wasDisabled) {
              element.disabled = false;
            }
          } else if (!wasDisabled) {
            element.removeAttribute('aria-disabled');
          }

          element.classList.remove('is-tutorial-disabled');
          delete element.dataset.tutorialWasDisabled;
        });
      }

      async function ensureRoutesAvailableForTutorial() {
        if (Array.isArray(routes) && routes.length) {
          return routes;
        }

        if (Array.isArray(allRoutes) && allRoutes.length) {
          return allRoutes;
        }

        try {
          await loadRoutes();
        } catch (error) {
          console.warn('Unable to refresh routes for tutorial:', error);
        }

        if (Array.isArray(routes) && routes.length) {
          return routes;
        }

        if (Array.isArray(allRoutes) && allRoutes.length) {
          return allRoutes;
        }

        return [];
      }

      async function showTutorialRouteTooltip() {
        const availableRoutes = await ensureRoutesAvailableForTutorial();
        if (!Array.isArray(availableRoutes) || availableRoutes.length === 0) {
          return;
        }

        const targetRoute = availableRoutes.find((route) => getRouteId(route));
        if (!targetRoute) {
          return;
        }

        tutorialHighlightedRouteId = targetRoute.id;
        focusRoute(targetRoute);
        showTooltip(targetRoute, window.innerWidth / 2, window.innerHeight / 2, { pin: true });
      }

      function closeTutorialRouteTooltip() {
        if (tutorialHighlightedRouteId) {
          const targetRoute =
            (Array.isArray(routes) ? routes : []).find((route) => route?.id === tutorialHighlightedRouteId) ||
            (Array.isArray(allRoutes) ? allRoutes : []).find((route) => route?.id === tutorialHighlightedRouteId);

          if (targetRoute) {
            setRouteFocus(targetRoute, false);
          } else if (focusedRouteId === tutorialHighlightedRouteId) {
            focusedRouteId = null;
            updateClearFocusButton();
            redraw();
          }
        }

        tutorialHighlightedRouteId = null;
        hideTooltip({ force: true });
      }

      function setTutorialOverlayAlignment(alignment = 'center') {
        if (!tutorialOverlay) {
          return;
        }

        const shouldAlignBottom = alignment === 'bottom';
        tutorialOverlay.classList.toggle('is-bottom-aligned', shouldAlignBottom);
      }

      function startTutorialRoutePulse() {
        if (!canvas) {
          return;
        }

        canvas.classList.add('tutorial-route-pulse');
      }

      function stopTutorialRoutePulse() {
        if (!canvas) {
          return;
        }

        canvas.classList.remove('tutorial-route-pulse');
      }



      function buildTutorialSteps() {
        const steps = [
          {
            title: 'Welcome to Ascend',
            body: [
              'Ascend helps you explore the latest problems on the wall and stay up to date with the gym.',
              'Use this public view to browse climbs and see what sets are available right now.',
            ],
            onEnter: () => {
              setTutorialOverlayAlignment('center');
              highlightTutorialElement(null);
              hideTooltip({ force: true });
              hideTutorialPointer();
            },
            onExit: () => {
              highlightTutorialElement(null);
            },
          },
        ];

        if (isMobileDevice()) {
          steps.push(
            {
              title: 'Landscape shows everything',
              body: [
                () => createMobileOrientationIllustration('landscape'),
                'On mobile, rotate your phone to landscape when you want the full wall in view.',
                'The wider layout gives you a complete snapshot of every climb at once.',
              ],
              onEnter: () => {
                setTutorialOverlayAlignment('center');
                highlightTutorialElement(null);
                hideTooltip({ force: true });
                hideTutorialPointer();
              },
              onExit: () => {
                highlightTutorialElement(null);
              },
            },
            {
              title: 'Portrait lets you pan',
              body: [
                () => createMobileOrientationIllustration('portrait'),
                'On mobile, stay in portrait when you prefer to pan horizontally across the wall.',
                'Swipe side to side to focus on specific sections while keeping controls close by.',
              ],
              onEnter: () => {
                setTutorialOverlayAlignment('center');
                highlightTutorialElement(null);
                hideTooltip({ force: true });
                hideTutorialPointer();
              },
              onExit: () => {
                highlightTutorialElement(null);
              },
            }
          );
        }

        steps.push(
          {
            title: 'Route details',
            body: [
              'Click any climb to open its tooltip for more information.',
              "You'll see the setter, description, and consensus grade gathered from other climbers.",
            ],
            onEnter: async () => {
              setTutorialOverlayAlignment('bottom');
              highlightTutorialElement(null);
              await showTutorialRouteTooltip();
            },
            onExit: () => {
              hideTutorialPointer();
              stopTutorialRoutePulse();
              closeTutorialRouteTooltip();
              setTutorialOverlayAlignment('center');
            },
          },
            {
              title: 'Coloring by Holds',
              body: [
                "Routes are showing the colour of each hold set right now so you can match what's taped on the wall.",
                'Click the palette icon to switch to Coloring by Grade when you want quick difficulty cues.',
              ],
              onEnter: () => {
                setTutorialOverlayAlignment('center');
                const holdButton = getViewToggleButtonForMode(VIEW_MODE_HOLD_COLORS);
                if (holdButton) {
                  tutorialPreviousViewMode = viewMode;
                  if (viewMode !== VIEW_MODE_HOLD_COLORS) {
                    setViewMode(VIEW_MODE_HOLD_COLORS);
                  }
                  highlightTutorialElement(holdButton, { illuminate: true });
                  showTutorialPointerFor(holdButton);
                } else {
                  hideTutorialPointer();
                }
              },
              onExit: () => {
                hideTutorialPointer();
                highlightTutorialElement(null);
                if (tutorialPreviousViewMode && tutorialPreviousViewMode !== viewMode) {
                  setViewMode(tutorialPreviousViewMode);
                }
                tutorialPreviousViewMode = null;
              },
          },
          {
            title: 'Coloring by Grade',
            body: [
              'Toggle Coloring by Grade to tint each climb by consensus difficulty.',
              'Climbs without a recorded grade stay bright white until someone logs one.',
              'Tap the same palette icon any time to jump back to Coloring by Holds.',
              () => createGradeChartElement(),
              "It's perfect when you want to scan the wall by difficulty at a glance.",
            ],
            onEnter: () => {
              setTutorialOverlayAlignment('center');
              const gradeButton = getViewToggleButtonForMode(VIEW_MODE_GRADE_COLORS);
              if (gradeButton) {
                tutorialPreviousViewMode = viewMode;
                if (viewMode !== VIEW_MODE_GRADE_COLORS) {
                  setViewMode(VIEW_MODE_GRADE_COLORS);
                }
                highlightTutorialElement(gradeButton, { illuminate: true });
                showTutorialPointerFor(gradeButton);
              } else {
                hideTutorialPointer();
              }
            },
            onExit: () => {
              hideTutorialPointer();
              highlightTutorialElement(null);
              if (tutorialPreviousViewMode && tutorialPreviousViewMode !== viewMode) {
                setViewMode(tutorialPreviousViewMode);
              }
              tutorialPreviousViewMode = null;
            },
          },
          {
            title: 'Choose a wall',
            body: [
              'Use the wall selector to jump between different locations in the gym.',
              'Each wall has its own background and set of climbs to explore.',
            ],
            onEnter: () => {
              setTutorialOverlayAlignment('bottom');
              if (locationModal) {
                locationModal.classList.add('is-top-aligned');
              }
              if (locationButton) {
                highlightTutorialElement(locationButton, { illuminate: true });
                showTutorialPointerFor(locationButton);
                openLocationModal();
                updateTutorialPointerPosition();
              } else {
                hideTutorialPointer();
              }
            },
            onExit: () => {
              hideTutorialPointer();
              highlightTutorialElement(null);
              if (locationModal) {
                locationModal.classList.remove('is-top-aligned');
              }
              closeLocationModal();
              setTutorialOverlayAlignment('center');
            },
          },
          {
            title: 'Sign in to track progress',
            body: [
              'The Log in button takes you to the personal dashboard where you can create an account or sign in.',
              "Members can record ascents and personal grades once they're logged in.",
            ],
            onEnter: () => {
              setTutorialOverlayAlignment('center');
              if (loginButton) {
                highlightTutorialElement(loginButton, { illuminate: true });
                showTutorialPointerFor(loginButton);
              } else {
                hideTutorialPointer();
              }
            },
            onExit: () => {
              hideTutorialPointer();
              highlightTutorialElement(null);
            },
          },
          {
            title: 'Need more info later?',
            body: [
              'Tap the info button to activate quick explanations for the controls around the screen.',
              "It's a handy refresher whenever you want to revisit what each tool does.",
            ],
            onEnter: () => {
              setTutorialOverlayAlignment('center');
              if (infoButton) {
                highlightTutorialElement(infoButton, { illuminate: true });
                showTutorialPointerFor(infoButton);
              } else {
                hideTutorialPointer();
              }
            },
            onExit: () => {
              hideTutorialPointer();
              highlightTutorialElement(null);
            },
          }
        );

        return steps;
      }

      const tutorialSteps = buildTutorialSteps();



      function renderTutorialStep() {
        if (!tutorialActive) {
          return;
        }

        const step = tutorialSteps[tutorialStepIndex];
        if (!step) {
          return;
        }

        if (tutorialTitle) {
          tutorialTitle.textContent = step.title || '';
        }

        setTutorialDescriptionContent(step.body || []);

        if (tutorialProgress) {
          tutorialProgress.textContent = `Step ${tutorialStepIndex + 1} of ${tutorialSteps.length}`;
          tutorialProgress.classList.toggle('hidden', tutorialSteps.length === 0);
        }

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.textContent =
            tutorialStepIndex === tutorialSteps.length - 1 ? 'Finish' : 'Next';
        }

        if (tutorialSecondaryAction) {
          tutorialSecondaryAction.textContent = 'Back';
          tutorialSecondaryAction.classList.toggle('hidden', tutorialStepIndex <= 0);
        }
      }

      async function goToTutorialStep(index) {
        if (!tutorialActive || tutorialTransitionInProgress) {
          return;
        }

        if (index < 0 || index >= tutorialSteps.length) {
          return;
        }

        tutorialTransitionInProgress = true;

        if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
          const currentStep = tutorialSteps[tutorialStepIndex];
          if (currentStep && typeof currentStep.onExit === 'function') {
            try {
              await currentStep.onExit();
            } catch (error) {
              console.warn('Tutorial step cleanup failed:', error);
            }
          }
        }

        tutorialStepIndex = index;
        tutorialOverlayMode = 'step';
        renderTutorialStep();

        const nextStep = tutorialSteps[tutorialStepIndex];
        if (nextStep && typeof nextStep.onEnter === 'function') {
          try {
            await nextStep.onEnter();
          } catch (error) {
            console.warn('Tutorial step setup failed:', error);
          }
        }

        tutorialTransitionInProgress = false;

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.focus();
        }
      }

      function renderTutorialInvite() {
        tutorialOverlayMode = 'invite';
        tutorialInviteOpen = true;
        tutorialActive = false;

        if (tutorialProgress) {
          tutorialProgress.classList.add('hidden');
        }

        highlightTutorialElement(null);
        stopTutorialRoutePulse();
        hideTutorialPointer();
        setTutorialOverlayAlignment('center');
        closeTutorialRouteTooltip();

        if (tutorialTitle) {
          tutorialTitle.textContent = 'Take a tour?';
        }

        setTutorialDescriptionContent([
          'Would you like a quick guided tour of the main controls before you dive in?',
          'If you\'d rather explore on your own, you can close this dialog at any time.',
        ]);

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.textContent = 'Start tutorial';
        }

        if (tutorialSecondaryAction) {
          tutorialSecondaryAction.textContent = 'Skip';
          tutorialSecondaryAction.classList.remove('hidden');
        }
      }

      async function startTutorial() {
        if (tutorialActive) {
          return;
        }

        tutorialInviteOpen = false;
        tutorialOverlayMode = 'step';
        tutorialActive = true;
        tutorialStepIndex = -1;
        tutorialTransitionInProgress = false;

        if (tutorialProgress) {
          tutorialProgress.classList.remove('hidden');
        }

        stopTutorialRoutePulse();
        setTutorialOverlayAlignment('center');

        disableInteractiveElementsForTutorial();

        await goToTutorialStep(0);
      }

      async function finishTutorial() {
        if (!tutorialActive) {
          return;
        }

        tutorialTransitionInProgress = true;

        if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
          const finalStep = tutorialSteps[tutorialStepIndex];
          if (finalStep && typeof finalStep.onExit === 'function') {
            try {
              await finalStep.onExit();
            } catch (error) {
              console.warn('Tutorial completion cleanup failed:', error);
            }
          }
        }

        tutorialActive = false;
        tutorialInviteOpen = false;
        tutorialOverlayMode = 'hidden';
        tutorialStepIndex = -1;
        tutorialTransitionInProgress = false;

        highlightTutorialElement(null);
        closeTutorialRouteTooltip();
        stopTutorialRoutePulse();
        hideTutorialPointer();
        setTutorialOverlayAlignment('center');
        restoreInteractiveElementsAfterTutorial();

        if (tutorialProgress) {
          tutorialProgress.classList.add('hidden');
        }

        closeTutorialOverlay();
      }

      function declineTutorial() {
        tutorialInviteOpen = false;
        tutorialOverlayMode = 'hidden';
        highlightTutorialElement(null);
        closeTutorialRouteTooltip();
        stopTutorialRoutePulse();
        hideTutorialPointer();
        setTutorialOverlayAlignment('center');
        closeTutorialOverlay();
      }

      async function handleTutorialPrimaryAction() {
        if (tutorialOverlayMode === 'invite') {
          await startTutorial();
          return;
        }

        if (tutorialOverlayMode === 'step') {
          if (tutorialTransitionInProgress) {
            return;
          }

          if (tutorialStepIndex >= tutorialSteps.length - 1) {
            await finishTutorial();
          } else {
            await goToTutorialStep(tutorialStepIndex + 1);
          }
        }
      }

      async function handleTutorialSecondaryAction() {
        if (tutorialOverlayMode === 'invite') {
          declineTutorial();
          return;
        }

        if (tutorialOverlayMode === 'step') {
          if (tutorialTransitionInProgress || tutorialStepIndex <= 0) {
            return;
          }

          await goToTutorialStep(tutorialStepIndex - 1);
        }
      }

      function setupTutorialInteractions() {
        renderTutorialInvite();
        openTutorialOverlay();

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.addEventListener('click', () => {
            void handleTutorialPrimaryAction();
          });
        }

        if (tutorialSecondaryAction) {
          tutorialSecondaryAction.addEventListener('click', () => {
            void handleTutorialSecondaryAction();
          });
        }

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.focus();
        }
      }

      onAuthStateChanged(auth, async (user) => {
        if (user && !user.isAnonymous) {
          if (authOverlay) {
            authOverlay.classList.add('hidden');
            authOverlay.setAttribute('aria-hidden', 'true');
          }

          currentUser = user;

          const resolvedUsername = await resolveUsernameForUser(user);
          if (!isValidUsername(resolvedUsername)) {
            authError.textContent =
              'Unable to resolve your username. Please contact a setter for assistance.';
            await signOut(auth);
            return;
          }

          currentUsername = normalizeUsername(resolvedUsername);
          authenticatedUsernameClaim = '';
          const canonicalUsername = await resolveAuthenticatedUsername();
          if (isValidUsername(canonicalUsername)) {
            currentUsername = canonicalUsername;
          }

          await ensureUidUsernameMapping(user, currentUsername);

          const role = await resolveUserRole(user, currentUsername);

          updateNavigationForRole(role);
          appContent.classList.remove('hidden');

          await loadRoutes();
          await loadAscents({ uid: currentUser?.uid || '' });

          return;
        }

        await presentGuestExperience();
      });

      setAuthMode('login');

      const canvasContainer = document.querySelector('.canvas-container');
      const canvas = document.getElementById('previewCanvas');
      const clearFocusButton = document.getElementById('clearFocusButton');
      const ctx = canvas.getContext('2d');

      syncViewModeState();
      updateViewToggleButtons();
      if (clearFocusButton) {
        clearFocusButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          clearRouteFocus();
        });
      }

      const DEFAULT_CANVAS_ASPECT_RATIO = 1536 / 1024;
      let canvasAspectRatio = DEFAULT_CANVAS_ASPECT_RATIO;
      let isHorizontalScrollEnabled = false;

      let allRoutes = [];
      let routes = [];
      let focusedRouteId = null;
      let routeInteractionEntries = [];
      let activeRouteId = null;
      let pinnedRouteId = null;
      let pinnedPosition = null;
      const ascendedRoutes = new Set();
      const routeScoresCache = new Map();
      const routeBetatipsCache = new Map();
      const uidUsernameCache = new Map();
      let userAscentDetails = new Map();
      const normalizeRouteUidValue = (value) =>
        typeof value === 'string' && value.trim() ? value.trim() : '';
      const getRouteId = (route) => {
        if (!route) {
          return '';
        }
        return normalizeRouteUidValue(route.uid) || normalizeRouteUidValue(route.id);
      };
      const CLICK_DRAG_DISTANCE_THRESHOLD = 8;
      const CLICK_DRAG_DISTANCE_THRESHOLD_SQUARED =
        CLICK_DRAG_DISTANCE_THRESHOLD * CLICK_DRAG_DISTANCE_THRESHOLD;
      let activePointerInteraction = null;
      let progressionPreviouslyFocusedElement = null;

      const DOUBLE_FOCUS_TIME_THRESHOLD = 350;
      const DOUBLE_FOCUS_DISTANCE_THRESHOLD = 32;
      let lastFocusActivation = {
        time: 0,
        routeId: null,
        pointerType: '',
        x: 0,
        y: 0,
      };

      updateClearFocusButton();

      function resetLastFocusActivation() {
        lastFocusActivation = {
          time: 0,
          routeId: null,
          pointerType: '',
          x: 0,
          y: 0,
        };
      }

      function resolvePointerType(event) {
        if (!event) {
          return '';
        }

        if (typeof event.pointerType === 'string') {
          return event.pointerType;
        }

        if (typeof event.type === 'string') {
          if (event.type.startsWith('mouse')) {
            return 'mouse';
          }
          if (event.type.startsWith('touch')) {
            return 'touch';
          }
          if (event.type.startsWith('pen')) {
            return 'pen';
          }
        }

        return '';
      }

      function shouldFocusFromInteraction(event, entry) {
        if (!entry || !entry.route || typeof entry.route.id !== 'string') {
          resetLastFocusActivation();
          return false;
        }

        const pointerType = resolvePointerType(event);
        const now = typeof event?.timeStamp === 'number' ? event.timeStamp : Date.now();
        const clickCount = typeof event?.detail === 'number' ? event.detail : 0;
        let isDoubleActivation = clickCount >= 2;

        if (!isDoubleActivation && lastFocusActivation.routeId) {
          const elapsed = now - lastFocusActivation.time;
          if (elapsed <= DOUBLE_FOCUS_TIME_THRESHOLD) {
            const pointerMatches =
              !pointerType || !lastFocusActivation.pointerType
                ? true
                : pointerType === lastFocusActivation.pointerType;
            if (pointerMatches && entry.route.id === lastFocusActivation.routeId) {
              const dx = (entry.canvasX ?? 0) - (lastFocusActivation.x ?? 0);
              const dy = (entry.canvasY ?? 0) - (lastFocusActivation.y ?? 0);
              const distanceSquared = dx * dx + dy * dy;
              if (distanceSquared <= DOUBLE_FOCUS_DISTANCE_THRESHOLD * DOUBLE_FOCUS_DISTANCE_THRESHOLD) {
                isDoubleActivation = true;
              }
            }
          }
        }

        lastFocusActivation = {
          time: now,
          routeId: entry.route.id,
          pointerType,
          x: entry.canvasX ?? 0,
          y: entry.canvasY ?? 0,
        };

        return isDoubleActivation;
      }

      function synchroniseAscentsWithRoutes(options = {}) {
        const { shouldRedraw = true } = options;
        ascendedRoutes.clear();

        if (!Array.isArray(routes) || routes.length === 0) {
          renderProgressionList();
          if (shouldRedraw) {
            redraw();
          }
          return;
        }

        routes.forEach((route) => {
          const routeId = getRouteId(route);
          if (!routeId) {
            return;
          }

          const ascent = userAscentDetails.get(routeId);
          if (ascent?.ascended) {
            ascendedRoutes.add(routeId);
          }
        });

        renderProgressionList();

        if (shouldRedraw) {
          redraw();
        }
      }

      async function loadAscents({ uid }) {
        ascendedRoutes.clear();
        userAscentDetails = new Map();

        const normalizedUid = typeof uid === 'string' ? uid.trim() : '';
        if (!normalizedUid) {
          synchroniseAscentsWithRoutes();
          return;
        }

        routeScoresCache.forEach((scoresMap, routeId) => {
          if (!(scoresMap instanceof Map)) {
            return;
          }

          const entry = scoresMap.get(normalizedUid);
          if (!entry) {
            return;
          }

          const gradeValue = normalizeGradeValue(entry.grade);
          const ascended = entry.ascended === true;

          const ascentDetails = {
            ascended,
            grade: gradeValue,
          };

          userAscentDetails.set(routeId, ascentDetails);

          if (ascended) {
            ascendedRoutes.add(routeId);
          }
        });

        synchroniseAscentsWithRoutes();
      }

      function normalizeDate(value) {
        if (!value) {
          return null;
        }

        if (typeof value === 'string') {
          const date = new Date(value);
          return Number.isNaN(date.getTime()) ? null : date.toISOString();
        }

        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }

        if (typeof value?.toDate === 'function') {
          const date = value.toDate();
          if (date instanceof Date && !Number.isNaN(date.getTime())) {
            return date.toISOString();
          }
          return null;
        }

        return null;
      }

      function formatDisplayDate(isoString) {
        if (!isoString) {
          return 'Unknown';
        }

        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return 'Unknown';
        }

        return date.toLocaleDateString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
        });
      }

      function normalizeGradeValue(value) {
        if (value === null || value === undefined) {
          return null;
        }

        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return null;
        }

        if (!Number.isInteger(numeric)) {
          return null;
        }

        if (numeric < MIN_GRADE_VALUE || numeric > MAX_GRADE_VALUE) {
          return null;
        }

        return numeric;
      }

      function normalizeRouteGradeField(value) {
        if (typeof value === 'string') {
          const trimmed = value.trim();
          return trimmed || null;
        }

        if (typeof value === 'number' && Number.isFinite(value)) {
          return value;
        }

        return null;
      }

      function normalizeUpvoteList(value) {
        const normalized = new Set();

        const addCandidate = (candidate) => {
          if (typeof candidate !== 'string') {
            return;
          }
          const normalizedName = normalizeUsername(candidate);
          if (normalizedName) {
            normalized.add(normalizedName);
          }
        };

        if (value instanceof Set) {
          value.forEach(addCandidate);
        } else if (Array.isArray(value)) {
          value.forEach(addCandidate);
        } else if (value && typeof value === 'object') {
          Object.values(value).forEach(addCandidate);
        } else {
          addCandidate(value);
        }

        return normalized;
      }

      function normalizeBetatipCacheValue(value, fallbackKey = '') {
        const fallback = typeof fallbackKey === 'string' ? fallbackKey.trim() : '';

        if (!value) {
          return {
            betatipId: fallback,
            userId: fallback,
            username: '',
            text: '',
            upvoters: new Set(),
            upvoteCount: 0,
          };
        }

        if (typeof value === 'string') {
          const text = value.replace(/\r\n/g, '\n').trim();
          return {
            betatipId: fallback,
            userId: fallback,
            username: '',
            text,
            upvoters: new Set(),
            upvoteCount: 0,
          };
        }

        if (typeof value === 'object') {
          const rawText =
            typeof value.betatip === 'string'
              ? value.betatip
              : typeof value.text === 'string'
              ? value.text
              : '';
          const text = rawText.replace(/\r\n/g, '\n').trim();
          const upvoteSource =
            value.upvoters instanceof Set || Array.isArray(value.upvoters)
              ? value.upvoters
              : value.betatipUpvotes ?? value.betatipupvotes;
          const upvoters = normalizeUpvoteList(upvoteSource);
          const normalizedUsername = isValidUsername(value.username)
            ? normalizeUsername(value.username)
            : '';
          const userId =
            typeof value.userId === 'string' && value.userId.trim()
              ? value.userId.trim()
              : fallback;
          const betatipId =
            typeof value.betatipId === 'string' && value.betatipId.trim()
              ? value.betatipId.trim()
              : fallback;
          const recordedCount =
            typeof value.upvoteCount === 'number' && Number.isFinite(value.upvoteCount)
              ? value.upvoteCount
              : upvoters.size;

          return {
            betatipId,
            userId,
            username: normalizedUsername,
            text,
            upvoters,
            upvoteCount: recordedCount,
          };
        }

        return {
          betatipId: fallback,
          userId: fallback,
          username: '',
          text: '',
          upvoters: new Set(),
          upvoteCount: 0,
        };
      }

      function sanitizeNormalizedPoint(point) {
        const x = Number(point?.x);
        const y = Number(point?.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          return null;
        }
        return { x, y };
      }

      function sanitizeNormalizedPointsArray(rawPoints) {
        if (!Array.isArray(rawPoints)) {
          return [];
        }

        return rawPoints.map(sanitizeNormalizedPoint).filter(Boolean);
      }

      function collectCandidatePoints(value) {
        if (Array.isArray(value)) {
          return value;
        }

        if (value instanceof Map) {
          return Array.from(value.values());
        }

        if (value && typeof value === 'object') {
          return Object.values(value);
        }

        return [];
      }

      function normalizeRoutePointsByType(rawPoints, fallbackPathType) {
        const normalized = {};
        const fallbackType = normalizePathType(fallbackPathType) || DEFAULT_PATH_TYPE;

        const assignPoints = (pathTypeKey, value) => {
          const normalizedType = normalizePathType(pathTypeKey);
          if (!normalizedType || normalized[normalizedType]) {
            return;
          }

          normalized[normalizedType] = sanitizeNormalizedPointsArray(collectCandidatePoints(value));
        };

        if (rawPoints instanceof Map) {
          rawPoints.forEach((value, key) => assignPoints(key, value));
        } else if (rawPoints && typeof rawPoints === 'object' && !Array.isArray(rawPoints)) {
          Object.entries(rawPoints).forEach(([key, value]) => assignPoints(key, value));
        } else if (Array.isArray(rawPoints)) {
          assignPoints(fallbackType, rawPoints);
        }

        if (!Object.prototype.hasOwnProperty.call(normalized, fallbackType)) {
          normalized[fallbackType] = [];
        }

        return normalized;
      }

      function getRoutePointEntries(route) {
        const entries = [];
        if (!route) {
          return entries;
        }

        const seenTypes = new Set();
        const appendEntry = (pathTypeKey, pointsValue) => {
          const normalizedType = normalizePathType(pathTypeKey);
          if (!normalizedType || seenTypes.has(normalizedType)) {
            return;
          }

          const pointsArray = sanitizeNormalizedPointsArray(collectCandidatePoints(pointsValue));

          seenTypes.add(normalizedType);
          entries.push({
            pathType: normalizedType,
            points: pointsArray,
          });
        };

        const { pointsByType } = route;
        if (pointsByType instanceof Map) {
          pointsByType.forEach((value, key) => appendEntry(key, value));
        } else if (pointsByType && typeof pointsByType === 'object' && !Array.isArray(pointsByType)) {
          Object.entries(pointsByType).forEach(([key, value]) => appendEntry(key, value));
        }

        if (!entries.length) {
          const fallbackPoints = Array.isArray(route.points) ? route.points : [];
          appendEntry(route.pathType, fallbackPoints);
        }

        return entries.filter((entry) => Array.isArray(entry.points) && entry.points.length);
      }

      function selectNormalizedPointsForPath(rawPoints, pathType) {
        const normalizedType = normalizePathType(pathType) || PATH_TYPE_BREZER;

        const extractPoints = (value) => {
          if (!Array.isArray(value)) {
            return [];
          }
          return value.map(sanitizeNormalizedPoint).filter(Boolean);
        };

        if (rawPoints instanceof Map) {
          const points = rawPoints.get(normalizedType);
          if (points) {
            return extractPoints(points);
          }

          for (const [key, value] of rawPoints.entries()) {
            if (Array.isArray(value)) {
              const candidate = extractPoints(value);
              if (candidate.length) {
                return candidate;
              }
            }
          }
          return [];
        }

        if (rawPoints && typeof rawPoints === 'object' && !Array.isArray(rawPoints)) {
          const activePoints = extractPoints(rawPoints[normalizedType]);
          if (activePoints.length || Array.isArray(rawPoints[normalizedType])) {
            return activePoints;
          }

          const fallbackTypes = [
            PATH_TYPE_BREZER,
            PATH_TYPE_HOLLOW_POINT,
            PATH_TYPE_FILLED_POINT,
            PATH_TYPE_RECTANGLE,
          ];

          for (const type of fallbackTypes) {
            if (type === normalizedType) {
              continue;
            }
            const candidate = extractPoints(rawPoints[type]);
            if (candidate.length) {
              return candidate;
            }
          }

          return [];
        }

        if (Array.isArray(rawPoints)) {
          return extractPoints(rawPoints);
        }

        return [];
      }

      function getRouteScoresMap(routeId) {
        if (typeof routeId !== 'string' || !routeId.trim()) {
          return new Map();
        }

        const normalizedId = routeId.trim();
        let map = routeScoresCache.get(normalizedId);
        if (!(map instanceof Map)) {
          map = new Map();
          routeScoresCache.set(normalizedId, map);
        }

        return map;
      }

      function getRouteBetatipsMap(routeId) {
        if (typeof routeId !== 'string' || !routeId.trim()) {
          return new Map();
        }

        const normalizedId = routeId.trim();
        let map = routeBetatipsCache.get(normalizedId);
        if (!(map instanceof Map)) {
          map = new Map();
          routeBetatipsCache.set(normalizedId, map);
        }

        return map;
      }

      function normalizeRouteScoreEntry(details) {
        const grade = normalizeGradeValue(details?.grade);
        const ascended = details?.ascended === true;

        return {
          grade,
          ascended,
        };
      }

      function extractNumericGradesFromScoresMap(scoresMap) {
        const grades = [];

        if (!(scoresMap instanceof Map)) {
          return grades;
        }

        scoresMap.forEach((value) => {
          const gradeValue = normalizeGradeValue(value?.grade);
          if (typeof gradeValue === 'number' && Number.isFinite(gradeValue)) {
            grades.push(gradeValue);
          }
        });

        return grades;
      }

      function computeMedianGrade(grades) {
        if (!Array.isArray(grades) || grades.length === 0) {
          return null;
        }

        const sorted = grades.slice().sort((a, b) => a - b);
        const midpoint = Math.floor(sorted.length / 2);

        if (sorted.length % 2 === 1) {
          return sorted[midpoint];
        }

        return (sorted[midpoint - 1] + sorted[midpoint]) / 2;
      }

      function computeMedianGradeForRoute(routeId) {
        if (!routeId) {
          return null;
        }

        const scoresMap = routeScoresCache.get(routeId);
        const grades = extractNumericGradesFromScoresMap(scoresMap);
        return computeMedianGrade(grades);
      }

      async function hydrateRouteScores(routeDescriptors = []) {
        if (!Array.isArray(routeDescriptors) || routeDescriptors.length === 0) {
          return;
        }

        const fetchPromises = routeDescriptors.map(({ docSnap, routeUid }) => {
          if (!docSnap || !routeUid) {
            return Promise.resolve();
          }

          const scoresRef = collection(docSnap.ref, 'scores');
          const scoresMap = getRouteScoresMap(routeUid);

          if (scoresMap instanceof Map && typeof scoresMap.clear === 'function') {
            scoresMap.clear();
          }

          return getDocs(scoresRef).then((scoresSnapshot) => {
            scoresSnapshot.forEach((scoreDoc) => {
              const userUid = typeof scoreDoc.id === 'string' ? scoreDoc.id.trim() : '';

              if (!userUid) {
                return;
              }

              const normalizedEntry = normalizeRouteScoreEntry(scoreDoc.data() || {});
              scoresMap.set(userUid, normalizedEntry);
            });
          });
        });

        const results = await Promise.allSettled(fetchPromises);
        results.forEach((result, index) => {
          if (result.status === 'rejected') {
            const descriptor = routeDescriptors[index];
            const identifier =
              (typeof descriptor?.routeUid === 'string' && descriptor.routeUid.trim()) ||
              (typeof descriptor?.docSnap?.id === 'string' && descriptor.docSnap.id.trim()) ||
              '(unknown route)';
            console.error(`Failed to load scores for route ${identifier}:`, result.reason);
          }
        });
      }

      async function loadBetatipUpvotes(betatipId) {
        if (typeof betatipId !== 'string' || !betatipId.trim()) {
          return new Set();
        }

        try {
          const snapshot = await getDocs(
            collection(db, 'routes_users_betatips', betatipId.trim(), 'upvotes'),
          );

          const upvoters = new Set();
          snapshot.forEach((docSnap) => {
            if (typeof docSnap.id === 'string' && docSnap.id.trim()) {
              upvoters.add(docSnap.id.trim());
            }
          });

          return upvoters;
        } catch (error) {
          console.error('Failed to load betatip upvotes:', error);
          return new Set();
        }
      }

      function formatGradeDisplay(value) {
        if (typeof value === 'string') {
          const trimmed = value.trim();
          return trimmed || '—';
        }

        if (typeof value !== 'number' || !Number.isFinite(value)) {
          return '—';
        }

        return Number.isInteger(value) ? String(value) : value.toFixed(1);
      }

      function resolveTooltipGradeValue(route) {
        if (!route) {
          return null;
        }

        const routeId = getRouteId(route);
        const medianGrade = computeMedianGradeForRoute(routeId);
        return typeof medianGrade === 'number' && Number.isFinite(medianGrade)
          ? medianGrade
          : null;
      }

      function resolveProgressionGradeValue(route) {
        if (!route) {
          return null;
        }

        const routeId = getRouteId(route);
        const medianGrade = computeMedianGradeForRoute(routeId);
        return typeof medianGrade === 'number' && Number.isFinite(medianGrade)
          ? medianGrade
          : null;
      }

      function renderProgressionList() {
        if (!progressionList) {
          return;
        }

        progressionList.innerHTML = '';

        const desiredLocation = normalizeLocationName(currentLocation?.name);
        const fallbackLocation = normalizeLocationName(getDefaultLocation()?.name);
        const targetLocation = desiredLocation || fallbackLocation || null;

        const relevantRoutes = Array.isArray(routes)
          ? routes.filter((route) => {
              if (!route) {
                return false;
              }

              if (!targetLocation) {
                return true;
              }

              const routeLocationKey =
                typeof route.locationKey === 'string' && route.locationKey
                  ? route.locationKey
                  : normalizeLocationName(route.location);

              return routeLocationKey === targetLocation;
            })
          : [];

        if (!relevantRoutes.length) {
          const emptyMessage = document.createElement('p');
          emptyMessage.className = 'progression-empty-message';
          emptyMessage.textContent = 'No routes available for this wall yet.';
          progressionList.appendChild(emptyMessage);
          return;
        }

        const sorted = relevantRoutes.slice().sort((routeA, routeB) => {
          const gradeA = resolveProgressionGradeValue(routeA);
          const gradeB = resolveProgressionGradeValue(routeB);

          const numberA =
            typeof gradeA === 'number' && Number.isFinite(gradeA) ? gradeA : null;
          const numberB =
            typeof gradeB === 'number' && Number.isFinite(gradeB) ? gradeB : null;

          if (numberA !== null || numberB !== null) {
            if (numberA === null) {
              return 1;
            }

            if (numberB === null) {
              return -1;
            }

            if (numberA !== numberB) {
              return numberA - numberB;
            }
          }

          const stringA = typeof gradeA === 'string' && gradeA ? gradeA : null;
          const stringB = typeof gradeB === 'string' && gradeB ? gradeB : null;

          if (stringA || stringB) {
            if (!stringA) {
              return 1;
            }

            if (!stringB) {
              return -1;
            }

            const compare = stringA.localeCompare(stringB, undefined, { sensitivity: 'base' });
            if (compare !== 0) {
              return compare;
            }
          }

          const nameA = (routeA.title || routeA.id || '').toLowerCase();
          const nameB = (routeB.title || routeB.id || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });

        sorted.forEach((route) => {
          if (!route) {
            return;
          }

          const listItem = document.createElement('div');
          listItem.className = 'progression-entry';
          listItem.setAttribute('role', 'listitem');
          listItem.setAttribute('tabindex', '0');

          const routeId = getRouteId(route);
          if (routeId) {
            listItem.dataset.routeId = routeId;
          }

          const isFocused = routeId && routeId === focusedRouteId;
          if (isFocused) {
            listItem.classList.add('is-focused');
            listItem.setAttribute('aria-current', 'true');
          }

          const grade = document.createElement('span');
          grade.className = 'progression-entry-grade';
          const gradeValue = resolveProgressionGradeValue(route);
          grade.textContent = formatGradeDisplay(gradeValue);

          const gradeColor = getRouteGradeColor(route);
          if (gradeColor) {
            grade.style.color = gradeColor;
          }

          listItem.appendChild(grade);

          const details = document.createElement('div');
          const title = document.createElement('span');
          title.className = 'progression-entry-name';
          title.textContent = route.title || routeId || 'Untitled route';

          if (gradeColor) {
            title.style.color = gradeColor;
          }

          details.appendChild(title);
          listItem.appendChild(details);

          const status = document.createElement('span');
          status.className = 'progression-entry-status';
          const isAscended = Boolean(routeId && ascendedRoutes.has(routeId));

          if (isAscended) {
            status.textContent = '✓';
            status.classList.add('is-ascended');
            status.setAttribute('aria-label', 'Ascended');
            status.setAttribute('title', 'Ascended');
          } else {
            status.textContent = '';
            status.setAttribute('aria-hidden', 'true');
          }

          listItem.appendChild(status);

          listItem.addEventListener('click', (event) => {
            event.preventDefault();
            focusRoute(route);
          });

          listItem.addEventListener('keydown', (event) => {
            const { key } = event;
            if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
              event.preventDefault();
              focusRoute(route);
            }
          });

          progressionList.appendChild(listItem);
        });
      }

      function isProgressionModalOpen() {
        if (!progressionModal) {
          return false;
        }

        return !progressionModal.classList.contains('hidden');
      }

      function closeProgressionModal() {
        if (!progressionModal) {
          return;
        }

        progressionModal.classList.add('hidden');
        progressionModal.setAttribute('aria-hidden', 'true');

        if (progressionButton) {
          progressionButton.setAttribute('aria-expanded', 'false');
        }

        document.removeEventListener('keydown', handleProgressionKeydown, true);

        if (progressionPreviouslyFocusedElement && typeof progressionPreviouslyFocusedElement.focus === 'function') {
          progressionPreviouslyFocusedElement.focus();
        }
        progressionPreviouslyFocusedElement = null;
      }

      function handleProgressionKeydown(event) {
        if (event.key === 'Escape' && isProgressionModalOpen()) {
          event.preventDefault();
          closeProgressionModal();
        }
      }

      function openProgressionModal() {
        if (!progressionModal) {
          return;
        }

        renderProgressionList();

        progressionPreviouslyFocusedElement =
          document.activeElement instanceof HTMLElement ? document.activeElement : null;

        progressionModal.classList.remove('hidden');
        progressionModal.setAttribute('aria-hidden', 'false');

        if (progressionButton) {
          progressionButton.setAttribute('aria-expanded', 'true');
        }

        document.addEventListener('keydown', handleProgressionKeydown, true);

        const focusTarget =
          progressionModalClose && typeof progressionModalClose.focus === 'function'
            ? progressionModalClose
            : progressionModal;
        focusTarget.focus();
      }

      function getUserGradeForRoute(routeId) {
        if (!routeId) {
          return null;
        }

        const ascent = userAscentDetails.get(routeId);
        const grade = ascent?.grade;
        return typeof grade === 'number' && Number.isFinite(grade) ? grade : null;
      }

      function createTooltipCloseButton() {
        const closeButton = document.createElement('button');
        closeButton.type = 'button';
        closeButton.className = 'tooltip-close-button';
        closeButton.setAttribute('aria-label', 'Close route details');
        closeButton.setAttribute('title', 'Close route details');
        closeButton.innerHTML = `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M6.34 6.34a1 1 0 0 1 1.32-.08l.1.08L12 10.59l4.24-4.25a1 1 0 0 1 1.5 1.32l-.08.1L13.41 12l4.25 4.24a1 1 0 0 1-1.32 1.5l-.1-.08L12 13.41l-4.24 4.25a1 1 0 0 1-1.5-1.32l.08-.1L10.59 12 6.34 7.76a1 1 0 0 1 0-1.42Z"
              fill="currentColor"
            />
          </svg>
        `;
        closeButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          hideTooltip({ force: true });
        });
        return closeButton;
      }

      function buildGradeControls(route) {
        const routeId = getRouteId(route);
        if (!routeId) {
          return null;
        }

        const container = document.createElement('div');
        container.className = 'grade-section';

        const gradeForm = document.createElement('form');
        gradeForm.className = 'grade-form';
        gradeForm.noValidate = true;

        const gradeLabel = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.textContent = `Your grade (${MIN_GRADE_VALUE}-${MAX_GRADE_VALUE})`;
        gradeLabel.appendChild(labelText);

        const gradeInput = document.createElement('input');
        gradeInput.type = 'number';
        gradeInput.min = String(MIN_GRADE_VALUE);
        gradeInput.max = String(MAX_GRADE_VALUE);
        gradeInput.step = '1';
        gradeInput.inputMode = 'numeric';
        const existingGrade = getUserGradeForRoute(routeId);
        gradeInput.value = existingGrade !== null ? String(existingGrade) : '';
        gradeInput.placeholder = '—';
        gradeInput.dataset.infoTarget = 'route-grade';

        gradeLabel.appendChild(gradeInput);

        const gradeInputRow = document.createElement('div');
        gradeInputRow.className = 'grade-input-row';
        gradeInputRow.appendChild(gradeLabel);

        gradeForm.appendChild(gradeInputRow);

        let isSubmittingGrade = false;
        let lastSubmittedValue = gradeInput.value.trim();

        const commitGradeFromInput = async () => {
          if (isSubmittingGrade) {
            return;
          }

          const rawValue = gradeInput.value.trim();
          if (rawValue === lastSubmittedValue) {
            return;
          }

          isSubmittingGrade = true;

          try {
            if (!rawValue) {
              gradeInput.setCustomValidity('');
            await applyUserRouteGrade(route, null);
              lastSubmittedValue = '';
              gradeInput.value = '';
              return;
            }

            const parsed = normalizeGradeValue(rawValue);
            if (parsed === null) {
              gradeInput.setCustomValidity(
                `Enter a whole number between ${MIN_GRADE_VALUE} and ${MAX_GRADE_VALUE}.`,
              );
              gradeInput.reportValidity();
              return;
            }

            gradeInput.setCustomValidity('');
            await applyUserRouteGrade(route, parsed);
            lastSubmittedValue = String(parsed);
            gradeInput.value = String(parsed);
          } finally {
            isSubmittingGrade = false;
          }
        };

        gradeInput.addEventListener('input', () => {
          gradeInput.setCustomValidity('');
        });

        gradeInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            gradeForm.requestSubmit();
          }
        });

        gradeInput.addEventListener('blur', () => {
          void commitGradeFromInput();
        });

        gradeForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          event.stopPropagation();
          await commitGradeFromInput();
        });

        container.appendChild(gradeForm);

        return container;
      }

      function buildBetatipsSection(route, ariaLines = []) {
        const routeId = getRouteId(route);
        if (!routeId) {
          return null;
        }

        const betatipsMap = getRouteBetatipsMap(routeId);
        const currentUid = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        const entries = [];
        const rewrittenEntries = [];
        let needsRewrite = false;

        if (betatipsMap instanceof Map) {
          betatipsMap.forEach((value, key) => {
            const normalized = normalizeBetatipCacheValue(value, key);
            const text = normalized.text;
            if (!text) {
              needsRewrite = true;
              return;
            }

            const betatipId = normalized.betatipId || (typeof key === 'string' ? key.trim() : '');
            const userId = normalized.userId || (typeof key === 'string' ? key.trim() : '');
            const upvoteSet = normalized.upvoters instanceof Set ? normalized.upvoters : new Set();
            const upvoteCount =
              typeof normalized.upvoteCount === 'number' && Number.isFinite(normalized.upvoteCount)
                ? normalized.upvoteCount
                : upvoteSet.size;
            const isCurrent = currentUid ? userId === currentUid : false;
            const normalizedUsername = isValidUsername(normalized.username)
              ? normalizeUsername(normalized.username)
              : '';
            const displayName = normalizedUsername
              ? `User ${normalizedUsername}`
              : 'Anonymous climber';

            entries.push({
              betatipId: betatipId || userId || '',
              userId,
              username: displayName,
              text,
              isCurrent,
              upvoteCount,
            });

            const nextKey = betatipId || userId || (typeof key === 'string' ? key.trim() : '');
            rewrittenEntries.push({
              key: nextKey,
              value: {
                betatipId: nextKey,
                userId,
                username: normalizedUsername,
                betatip: text,
                upvoters: upvoteSet,
                upvoteCount,
              },
            });

            if (
              typeof key !== 'string' ||
              !key.trim() ||
              nextKey !== key.trim() ||
              typeof value !== 'object' ||
              value.betatip !== text ||
              value.userId !== userId ||
              !(value.upvoters instanceof Set)
            ) {
              needsRewrite = true;
            }
          });
        }

        if (needsRewrite && betatipsMap instanceof Map) {
          betatipsMap.clear();
          rewrittenEntries.forEach(({ key, value }) => {
            if (typeof key === 'string' && key.trim()) {
              betatipsMap.set(key.trim(), value);
            }
          });
        }

        entries.sort((a, b) => {
          if (b.upvoteCount !== a.upvoteCount) {
            return b.upvoteCount - a.upvoteCount;
          }

          const nameComparison = a.username.localeCompare(b.username);
          if (nameComparison !== 0) {
            return nameComparison;
          }

          return a.text.localeCompare(b.text);
        });

        const section = document.createElement('section');
        section.className = 'tooltip-betatips';

        const heading = document.createElement('h3');
        heading.className = 'tooltip-betatips-heading';
        heading.textContent = 'Beta tips';
        section.appendChild(heading);

        if (Array.isArray(ariaLines)) {
          ariaLines.push('Beta tips');
        }

        const list = document.createElement('div');
        list.className = 'tooltip-betatips-list';

        if (entries.length) {
          entries.forEach(({ betatipId, userId, username, text, isCurrent, upvoteCount }) => {
            const entry = document.createElement('article');
            entry.className = 'betatip-entry';
            if (isCurrent) {
              entry.classList.add('is-current-user');
            }

            if (typeof betatipId === 'string' && betatipId) {
              entry.dataset.betatipId = betatipId;
            }

            const nameEl = document.createElement('span');
            nameEl.className = 'betatip-username';
            nameEl.textContent = isCurrent ? `${username} (you)` : username;
            entry.appendChild(nameEl);

            const body = document.createElement('div');
            body.className = 'betatip-body';

            const countWrapper = document.createElement('span');
            countWrapper.className = 'betatip-upvote-count';
            const displayCount = upvoteCount > 0 ? String(upvoteCount) : '—';
            countWrapper.textContent = displayCount;
            countWrapper.setAttribute('aria-hidden', 'true');
            body.appendChild(countWrapper);

            const countSr = document.createElement('span');
            countSr.className = 'sr-only';
            if (upvoteCount === 0) {
              countSr.textContent = 'No upvotes yet';
            } else if (upvoteCount === 1) {
              countSr.textContent = '1 upvote';
            } else {
              countSr.textContent = `${upvoteCount} upvotes`;
            }
            body.appendChild(countSr);

            const textEl = document.createElement('p');
            textEl.className = 'betatip-text';
            textEl.textContent = text;
            body.appendChild(textEl);

            const actions = document.createElement('div');
            actions.className = 'betatip-actions';

            if (currentUser && isCurrent && typeof betatipId === 'string' && betatipId) {
              const deleteButton = document.createElement('button');
              deleteButton.type = 'button';
              deleteButton.className = 'betatip-delete-button';
              deleteButton.textContent = 'Delete tip';
              deleteButton.setAttribute('aria-label', 'Delete your beta tip');

              let isDeleting = false;
              deleteButton.addEventListener('click', async (event) => {
                event.preventDefault();
                if (isDeleting) {
                  return;
                }

                isDeleting = true;
                deleteButton.disabled = true;

                try {
                  const scrollContainer = tooltip?.querySelector('.tooltip-content');
                  const previousScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
                  await deleteBetatipForRoute(route, betatipId);
                  if (tooltip) {
                    updateTooltipContent(route);
                    const nextScrollContainer = tooltip.querySelector('.tooltip-content');
                    if (nextScrollContainer) {
                      nextScrollContainer.scrollTop = previousScrollTop;
                    }
                  }
                } catch (error) {
                  console.error('Failed to delete beta tip:', error);
                  deleteButton.disabled = false;
                  isDeleting = false;
                }
              });

              actions.appendChild(deleteButton);
            }

            if (actions.childElementCount > 0) {
              body.appendChild(actions);
            }

            entry.appendChild(body);
            list.appendChild(entry);

            if (Array.isArray(ariaLines)) {
              const upvoteSummary =
                upvoteCount === 0
                  ? 'no upvotes'
                  : upvoteCount === 1
                  ? '1 upvote'
                  : `${upvoteCount} upvotes`;
              const ariaText = text.replace(/\s+/g, ' ').trim();
              ariaLines.push(
                `Beta from ${username}${isCurrent ? ' (you)' : ''}: ${ariaText} (${upvoteSummary})`,
              );
            }
          });
        } else {
          const empty = document.createElement('p');
          empty.className = 'tooltip-betatips-empty';
          empty.textContent = 'No beta tips yet.';
          list.appendChild(empty);
          if (Array.isArray(ariaLines)) {
            ariaLines.push('No beta tips yet.');
          }
        }

        section.appendChild(list);

        if (currentUser) {
          const form = document.createElement('form');
          form.className = 'tooltip-betatips-form';
          form.noValidate = true;

          const textareaId = `betatip-${routeId.replace(/[^a-zA-Z0-9_-]/g, '-')}`;
          const label = document.createElement('label');
          label.className = 'tooltip-betatips-label';
          label.setAttribute('for', textareaId);

          const labelText = document.createElement('span');
          labelText.textContent = 'Share your beta';
          label.appendChild(labelText);

          const textarea = document.createElement('textarea');
          textarea.id = textareaId;
          textarea.className = 'tooltip-betatips-textarea';
          textarea.maxLength = MAX_BETATIP_LENGTH;
          textarea.placeholder = 'The trick is...to go up!';
          textarea.value = '';

          label.appendChild(textarea);
          form.appendChild(label);

          const actions = document.createElement('div');
          actions.className = 'tooltip-betatips-actions';

          const saveButton = document.createElement('button');
          saveButton.type = 'submit';
          saveButton.textContent = 'Save tip';
          actions.appendChild(saveButton);

          form.appendChild(actions);

          const status = document.createElement('p');
          status.className = 'tooltip-betatips-status';
          status.setAttribute('role', 'status');
          status.textContent = '';
          form.appendChild(status);

          const setSavingState = (saving) => {
            textarea.disabled = saving;
            saveButton.disabled = saving;
          };

          textarea.addEventListener('input', () => {
            status.textContent = '';
          });

          let isSaving = false;

          form.addEventListener('submit', async (event) => {
            event.preventDefault();
            if (isSaving) {
              return;
            }

            const trimmedValue = textarea.value.replace(/\r\n/g, '\n').trim();
            if (!trimmedValue) {
              status.textContent = 'Add some beta before saving.';
              return;
            }

            status.textContent = '';
            isSaving = true;
            setSavingState(true);

            try {
              await saveBetatipForRoute(route, trimmedValue);
              updateTooltipContent(route);
            } catch (error) {
              console.error('Failed to save beta tip:', error);
              status.textContent = 'We couldn’t save your beta. Please try again.';
              setSavingState(false);
              isSaving = false;
            }
          });

          section.appendChild(form);
        }

        return section;
      }

      async function applyUserRouteGrade(route, gradeValue) {
        const routeId = getRouteId(route);
        if (!routeId) {
          return;
        }

        if (!currentUser) {
          console.warn('Unable to save grade: no authenticated user.');
          return;
        }

        const userId = typeof currentUser.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to save grade: user ID missing.');
          return;
        }

        const sanitizedGrade = gradeValue === null ? null : normalizeGradeValue(gradeValue);
        if (sanitizedGrade === null && gradeValue !== null) {
          console.warn('Unable to save grade: invalid grade value provided.');
          return;
        }

        const routeRef = doc(db, 'routes', routeId, 'scores', userId);
        const isAscended = ascendedRoutes.has(routeId);

        try {
          const userPayload = {
            grade: sanitizedGrade,
            ascended: isAscended,
          };

          await setDoc(routeRef, userPayload, { merge: true });

          const existingEntry = userAscentDetails.get(routeId) || {};

          if (sanitizedGrade === null) {
            const hadRecordedGrade =
              typeof existingEntry.grade === 'number' && Number.isFinite(existingEntry.grade);

            if (existingEntry.ascended || hadRecordedGrade) {
              userAscentDetails.set(routeId, { ...existingEntry, ascended: isAscended, grade: null });
            } else {
              userAscentDetails.delete(routeId);
            }
          } else {
            const nextEntry = { ...existingEntry, ascended: isAscended, grade: sanitizedGrade };
            userAscentDetails.set(routeId, nextEntry);
          }

          let scoresMap = routeScoresCache.get(routeId);
          if (!(scoresMap instanceof Map)) {
            scoresMap = new Map();
            routeScoresCache.set(routeId, scoresMap);
          }
          scoresMap.set(userId, normalizeRouteScoreEntry(userPayload));

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
        } catch (error) {
          console.error('Failed to update route grade:', error);
        }
      }

      async function saveBetatipForRoute(route, rawText) {
        if (!currentUser) {
          throw new Error('You must be signed in to share beta tips.');
        }

        const routeId = getRouteId(route);
        if (!routeId) {
          throw new Error('Unable to determine which route to update.');
        }

        const userId = typeof currentUser.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          throw new Error('Unable to determine your account.');
        }

        let username = isValidUsername(currentUsername) ? normalizeUsername(currentUsername) : '';
        if (!username) {
          const resolved = await resolveAuthenticatedUsername();
          if (isValidUsername(resolved)) {
            username = normalizeUsername(resolved);
            currentUsername = username;
          }
        }

        if (!isValidUsername(username)) {
          throw new Error('Unable to resolve your username.');
        }

        uidUsernameCache.set(userId, username);

        const normalizedText = typeof rawText === 'string' ? rawText.replace(/\r\n/g, '\n').trim() : '';
        if (!normalizedText) {
          throw new Error('Beta tip text is required.');
        }

        const limitedText = normalizedText.slice(0, MAX_BETATIP_LENGTH);

        const betatipsMap = getRouteBetatipsMap(routeId);
        const betatipData = {
          routeId,
          userId,
          betatip: limitedText,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          upvoteCount: 0,
        };

        let betatipId = '';
        try {
          const betatipRef = await addDoc(collection(db, 'routes_users_betatips'), betatipData);
          betatipId = betatipRef.id;
        } catch (error) {
          console.error('Failed to save beta tip:', error);
          throw new Error('Unable to save your beta tip right now.');
        }

        const newEntry = {
          betatipId,
          userId,
          username,
          betatip: limitedText,
          upvoters: new Set(),
          upvoteCount: 0,
        };

        betatipsMap.set(betatipId, newEntry);

        [allRoutes, routes].forEach((collection) => {
          if (!Array.isArray(collection)) {
            return;
          }

          collection.forEach((entry) => {
            if (entry && entry.id === routeId) {
              entry.betatips = betatipsMap;
            }
          });
        });

        return limitedText;
      }

      async function deleteBetatipForRoute(route, betatipId) {
        if (!currentUser) {
          throw new Error('You must be signed in to delete beta tips.');
        }

        const routeId = getRouteId(route);
        if (!routeId) {
          throw new Error('Unable to determine which route to update.');
        }

        const userId = typeof currentUser.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          throw new Error('Unable to determine your account.');
        }

        const normalizedBetatipId = typeof betatipId === 'string' ? betatipId.trim() : '';
        if (!normalizedBetatipId) {
          throw new Error('We could not determine which beta tip to delete.');
        }

        const betatipsMap = getRouteBetatipsMap(routeId);
        const existingEntry =
          betatipsMap instanceof Map ? betatipsMap.get(normalizedBetatipId) : null;

        if (!existingEntry) {
          throw new Error('This beta tip is no longer available.');
        }

        if (existingEntry.userId !== userId) {
          throw new Error('You can only delete your own beta tips.');
        }

        try {
          const betatipRef = doc(db, 'routes_users_betatips', normalizedBetatipId);
          if (existingEntry.upvoters instanceof Set && existingEntry.upvoters.size) {
            await Promise.all(
              Array.from(existingEntry.upvoters).map((voter) =>
                deleteDoc(doc(betatipRef, 'upvotes', voter)),
              ),
            );
          }

          await deleteDoc(betatipRef);
        } catch (error) {
          console.error('Failed to delete beta tip:', error);
          throw new Error('Unable to delete this beta tip right now.');
        }

        betatipsMap.delete(normalizedBetatipId);

        [allRoutes, routes].forEach((collection) => {
          if (!Array.isArray(collection)) {
            return;
          }

          collection.forEach((entry) => {
            if (entry && entry.id === routeId) {
              entry.betatips = betatipsMap;
            }
          });
        });

        return true;
      }

      function updateTooltipContent(route) {
        if (!tooltip) {
          return;
        }

        applyTooltipColorScheme(route);

        const fragment = document.createDocumentFragment();
        const ariaLines = [];

        const header = document.createElement('div');
        header.className = 'tooltip-header';
        header.appendChild(createTooltipCloseButton());

        const displayTitle = (route.title || route.id || '').trim();
        const titleLine = document.createElement('strong');
        titleLine.className = 'tooltip-title';
        titleLine.textContent = displayTitle || 'Route details';
        header.appendChild(titleLine);
        fragment.appendChild(header);
        if (titleLine.textContent) {
          ariaLines.push(titleLine.textContent);
        }

        const routeId = getRouteId(route);
        const tooltipGrade = resolveTooltipGradeValue(route);
        const gradeDisplay = formatGradeDisplay(tooltipGrade);
        const gradeBadge = document.createElement('div');
        gradeBadge.className = 'tooltip-grade-badge';
        gradeBadge.setAttribute('aria-hidden', 'true');
        gradeBadge.setAttribute('data-grade', gradeDisplay);
        const gradeValue = document.createElement('span');
        gradeValue.className = 'tooltip-grade-value';
        gradeValue.textContent = gradeDisplay;
        gradeBadge.appendChild(gradeValue);
        const isAscended = Boolean(routeId && ascendedRoutes.has(routeId));
        if (isAscended) {
          gradeBadge.classList.add('ascended');
        }
        const gradeStrokeWidth = Math.max(2, Math.round(calculateRouteStrokeWidth(route)) || 2);
        gradeBadge.style.setProperty('--tooltip-grade-stroke-width', `${gradeStrokeWidth}px`);
        tooltip.style.setProperty('--tooltip-grade-stroke-width', `${gradeStrokeWidth}px`);
        const gradeCluster = document.createElement('div');
        gradeCluster.className = 'tooltip-grade-cluster';
        gradeCluster.appendChild(gradeBadge);

        ariaLines.push(`Grade: ${gradeDisplay}`);
        ariaLines.push(isAscended ? 'Ascended' : 'Not ascended');

        const infoContainer = document.createElement('div');
        infoContainer.className = 'tooltip-lines';
        fragment.appendChild(infoContainer);

        const appendInfoLine = (text, className = '') => {
          if (!text) {
            return;
          }
          const line = document.createElement('div');
          line.className = className ? `tooltip-line ${className}` : 'tooltip-line';
          line.textContent = text;
          infoContainer.appendChild(line);
          ariaLines.push(text);
        };

        const setterValue = typeof route.setter === 'string' ? route.setter : '';
        appendInfoLine(`Setter: ${setterValue.trim() || 'Unknown'}`);

        const descriptionText =
          typeof route.description === 'string' ? route.description.trim() : '';
        appendInfoLine(descriptionText ? `Description: ${descriptionText}` : 'Description: —');

        appendInfoLine(`Date set: ${formatDisplayDate(route.date_set)}`);

        const betatipsSection = buildBetatipsSection(route, ariaLines);
        if (betatipsSection) {
          fragment.appendChild(betatipsSection);
        }

        const content = document.createElement('div');
        content.className = 'tooltip-content';
        content.appendChild(fragment);

        tooltip.replaceChildren(gradeCluster, content);

        if (ariaLines.length) {
          tooltip.setAttribute('aria-label', ariaLines.join('\n'));
        } else {
          tooltip.removeAttribute('aria-label');
        }
      }

      function positionTooltip() {
        if (!tooltip) {
          return null;
        }

        const tooltipWidth = tooltip.offsetWidth || 0;
        const tooltipHeight = tooltip.offsetHeight || 0;
        const halfWidth = tooltipWidth / 2;

        const minHorizontalMargin = 12;
        const minLeft = halfWidth + minHorizontalMargin;
        const maxLeft = window.innerWidth - halfWidth - minHorizontalMargin;
        const desiredLeft = window.innerWidth / 2;
        const clampedLeft =
          maxLeft < minLeft ? window.innerWidth / 2 : Math.min(maxLeft, Math.max(minLeft, desiredLeft));

        const minVerticalMargin = 12;
        const maxTop = window.innerHeight - tooltipHeight - minVerticalMargin;
        const safeMaxTop = maxTop < minVerticalMargin ? Math.max(minVerticalMargin, maxTop) : maxTop;
        const isMobileViewport =
          typeof window.matchMedia === 'function'
            ? window.matchMedia('(max-width: 768px)').matches
            : window.innerWidth <= 768;
        const desiredTop =
          tutorialActive && isMobileViewport
            ? minVerticalMargin
            : (window.innerHeight - tooltipHeight) / 2;
        const clampedTop = Math.min(safeMaxTop, Math.max(minVerticalMargin, desiredTop));

        tooltip.style.left = `${clampedLeft}px`;
        tooltip.style.top = `${clampedTop}px`;

        return { x: clampedLeft, y: clampedTop };
      }

      function showTooltip(route, clientX, clientY, options = {}) {
        if (!tooltip) {
          return;
        }

        const { pin = false } = options;

        if (route.id !== activeRouteId) {
          updateTooltipContent(route);
        }

        const position = positionTooltip();
        tooltip.classList.add('visible');
        tooltip.setAttribute('aria-hidden', 'false');
        activeRouteId = route.id;

        if (pin) {
          pinnedRouteId = route.id;
          pinnedPosition = position;
          tooltip.classList.add('pinned');
        } else {
          pinnedRouteId = null;
          pinnedPosition = null;
          tooltip.classList.remove('pinned');
        }
      }

      function hideTooltip(options = {}) {
        if (!tooltip) {
          return;
        }

        const { force = false } = options;

        if (!force && pinnedRouteId) {
          return;
        }

        tooltip.classList.remove('visible');
        tooltip.classList.remove('pinned');
        tooltip.setAttribute('aria-hidden', 'true');
        activeRouteId = null;
        pinnedRouteId = null;
        pinnedPosition = null;
      }

      function updateClearFocusButton() {
        if (!clearFocusButton) {
          return;
        }

        const hasFocusedRoute = Boolean(focusedRouteId);
        clearFocusButton.classList.toggle('hidden', !hasFocusedRoute);
        clearFocusButton.setAttribute('aria-hidden', hasFocusedRoute ? 'false' : 'true');

        if (hasFocusedRoute) {
          clearFocusButton.removeAttribute('disabled');
        } else {
          clearFocusButton.setAttribute('disabled', 'true');
          if (document.activeElement === clearFocusButton && typeof clearFocusButton.blur === 'function') {
            clearFocusButton.blur();
          }
        }
      }

      function clearRouteFocus() {
        if (!focusedRouteId) {
          return;
        }

        resetLastFocusActivation();

        const activeRoutes = Array.isArray(routes) ? routes : [];
        const fallbackRoutes = Array.isArray(allRoutes) ? allRoutes : [];
        const route =
          activeRoutes.find((entry) => entry?.id === focusedRouteId) ||
          fallbackRoutes.find((entry) => entry?.id === focusedRouteId) ||
          null;

        if (route) {
          setRouteFocus(route, false);
          return;
        }

        focusedRouteId = null;
        updateClearFocusButton();
        redraw();
        renderProgressionList();
      }

      function setRouteFocus(route, shouldFocus) {
        if (!route || typeof route.id !== 'string') {
          return;
        }

        const nextFocusedId = shouldFocus ? route.id : null;
        const shouldRestoreProgressionFocus = Boolean(
          shouldFocus && progressionList && isProgressionModalOpen()
        );

        if (focusedRouteId === nextFocusedId) {
          updateClearFocusButton();
          redraw();

          if (tooltip && tooltip.classList.contains('visible') && activeRouteId === route.id) {
            updateTooltipContent(route);
          }

          renderProgressionList();

          if (shouldRestoreProgressionFocus) {
            const entry = progressionList.querySelector(
              `[data-route-id="${route.id}"]`,
            );
            if (entry && typeof entry.focus === 'function') {
              entry.focus();
            }
          }
          return;
        }

        focusedRouteId = nextFocusedId;
        updateClearFocusButton();

        redraw();

        if (tooltip && tooltip.classList.contains('visible') && activeRouteId === route.id) {
          updateTooltipContent(route);
        }

        renderProgressionList();

        if (shouldRestoreProgressionFocus) {
          const entry = progressionList.querySelector(`[data-route-id="${route.id}"]`);
          if (entry && typeof entry.focus === 'function') {
            entry.focus();
          }
        }
      }

      function focusRoute(route) {
        const shouldCloseProgression = isProgressionModalOpen();
        setRouteFocus(route, true);

        if (shouldCloseProgression) {
          closeProgressionModal();
        }
      }

      function extractClientPoint(event) {
        if (typeof event.clientX === 'number' && typeof event.clientY === 'number') {
          return { x: event.clientX, y: event.clientY };
        }

        const touch = event.touches?.[0] ?? event.changedTouches?.[0];
        if (touch) {
          return { x: touch.clientX, y: touch.clientY };
        }

        return null;
      }

      function distanceSquared(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return dx * dx + dy * dy;
      }

      function isPointNearSegment(px, py, x1, y1, x2, y2, padding = 0) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSquared = dx * dx + dy * dy;

        if (lengthSquared <= 0.0001) {
          return distanceSquared(px, py, x1, y1) <= padding * padding;
        }

        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));

        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        return distanceSquared(px, py, projX, projY) <= padding * padding;
      }

      function getRouteEntryAtClientPoint(clientX, clientY) {
        if (!Array.isArray(routeInteractionEntries) || routeInteractionEntries.length === 0) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        for (let index = routeInteractionEntries.length - 1; index >= 0; index -= 1) {
          const entry = routeInteractionEntries[index];
          if (!entry || !entry.route) {
            continue;
          }

          if (entry.type === 'circle') {
            const radius = Number(entry.r) || 0;
            if (radius > 0) {
              const distance = distanceSquared(x, y, Number(entry.cx), Number(entry.cy));
              if (distance <= radius * radius) {
                return { route: entry.route, canvasX: entry.cx, canvasY: entry.cy };
              }
            }
          } else if (entry.type === 'rect') {
            const left = Number(entry.left);
            const right = Number(entry.right);
            const top = Number(entry.top);
            const bottom = Number(entry.bottom);
            if (x >= left && x <= right && y >= top && y <= bottom) {
              return {
                route: entry.route,
                canvasX: (left + right) / 2,
                canvasY: (top + bottom) / 2,
              };
            }
          } else if (entry.type === 'segment') {
            const padding = Number(entry.padding) || 0;
            const x1 = Number(entry.x1);
            const y1 = Number(entry.y1);
            const x2 = Number(entry.x2);
            const y2 = Number(entry.y2);
            if (isPointNearSegment(x, y, x1, y1, x2, y2, padding)) {
              return {
                route: entry.route,
                canvasX: (x1 + x2) / 2,
                canvasY: (y1 + y2) / 2,
              };
            }
          }
        }

        return null;
      }

      function beginPointerInteraction(event) {
        const point = extractClientPoint(event);
        if (!point) {
          activePointerInteraction = null;
          return;
        }

        const pointerId = 'pointerId' in event ? event.pointerId : null;
        activePointerInteraction = {
          pointerId,
          startX: point.x,
          startY: point.y,
          latestX: point.x,
          latestY: point.y,
          dragging: false,
        };
      }

      function updatePointerInteraction(event) {
        if (!activePointerInteraction) {
          return;
        }

        if (
          'pointerId' in event &&
          activePointerInteraction.pointerId !== null &&
          event.pointerId !== activePointerInteraction.pointerId
        ) {
          return;
        }

        const point = extractClientPoint(event);
        if (!point) {
          return;
        }

        activePointerInteraction.latestX = point.x;
        activePointerInteraction.latestY = point.y;

        if (!activePointerInteraction.dragging) {
          const movementSquared = distanceSquared(
            activePointerInteraction.startX,
            activePointerInteraction.startY,
            point.x,
            point.y,
          );

          if (movementSquared > CLICK_DRAG_DISTANCE_THRESHOLD_SQUARED) {
            activePointerInteraction.dragging = true;
          }
        }
      }

      function concludePointerInteraction(event) {
        if (!activePointerInteraction) {
          return null;
        }

        if (
          'pointerId' in event &&
          activePointerInteraction.pointerId !== null &&
          event.pointerId !== activePointerInteraction.pointerId
        ) {
          return null;
        }

        const point = extractClientPoint(event);
        const resolvedX = point?.x ?? activePointerInteraction.latestX;
        const resolvedY = point?.y ?? activePointerInteraction.latestY;

        const result = {
          x: resolvedX,
          y: resolvedY,
          dragging: activePointerInteraction.dragging,
        };

        activePointerInteraction = null;
        return result;
      }

      function cancelPointerInteraction() {
        activePointerInteraction = null;
        resetLastFocusActivation();
      }

      function applyLocationFilter() {
        const desiredLocation = normalizeLocationName(currentLocation?.name);
        const fallbackLocation = normalizeLocationName(getDefaultLocation()?.name);
        const targetLocation = desiredLocation || fallbackLocation;

        if (!targetLocation) {
          routes = [...allRoutes];
        } else {
          routes = allRoutes.filter((route) => {
            const routeLocation =
              typeof route?.locationKey === 'string'
                ? route.locationKey
                : normalizeLocationName(route?.location);
            return routeLocation === targetLocation;
          });
        }

        if (focusedRouteId) {
          const hasFocusedRoute = routes.some((route) => route.id === focusedRouteId);
          if (!hasFocusedRoute) {
            focusedRouteId = null;
            updateClearFocusButton();
            hideTooltip({ force: true });
          }
        }

        synchroniseAscentsWithRoutes({ shouldRedraw: false });
        redraw();
      }

      async function loadRoutes() {
        try {
          const [routesSnapshot, wallSnapshot, betatipsSnapshot] = await Promise.all([
            getDocs(collection(db, 'routes')),
            getDocs(collection(db, WALL_COLLECTION)),
            getDocs(collection(db, 'routes_users_betatips')),
          ]);

          routeScoresCache.clear();
          routeBetatipsCache.clear();

          const routeDescriptors = routesSnapshot.docs.map((docSnap) => {
            const data = docSnap.data() || {};
            const routeUid =
              normalizeRouteUidValue(data?.uid) || normalizeRouteUidValue(docSnap.id);

            if (routeUid) {
              getRouteScoresMap(routeUid);
            }

            return { docSnap, data, routeUid };
          });

          await hydrateRouteScores(routeDescriptors);

          const betatipEntries = [];
          betatipsSnapshot.forEach((docSnap) => {
            const data = docSnap.data() || {};
            const routeId = normalizeRouteUidValue(data.routeId);
            const userId = typeof data.userId === 'string' ? data.userId.trim() : '';

            if (!routeId || !userId) {
              return;
            }

            const text =
              typeof data.betatip === 'string'
                ? data.betatip.replace(/\r\n/g, '\n').trim()
                : '';
            const upvoteCount =
              typeof data.upvoteCount === 'number' && Number.isFinite(data.upvoteCount)
                ? data.upvoteCount
                : 0;

            if (!text) {
              return;
            }

            betatipEntries.push({
              id: docSnap.id,
              routeId,
              userId,
              text,
              upvoteCount,
            });
          });

          await Promise.all(
            betatipEntries.map(async (entry) => {
              const resolvedUsername = await lookupUsernameByUid(entry.userId);
              const normalizedUsername = isValidUsername(resolvedUsername)
                ? resolvedUsername
                : '';
              const betatipsMap = getRouteBetatipsMap(entry.routeId);
              const upvoters = await loadBetatipUpvotes(entry.id);
              const calculatedCount = upvoters.size;
              const normalizedCount = Math.max(entry.upvoteCount, calculatedCount);
              betatipsMap.set(entry.id, {
                betatipId: entry.id,
                userId: entry.userId,
                username: normalizedUsername,
                betatip: entry.text,
                upvoters,
                upvoteCount: normalizedCount,
              });
            }),
          );

          wallSettingsCache.clear();
          const hiddenWallKeys = new Set();
          let locationsChanged = false;
          wallSnapshot.forEach((docSnap) => {
            const data = docSnap.data();
            const settings = normalizeWallSettings(data);
            const normalizedId = normalizeWallKey(docSnap.id);
            const normalizedName = normalizeWallKey(data?.name);
            const normalizedKeyField = normalizeWallKey(data?.key);
            const isHidden = data?.hidden === true;

            if (normalizedId) {
              wallSettingsCache.set(normalizedId, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedId);
              }
            }

            if (normalizedName) {
              wallSettingsCache.set(normalizedName, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedName);
              }
            }

            if (normalizedKeyField) {
              wallSettingsCache.set(normalizedKeyField, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedKeyField);
              }
            }

            const { changed } = upsertLocation({
              key: typeof data?.key === 'string' ? data.key : docSnap.id,
              name: typeof data?.name === 'string' ? data.name : '',
              image: typeof data?.background_url === 'string' ? data.background_url : '',
              fallbackName: typeof data?.name === 'string' && data.name ? data.name : docSnap.id,
              hidden: isHidden,
            });

            if (changed) {
              locationsChanged = true;
            }
          });

          if (locationsChanged) {
            renderLocationOptions();
            synchronizeCurrentLocationReference();
          } else {
            ensureCurrentLocationVisible();
          }

          allRoutes = routeDescriptors
            .map(({ docSnap, data, routeUid }) => {
              if (!docSnap) {
                return null;
              }

              const betatipsMap = getRouteBetatipsMap(routeUid);
              getRouteScoresMap(routeUid);
              if (data.hiddenFromClimbers === true) {
                return null;
              }

              const grade = computeMedianGradeForRoute(routeUid);

              const pointsByType = normalizeRoutePointsByType(
                data.points,
                data.pathType,
              );
              const normalizedPoints = selectNormalizedPointsForPath(
                pointsByType,
                data.pathType,
              );

              const rawLocationValue = typeof data.location === 'string' ? data.location.trim() : '';
              const defaultLocation = getDefaultLocation();
              const normalizedLocation =
                normalizeLocationName(rawLocationValue) || normalizeLocationName(defaultLocation?.name);
              const displayLocation = rawLocationValue || defaultLocation?.name || '';

              if (normalizedLocation && hiddenWallKeys.has(normalizedLocation)) {
                return null;
              }

              const fallbackWallSettings = {
                pointDiameter: data.pointDiameter,
                hollowPointDiameter: data.hollowPointDiameter ?? data.pointDiameter,
                filledPointDiameter: data.filledPointDiameter ?? data.pointDiameter,
                rectangleWidth: data.rectangleWidth,
                rectangleHeight: data.rectangleHeight,
                brezerStrokeWidth: data.brezerStrokeWidth,
                gradeBarBaseHeight: data.gradeBarBaseHeight,
                gradeBarMaxHeight: data.gradeBarMaxHeight,
                gradeBarWidth: data.gradeBarWidth,
                transparency: data.transparency ?? data.gradeBarTransparency,
                unfocusedTransparency: data.unfocusedTransparency,
              };
              const wallSettings = resolveWallSettings(normalizedLocation, fallbackWallSettings);

              return {
                id: routeUid,
                uid: routeUid,
                strokeColor: typeof data.strokeColor === 'string' ? data.strokeColor : '#ffde59',
                points: normalizedPoints,
                pointsByType,
                title: typeof data.title === 'string' ? data.title : '',
                setter: typeof data.setter === 'string' ? data.setter : '',
                description: typeof data.description === 'string' ? data.description : '',
                date_set: normalizeDate(data.date_set),
                date_removed: normalizeDate(data.date_removed),
                location: displayLocation,
                locationKey: normalizedLocation,
                grade,
                pathType: normalizePathType(data.pathType),
                pointDiameter: wallSettings.pointDiameter,
                hollowPointDiameter: wallSettings.hollowPointDiameter,
                filledPointDiameter: wallSettings.filledPointDiameter,
                rectangleWidth: wallSettings.rectangleWidth,
                rectangleHeight: wallSettings.rectangleHeight,
                brezerStrokeWidth: wallSettings.brezerStrokeWidth,
                gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
                gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
                gradeBarWidth: wallSettings.gradeBarWidth,
                gradeBarTransparency: wallSettings.gradeBarTransparency,
                unfocusedTransparency: wallSettings.unfocusedTransparency,
                betatips: betatipsMap,
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              const nameA = (a.title || a.uid || a.id).toLowerCase();
              const nameB = (b.title || b.uid || b.id).toLowerCase();
              return nameA.localeCompare(nameB);
            });

          applyLocationFilter();
        } catch (error) {
          console.error('Failed to load routes:', error);
          allRoutes = [];
          routes = [];
          focusedRouteId = null;
          updateClearFocusButton();
          routeScoresCache.clear();
          routeBetatipsCache.clear();
          renderProgressionList();
          redraw();
        }
      }

      async function toggleRouteAscent(route) {
        if (!currentUser) {
          return;
        }

        const userId = typeof currentUser.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to mark ascent: user ID missing.');
          return;
        }

        const routeId = getRouteId(route);
        if (!routeId) {
          console.warn('Unable to mark ascent: route ID missing.');
          return;
        }

        const routeRef = doc(db, 'routes', routeId, 'scores', userId);
        const isAscended = ascendedRoutes.has(routeId);
        const previousDetails =
          routeScoresCache.get(routeId) instanceof Map
            ? routeScoresCache.get(routeId).get(userId)
            : null;
        const persistedGrade = normalizeGradeValue(previousDetails?.grade);
        const fallbackGrade = getUserGradeForRoute(routeId);
        const normalizedGrade =
          typeof persistedGrade === 'number' && Number.isFinite(persistedGrade)
            ? persistedGrade
            : fallbackGrade;
        const sanitizedGrade =
          typeof normalizedGrade === 'number' && Number.isFinite(normalizedGrade)
            ? normalizedGrade
            : null;

        try {
          const nextAscended = !isAscended;
          const userPayload = {
            grade: sanitizedGrade,
            ascended: nextAscended,
          };

          await setDoc(routeRef, userPayload, { merge: true });

          userAscentDetails.set(routeId, {
            ascended: nextAscended,
            grade: sanitizedGrade,
          });

          let scoresMap = routeScoresCache.get(routeId);
          if (!(scoresMap instanceof Map)) {
            scoresMap = new Map();
            routeScoresCache.set(routeId, scoresMap);
          }
          scoresMap.set(userId, normalizeRouteScoreEntry(userPayload));

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          redraw();
        } catch (error) {
          console.error('Failed to update ascent:', error);
        }
      }

      function computeCanvasDimensions() {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const aspectRatio = Number.isFinite(canvasAspectRatio) && canvasAspectRatio > 0
          ? canvasAspectRatio
          : DEFAULT_CANVAS_ASPECT_RATIO;
        const enableScroll = viewportWidth <= 768 && viewportHeight > viewportWidth;

        if (enableScroll) {
          const height = viewportHeight;
          const width = Math.max(viewportWidth, Math.round(height * aspectRatio));
          return { width, height, enableScroll };
        }

        return {
          width: viewportWidth,
          height: viewportHeight,
          enableScroll: false,
        };
      }

      function resizeCanvas() {
        const { width, height, enableScroll } = computeCanvasDimensions();

        if (canvasContainer) {
          canvasContainer.classList.toggle('scrollable', enableScroll);
        }

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        if (canvasContainer) {
          if (enableScroll) {
            const maxScrollLeft = Math.max(0, width - window.innerWidth);
            if (!isHorizontalScrollEnabled) {
              canvasContainer.scrollLeft = Math.max(0, maxScrollLeft / 2);
            } else if (canvasContainer.scrollLeft > maxScrollLeft) {
              canvasContainer.scrollLeft = maxScrollLeft;
            }
          } else if (isHorizontalScrollEnabled) {
            canvasContainer.scrollLeft = 0;
          }
        }

        isHorizontalScrollEnabled = enableScroll;
        redraw();
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (backgroundReady && backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        routeInteractionEntries = [];
        let isFocusActive = false;
        let resolvedFocusRoute = null;
        let focusedRoutePointKeys = null;

        if (focusedRouteId) {
          resolvedFocusRoute = routes.find((route) => route.id === focusedRouteId) || null;
          if (resolvedFocusRoute) {
            isFocusActive = true;
            focusedRoutePointKeys = buildNormalizedPointKeySet(resolvedFocusRoute.points);
          } else {
            focusedRouteId = null;
            updateClearFocusButton();
          }
        }

        const shouldPreservePinned = Boolean(
          pinnedRouteId &&
            pinnedPosition &&
            (!isFocusActive || pinnedRouteId === focusedRouteId),
        );
        const pinnedRoute = shouldPreservePinned
          ? routes.find((route) => route.id === pinnedRouteId)
          : null;

        if (!shouldPreservePinned) {
          hideTooltip();
        } else if (!pinnedRoute) {
          hideTooltip({ force: true });
        }

        const overlapGroups = buildOverlappingShapeGroups(routes);
        const routeAlphaMap = new Map();

        routes.forEach((route) => {
          if (!route || typeof route.id !== 'string') {
            return;
          }
          const isFocused = isFocusActive && route.id === focusedRouteId;
          const routeAlpha = isFocused
            ? 1
            : isFocusActive
              ? normalizeUnfocusedTransparency(route.unfocusedTransparency)
              : 1;
          routeAlphaMap.set(route.id, routeAlpha);
        });

        const handledOverlapKeys = new Set();

        routes.forEach((route) => {
          const isFocused = isFocusActive && route.id === focusedRouteId;
          const routeAlpha = routeAlphaMap.get(route?.id) ?? 1;
          const omitOverlaps = !isFocused && focusedRoutePointKeys?.size ? focusedRoutePointKeys : null;
          drawRoute(route, {
            alpha: routeAlpha,
            omitOverlappingPointKeys: omitOverlaps,
            overlapGroups,
            handledOverlapKeys,
            routeAlphaMap,
            isFocused,
          });
        });
        if (pinnedRoute && tooltip) {
          updateTooltipContent(pinnedRoute);
          tooltip.classList.add('visible');
          tooltip.classList.add('pinned');
          tooltip.setAttribute('aria-hidden', 'false');
          const updatedPosition = positionTooltip();
          if (updatedPosition) {
            pinnedPosition = updatedPosition;
          }
        }
      }

      function clamp(value, min, max) {
        if (!Number.isFinite(value)) {
          return min;
        }
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }

      function createNormalizedPointKey(x, y) {
        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          return null;
        }

        const clampedX = Math.min(Math.max(x, 0), 1);
        const clampedY = Math.min(Math.max(y, 0), 1);
        const scaledX = Math.round(clampedX * 10000);
        const scaledY = Math.round(clampedY * 10000);
        return `${scaledX}:${scaledY}`;
      }

      function buildNormalizedPointKeySet(points = []) {
        const keys = new Set();
        if (!Array.isArray(points) || !points.length) {
          return keys;
        }

        points.forEach((point) => {
          const x = Number(point?.x);
          const y = Number(point?.y);
          const key = createNormalizedPointKey(x, y);
          if (key) {
            keys.add(key);
          }
        });

        return keys;
      }

      function getRouteStrokeColor(route) {
        const rawColor = route?.strokeColor;
        if (typeof rawColor === 'string' && rawColor.trim()) {
          return rawColor;
        }
        return '#ffde59';
      }

      function getGradeColorForValue(value) {
        if (typeof value !== 'number' || !Number.isFinite(value)) {
          return null;
        }

        const rounded = Math.round(value);
        if (!Number.isFinite(rounded)) {
          return null;
        }

        const clamped = Math.min(Math.max(rounded, MIN_GRADE_VALUE), MAX_GRADE_VALUE);
        return GRADE_COLOR_MAP.get(clamped) ?? null;
      }

      function getRouteGradeColor(route) {
        if (!route) {
          return null;
        }

        const routeId = getRouteId(route);
        const grade = computeMedianGradeForRoute(routeId);
        return getGradeColorForValue(grade);
      }

      function getRouteDisplayColor(route) {
        if (viewMode === VIEW_MODE_GRADE_COLORS) {
          const gradeColor = getRouteGradeColor(route);
          return gradeColor ?? DEFAULT_GRADELESS_COLOR;
        }
        return getRouteStrokeColor(route);
      }

      function createOverlapGroupKey(pathType, pointKey) {
        if (!pathType || !pointKey) {
          return null;
        }
        return `${pathType}::${pointKey}`;
      }

      function buildOverlappingShapeGroups(routeList = []) {
        const groups = new Map();

        if (!Array.isArray(routeList) || !routeList.length) {
          return groups;
        }

        routeList.forEach((route) => {
          if (!route) {
            return;
          }

          const pointEntries = getRoutePointEntries(route);
          if (!pointEntries.length) {
            return;
          }

          const strokeColor = getRouteStrokeColor(route);
          const normalizedRectangleWidth = normalizeRectangleSize(
            route.rectangleWidth,
            DEFAULT_RECTANGLE_WIDTH,
          );
          const normalizedRectangleHeight = normalizeRectangleSize(
            route.rectangleHeight,
            DEFAULT_RECTANGLE_HEIGHT,
          );

          pointEntries.forEach(({ pathType, points }) => {
            if (
              !Array.isArray(points) ||
              !points.length ||
              (!isNormalizedPointPathType(pathType) && pathType !== PATH_TYPE_RECTANGLE)
            ) {
              return;
            }

            const normalizedPointDiameter = getRoutePointDiameterForPathType(route, pathType);

            points.forEach((point) => {
              const normalizedX = Number(point?.x);
              const normalizedY = Number(point?.y);
              const pointKey = createNormalizedPointKey(normalizedX, normalizedY);
              if (!pointKey) {
                return;
              }

              const groupKey = createOverlapGroupKey(pathType, pointKey);
              if (!groupKey) {
                return;
              }

              if (!groups.has(groupKey)) {
                groups.set(groupKey, {
                  pathType,
                  entries: [],
                });
              }

              const group = groups.get(groupKey);
              group.entries.push({
                routeId: route.id,
                color: strokeColor,
                pointDiameter: normalizedPointDiameter,
                rectangleWidth: normalizedRectangleWidth,
                rectangleHeight: normalizedRectangleHeight,
              });
            });
          });
        });

        for (const [key, group] of groups) {
          if (!group || !Array.isArray(group.entries) || group.entries.length <= 1) {
            groups.delete(key);
          }
        }

        return groups;
      }

      function drawOverlappingPointGroup(ctx, center, entries) {
        if (!ctx || !center || !entries || entries.length <= 1) {
          return;
        }

        const total = entries.length;
        const radii = entries.map((entry) => Math.max(1, Number(entry.pointDiameter) / 2));
        const radius = Math.max(...radii, 4);
        const step = (Math.PI * 2) / total;
        const startAngle = -Math.PI / 2;

        ctx.save();
        ctx.setLineDash([]);
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';

        entries.forEach((entry, index) => {
          const strokeWidth = Math.max(2, Math.round(Number(entry.pointDiameter) / 10) || 2);
          const angleStart = startAngle + step * index;
          const angleEnd = angleStart + step;

          ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = entry.color || '#ffde59';
          ctx.beginPath();
          ctx.arc(center.x, center.y, radius, angleStart, angleEnd);
          ctx.stroke();
        });

        ctx.restore();
      }

      function drawOverlappingRectangleGroup(ctx, center, entries) {
        if (!ctx || !center || !entries || entries.length <= 1) {
          return;
        }

        const widths = entries.map((entry) => Math.max(1, Number(entry.rectangleWidth) || 0));
        const heights = entries.map((entry) => Math.max(1, Number(entry.rectangleHeight) || 0));
        const width = Math.max(...widths, 4);
        const height = Math.max(...heights, 4);
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const perimeter = 2 * (width + height);

        if (!Number.isFinite(perimeter) || perimeter <= 0) {
          return;
        }

        const segmentLength = perimeter / entries.length;
        const edges = [
          { length: width, startX: center.x - halfWidth, startY: center.y - halfHeight, dx: 1, dy: 0 },
          { length: height, startX: center.x + halfWidth, startY: center.y - halfHeight, dx: 0, dy: 1 },
          { length: width, startX: center.x + halfWidth, startY: center.y + halfHeight, dx: -1, dy: 0 },
          { length: height, startX: center.x - halfWidth, startY: center.y + halfHeight, dx: 0, dy: -1 },
        ];
        const edgeCount = edges.length;

        let offset = 0;

        entries.forEach((entry) => {
          let localOffset = offset % perimeter;
          if (localOffset < 0) {
            localOffset += perimeter;
          }

          let edgeIndex = 0;
          while (localOffset >= edges[edgeIndex].length && edgeIndex < edgeCount - 1) {
            localOffset -= edges[edgeIndex].length;
            edgeIndex += 1;
          }

          let currentX = edges[edgeIndex].startX + edges[edgeIndex].dx * localOffset;
          let currentY = edges[edgeIndex].startY + edges[edgeIndex].dy * localOffset;
          let remaining = segmentLength;

          ctx.save();
          ctx.setLineDash([]);
          ctx.lineCap = 'butt';
          ctx.lineJoin = 'miter';
          ctx.lineWidth = Math.max(
            2,
            Math.round(Math.max(Number(entry.rectangleWidth) || 0, Number(entry.rectangleHeight) || 0) / 10) || 2,
          );
          ctx.strokeStyle = entry.color || '#ffde59';
          ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;

          while (remaining > 0) {
            const edge = edges[edgeIndex];
            const available = edge.length - localOffset;
            const step = Math.min(remaining, available);
            const nextOffset = localOffset + step;
            const nextX = edge.startX + edge.dx * nextOffset;
            const nextY = edge.startY + edge.dy * nextOffset;

            ctx.beginPath();
            ctx.moveTo(currentX, currentY);
            ctx.lineTo(nextX, nextY);
            ctx.stroke();

            remaining -= step;
            currentX = nextX;
            currentY = nextY;
            localOffset = 0;
            edgeIndex = (edgeIndex + 1) % edgeCount;
          }

          ctx.restore();

          offset += segmentLength;
          if (offset >= perimeter) {
            offset -= perimeter;
          }
        });
      }

      function calculateRouteStrokeWidth(route, pathTypeOverride = undefined) {
        const pathType = normalizePathType(pathTypeOverride ?? route?.pathType);
        if (pathType === PATH_TYPE_BREZER) {
          return normalizeBrezerStrokeWidth(route?.brezerStrokeWidth);
        }
        if (pathType === PATH_TYPE_HOLLOW_POINT) {
          const diameter = getRoutePointDiameterForPathType(route, PATH_TYPE_HOLLOW_POINT);
          return Math.max(2, Math.round(diameter / 10));
        }
        if (pathType === PATH_TYPE_FILLED_POINT) {
          const diameter = getRoutePointDiameterForPathType(route, PATH_TYPE_FILLED_POINT);
          return Math.max(2, Math.round(diameter / 10));
        }
        if (pathType === PATH_TYPE_RECTANGLE) {
          const width = normalizeRectangleSize(route?.rectangleWidth, DEFAULT_RECTANGLE_WIDTH);
          const height = normalizeRectangleSize(route?.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT);
          return Math.max(2, Math.round(Math.max(width, height) / 10));
        }
        return DEFAULT_BREZER_STROKE_WIDTH;
      }

      function drawRoute(route, options = {}) {
        const strokeColor = getRouteDisplayColor(route);
        const pointEntries = getRoutePointEntries(route);

        const alphaValue = Number(options.alpha);
        const routeAlpha = Number.isFinite(alphaValue)
          ? Math.min(Math.max(alphaValue, 0), 1)
          : 1;

        const omitOverlapKeys =
          options?.omitOverlappingPointKeys instanceof Set ? options.omitOverlappingPointKeys : null;
        const overlapGroups =
          options?.overlapGroups instanceof Map ? options.overlapGroups : null;
        const handledOverlapKeys =
          options?.handledOverlapKeys instanceof Set ? options.handledOverlapKeys : null;
        const routeAlphaMap =
          options?.routeAlphaMap instanceof Map ? options.routeAlphaMap : null;
        const isFocusedRoute = Boolean(options?.isFocused);

        if (!pointEntries.length) {
          return;
        }

        const interactionRegions = [];

        pointEntries.forEach(({ pathType, points }) => {
          if (!Array.isArray(points) || !points.length) {
            return;
          }

          const supportsOverlapPattern =
            isNormalizedPointPathType(pathType) || pathType === PATH_TYPE_RECTANGLE;
          const shouldFilterOverlaps =
            omitOverlapKeys && omitOverlapKeys.size > 0 && supportsOverlapPattern;

          const pathPoints = [];
          const visiblePoints = [];

          points.forEach((point) => {
            const normalizedX = Number(point?.x);
            const normalizedY = Number(point?.y);
            if (!Number.isFinite(normalizedX) || !Number.isFinite(normalizedY)) {
              return;
            }

            const scaledPoint = {
              x: normalizedX * canvas.width,
              y: normalizedY * canvas.height,
            };
            pathPoints.push(scaledPoint);

            const pointKey = supportsOverlapPattern
              ? createNormalizedPointKey(normalizedX, normalizedY)
              : null;

            if (shouldFilterOverlaps && pointKey && omitOverlapKeys.has(pointKey)) {
              return;
            }

            const overlapKey =
              pointKey && overlapGroups ? createOverlapGroupKey(pathType, pointKey) : null;
            const overlapGroup =
              overlapKey && overlapGroups ? overlapGroups.get(overlapKey) : null;

            if (
              overlapGroup &&
              Array.isArray(overlapGroup.entries) &&
              overlapGroup.entries.length > 1 &&
              !isFocusedRoute
            ) {
              if (handledOverlapKeys && handledOverlapKeys.has(overlapKey)) {
                return;
              }

              const entriesWithAlpha = overlapGroup.entries.map((entry) => {
                const mappedAlpha = routeAlphaMap?.get(entry.routeId);
                const entryAlpha = Number.isFinite(mappedAlpha) ? mappedAlpha : 1;
                return { ...entry, alpha: entryAlpha };
              });

              if (handledOverlapKeys) {
                handledOverlapKeys.add(overlapKey);
              }

              if (isNormalizedPointPathType(pathType)) {
                drawOverlappingPointGroup(ctx, scaledPoint, entriesWithAlpha);
              } else if (pathType === PATH_TYPE_RECTANGLE) {
                drawOverlappingRectangleGroup(ctx, scaledPoint, entriesWithAlpha);
              }
              return;
            }

            visiblePoints.push(scaledPoint);
          });

          if (!pathPoints.length) {
            return;
          }

          const resolvedPointDiameter = getRoutePointDiameterForPathType(route, pathType);
          const rectangleWidth = normalizeRectangleSize(route.rectangleWidth, DEFAULT_RECTANGLE_WIDTH);
          const rectangleHeight = normalizeRectangleSize(route.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT);

          ctx.save();
          ctx.globalAlpha = routeAlpha;

          if (pathType === PATH_TYPE_HOLLOW_POINT) {
            const circleRadius = Math.max(1, resolvedPointDiameter / 2);
            const strokeWidth = Math.max(2, Math.round(resolvedPointDiameter / 10));
            if (visiblePoints.length) {
              const path = new Path2D();

              visiblePoints.forEach((point) => {
                path.moveTo(point.x + circleRadius, point.y);
                path.arc(point.x, point.y, circleRadius, 0, Math.PI * 2);
              });

              ctx.save();
              ctx.lineWidth = strokeWidth;
              ctx.strokeStyle = strokeColor;
              ctx.lineJoin = 'round';
              ctx.lineCap = 'round';
              ctx.stroke(path);
              ctx.restore();

              const padding = Math.max(4, strokeWidth / 2);
              visiblePoints.forEach((point) => {
                interactionRegions.push({
                  type: 'circle',
                  cx: point.x,
                  cy: point.y,
                  r: circleRadius + padding,
                });
              });
            }
          } else if (pathType === PATH_TYPE_FILLED_POINT) {
            const circleRadius = Math.max(1, resolvedPointDiameter / 2);
            if (visiblePoints.length) {
              const path = new Path2D();

              visiblePoints.forEach((point) => {
                path.moveTo(point.x + circleRadius, point.y);
                path.arc(point.x, point.y, circleRadius, 0, Math.PI * 2);
              });

              ctx.save();
              ctx.fillStyle = strokeColor;
              ctx.fill(path);
              ctx.restore();

              const padding = Math.max(4, circleRadius / 2);
              visiblePoints.forEach((point) => {
                interactionRegions.push({
                  type: 'circle',
                  cx: point.x,
                  cy: point.y,
                  r: circleRadius + padding,
                });
              });
            }
          } else if (pathType === PATH_TYPE_RECTANGLE) {
            const rectWidth = Math.max(1, rectangleWidth);
            const rectHeight = Math.max(1, rectangleHeight);
            const halfWidth = Math.max(1, rectWidth / 2);
            const halfHeight = Math.max(1, rectHeight / 2);
            const strokeWidth = Math.max(2, Math.round(Math.max(rectWidth, rectHeight) / 10));
            if (visiblePoints.length) {
              const path = new Path2D();

              visiblePoints.forEach((point) => {
                path.rect(point.x - halfWidth, point.y - halfHeight, rectWidth, rectHeight);
              });

              ctx.save();
              ctx.lineWidth = strokeWidth;
              ctx.strokeStyle = strokeColor;
              ctx.lineJoin = 'round';
              ctx.lineCap = 'round';
              ctx.stroke(path);
              ctx.restore();

              const padding = Math.max(4, strokeWidth / 2);
              visiblePoints.forEach((point) => {
                interactionRegions.push({
                  type: 'rect',
                  left: point.x - halfWidth - padding,
                  right: point.x + halfWidth + padding,
                  top: point.y - halfHeight - padding,
                  bottom: point.y + halfHeight + padding,
                });
              });
            }
          } else if (pathType === PATH_TYPE_BREZER && pathPoints.length >= 2) {
            const path = new Path2D();
            path.moveTo(pathPoints[0].x, pathPoints[0].y);

            for (let i = 0; i < pathPoints.length - 1; i++) {
              const p0 = i === 0 ? pathPoints[0] : pathPoints[i - 1];
              const p1 = pathPoints[i];
              const p2 = pathPoints[i + 1];
              const p3 = i + 2 < pathPoints.length ? pathPoints[i + 2] : pathPoints[i + 1];

              const cp1x = p1.x + (p2.x - p0.x) / 6;
              const cp1y = p1.y + (p2.y - p0.y) / 6;
              const cp2x = p2.x - (p3.x - p1.x) / 6;
              const cp2y = p2.y - (p3.y - p1.y) / 6;

              path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
            }

            ctx.save();
            const strokeWidth = Math.max(6, Math.round(calculateRouteStrokeWidth(route, pathType)) || 6);
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke(path);
            ctx.restore();

            const padding = Math.max(6, strokeWidth / 2 + 4);
            for (let i = 0; i < pathPoints.length - 1; i += 1) {
              const start = pathPoints[i];
              const end = pathPoints[i + 1];
              if (!start || !end) {
                continue;
              }

              interactionRegions.push({
                type: 'segment',
                x1: start.x,
                y1: start.y,
                x2: end.x,
                y2: end.y,
                padding,
              });
            }
          }

          ctx.restore();
        });

        if (interactionRegions.length) {
          interactionRegions.forEach((region) => {
            if (!region) {
              return;
            }
            routeInteractionEntries.push({
              ...region,
              route,
            });
          });
        }
      }
      function handlePointerMove(event) {
        updatePointerInteraction(event);

        if ('pointerType' in event) {
          const pointerType = event.pointerType;
          if (pointerType && pointerType !== 'mouse' && pointerType !== 'pen') {
            canvas.style.cursor = '';
            return;
          }
        }

        const point = extractClientPoint(event);
        if (!point) {
          canvas.style.cursor = '';
          return;
        }

        const entry = getRouteEntryAtClientPoint(point.x, point.y);

        if (entry && entry.route) {
          canvas.style.cursor = 'pointer';
        } else {
          canvas.style.cursor = '';
          if (!pinnedRouteId) {
            hideTooltip();
          }
        }
      }

      function handlePointerLeave() {
        canvas.style.cursor = '';
        if (!pinnedRouteId) {
          hideTooltip();
        }
      }

      function handleCanvasPointerDown(event) {
        beginPointerInteraction(event);
      }

      function handleCanvasPointerUp(event) {
        const interaction = concludePointerInteraction(event);
        if (!interaction) {
          return;
        }

        if (interaction.dragging) {
          return;
        }

        const entry = getRouteEntryAtClientPoint(interaction.x, interaction.y);

        if (entry && entry.route) {
          const shouldFocusRoute = shouldFocusFromInteraction(event, entry);
          showTooltip(entry.route, interaction.x, interaction.y, { pin: true });
          if (shouldFocusRoute) {
            focusRoute(entry.route);
          }
        } else {
          resetLastFocusActivation();
          if (!pinnedRouteId) {
            hideTooltip({ force: true });
          }
        }
      }

      function handleCanvasPointerCancel() {
        cancelPointerInteraction();
      }

      function handleDocumentPointerDown(event) {
        if (!tooltip) {
          return;
        }

        if (event.target === canvas) {
          return;
        }

        if (tooltip.contains(event.target)) {
          return;
        }

        if (pinnedRouteId) {
          return;
        }

        hideTooltip({ force: true });
      }

      if ('PointerEvent' in window) {
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerleave', handlePointerLeave);
        canvas.addEventListener('pointerdown', handleCanvasPointerDown);
        document.addEventListener('pointerup', handleCanvasPointerUp);
        document.addEventListener('pointercancel', handleCanvasPointerCancel);
        document.addEventListener('pointerdown', handleDocumentPointerDown);
      } else {
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseleave', handlePointerLeave);
        canvas.addEventListener('mousedown', handleCanvasPointerDown);
        document.addEventListener('mouseup', handleCanvasPointerUp);
        canvas.addEventListener('touchstart', handleCanvasPointerDown);
        canvas.addEventListener('touchmove', handlePointerMove);
        document.addEventListener('touchend', handleCanvasPointerUp);
        document.addEventListener('touchcancel', handleCanvasPointerCancel);
        document.addEventListener('mousedown', handleDocumentPointerDown);
        document.addEventListener('touchstart', handleDocumentPointerDown);
      }

      setupTutorialInteractions();

      window.addEventListener('resize', resizeCanvas);

      if (backgroundImage.complete) {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      } else {
        resizeCanvas();
      }
    </script>
  </body>
</html>
