<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ascend</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #000;
        --wall-background: url('./location/New Wall.jpg');
        background-image: var(--wall-background);
        background-position: center;
        background-size: 100% 100%;
        background-repeat: no-repeat;
        background-attachment: fixed;
        color: #fff;
        overflow: hidden;
      }

      .hidden {
        display: none !important;
      }

      .canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .canvas-container.scrollable {
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
      }

      canvas {
        display: block;
        height: 100%;
        width: auto;
        min-width: 100%;
      }

      .auth-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        padding: 1.5rem;
        backdrop-filter: blur(2px);
        z-index: 10;
      }

      .auth-card {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1rem;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: min(90vw, 360px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      }

      .auth-card h1 {
        font-size: 1.4rem;
        text-align: center;
      }

      .auth-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.95rem;
      }

      .auth-field input {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        padding: 0.65rem 1rem;
        font-size: 1rem;
      }

      .auth-submit {
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1rem;
        background: #7ed957;
        color: #111;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .auth-submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
      }

      .auth-switch {
        font-size: 0.9rem;
        text-align: center;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        justify-content: center;
        align-items: center;
      }

      .auth-switch button {
        background: none;
        border: none;
        color: #7ed957;
        font-weight: 600;
        cursor: pointer;
        text-decoration: underline;
      }

      .auth-error {
        min-height: 1.25rem;
        color: #ff7a7a;
        text-align: center;
        font-size: 0.85rem;
      }

      .app-header {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 5;
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      .location-button {
        border: 1px solid rgba(255, 255, 255, 0.35);
        border-radius: 999px;
        padding: 0.6rem 1.25rem;
        font-size: 0.9rem;
        font-weight: 700;
        cursor: pointer;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
        color: #fff;
        backdrop-filter: blur(6px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .location-button:hover,
      .location-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
        outline: none;
      }

      .location-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(3px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        z-index: 20;
      }

      .location-modal.hidden {
        display: none !important;
      }

      .location-modal-content {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1.25rem;
        width: min(720px, 92vw);
        max-height: 90vh;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .location-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .location-modal-title {
        font-size: 1.35rem;
        font-weight: 700;
      }

      .location-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.4rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .location-modal-close:hover,
      .location-modal-close:focus-visible {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .location-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
      }

      .location-option {
        border: none;
        border-radius: 1rem;
        padding: 0;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        cursor: pointer;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        text-align: left;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .location-option:hover,
      .location-option:focus-visible {
        transform: translateY(-4px);
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.4);
        outline: none;
        background: rgba(255, 255, 255, 0.18);
      }

      .location-option[aria-current='true'] {
        box-shadow: 0 0 0 3px rgba(126, 217, 87, 0.75);
        background: rgba(126, 217, 87, 0.18);
      }

      .location-option-preview {
        position: relative;
        width: 100%;
        padding-top: 66%;
        background-size: cover;
        background-position: center;
      }

      .location-option-label {
        padding: 0.9rem 1rem;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      .info-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .info-button {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 2px solid rgba(126, 217, 87, 0.6);
        background: #7ed957;
        color: #0c1905;
        font-size: 1.05rem;
        font-weight: 700;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 22px rgba(126, 217, 87, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }

      .info-button:hover,
      .info-button:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 12px 28px rgba(126, 217, 87, 0.45);
        border-color: rgba(126, 217, 87, 0.9);
        outline: none;
      }

      .info-button:focus-visible {
        box-shadow: 0 0 0 4px rgba(126, 217, 87, 0.25), 0 12px 28px rgba(126, 217, 87, 0.45);
      }

      .info-popover {
        position: absolute;
        top: calc(100% + 0.75rem);
        right: 0;
        width: min(280px, 70vw);
        padding: 0.9rem 1rem;
        border-radius: 0.75rem;
        background: rgba(0, 0, 0, 0.85);
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.85rem;
        line-height: 1.4;
        text-align: left;
      }

      .info-popover p {
        color: rgba(255, 255, 255, 0.85);
      }

      .nav-links {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .nav-links a {
        padding: 0.55rem 0.95rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.18);
        color: #0c1905;
        font-size: 0.85rem;
        font-weight: 600;
        text-decoration: none;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background-image: linear-gradient(135deg, rgba(255, 255, 255, 0.85), rgba(255, 255, 255, 0.45));
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .nav-links a:hover,
      .nav-links a:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 10px 22px rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .sign-out {
        border: 1px solid rgba(255, 255, 255, 0.35);
        border-radius: 999px;
        padding: 0.6rem 1.25rem;
        font-size: 0.9rem;
        font-weight: 700;
        cursor: pointer;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.22), rgba(255, 255, 255, 0.08));
        color: #fff;
        backdrop-filter: blur(6px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .sign-out:hover,
      .sign-out:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
        outline: none;
      }

      .route-tooltip {
        --tooltip-accent: #7ed957;
        --tooltip-accent-rgb: 126, 217, 87;
        --tooltip-accent-soft: rgba(126, 217, 87, 0.18);
        --tooltip-accent-strong: rgba(126, 217, 87, 0.85);
        --tooltip-on-accent: #000;
        --tooltip-foreground: #fff;
        --tooltip-soft-foreground: #000;
        position: fixed;
        pointer-events: none;
        background: rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.72);
        color: var(--tooltip-foreground, #fff);
        padding: 0.75rem 1rem;
        border-radius: 0.75rem;
        border: 1px solid rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.45);
        box-shadow: 0 12px 30px rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.25);
        font-size: 0.85rem;
        line-height: 1.4;
        max-width: min(280px, 80vw);
        z-index: 6;
        opacity: 0;
        transform: translate(-50%, -12px);
        transition: opacity 0.12s ease, transform 0.12s ease;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .route-tooltip.pinned {
        pointer-events: auto;
      }

      .route-tooltip.visible {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      .route-tooltip .tooltip-title {
        display: block;
        font-size: 0.95rem;
        font-weight: 600;
      }

      .route-tooltip .tooltip-lines {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        white-space: pre-line;
      }

      .route-tooltip .tooltip-line {
        display: block;
      }

      .ascend-toggle {
        margin-top: 0.75rem;
        width: 100%;
        border: none;
        border-radius: 999px;
        padding: 0.6rem 1rem;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        background: var(--tooltip-accent-soft, rgba(126, 217, 87, 0.18));
        color: var(--tooltip-soft-foreground, var(--tooltip-accent, #7ed957));
      }

      .ascend-toggle:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 18px rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.25);
      }

      .ascend-toggle.ascended {
        background: var(--tooltip-accent-strong, rgba(126, 217, 87, 0.85));
        color: var(--tooltip-on-accent, #000);
        box-shadow: 0 10px 18px rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.25);
      }

      .grade-section {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        margin-top: 0.75rem;
      }

      .grade-form {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .grade-form label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.8rem;
        font-weight: 600;
      }

      .grade-form input[type='number'] {
        border-radius: 0.65rem;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        padding: 0.45rem 0.6rem;
        font-size: 0.85rem;
      }

      .grade-form input[type='number']:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .grade-form-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .grade-form button {
        border: none;
        border-radius: 999px;
        padding: 0.45rem 0.9rem;
        font-size: 0.8rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      .grade-form button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .grade-submit {
        background: var(--tooltip-accent-strong, rgba(126, 217, 87, 0.85));
        color: var(--tooltip-on-accent, #111);
      }

      .grade-submit:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 18px rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.25);
      }

      .grade-clear {
        background: rgba(255, 255, 255, 0.15);
        color: var(--tooltip-foreground, #fff);
      }

      .grade-clear:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 18px rgba(255, 255, 255, 0.2);
      }

      .grade-note {
        font-size: 0.75rem;
        color: var(--tooltip-foreground, rgba(255, 255, 255, 0.7));
      }

      .ascend-status {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-weight: 600;
        color: var(--tooltip-foreground, #fff);
      }

      .ascend-status::before {
        content: '✔';
        font-size: 0.9rem;
        color: inherit;
      }

      .ascend-status.not-ascended {
        opacity: 0.75;
      }

      .ascend-status.not-ascended::before {
        content: '○';
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <div id="authOverlay" class="auth-overlay" role="dialog" aria-modal="true" aria-labelledby="authTitle">
      <form id="authForm" class="auth-card">
        <h1 id="authTitle">Sign in to continue</h1>
        <label class="auth-field">
          <span>Username</span>
          <input id="authUsername" type="text" name="username" autocomplete="username" required />
        </label>
        <label class="auth-field">
          <span>Password</span>
          <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="6" required />
        </label>
        <p id="authError" class="auth-error" role="alert" aria-live="assertive"></p>
        <button type="submit" class="auth-submit">Sign In</button>
        <p class="auth-switch">
          <span id="authSwitchLabel">Don't have an account?</span>
          <button type="button" id="toggleAuthMode">Create one</button>
        </p>
      </form>
    </div>
    <div id="appContent" class="app hidden" aria-live="polite">
      <header class="app-header">
        <button id="locationButton" class="location-button" type="button" aria-haspopup="dialog">
          Select wall
        </button>
        <nav id="navLinks" class="nav-links" aria-label="Available pages">
          <a id="setterLink" class="hidden" href="setter.html">Setter Tools</a>
        </nav>
        <div class="info-wrapper">
          <button
            id="infoButton"
            class="info-button"
            type="button"
            aria-label="Learn about Ascend"
            aria-haspopup="dialog"
            aria-expanded="false"
            aria-controls="infoPopover"
          >
            i
          </button>
          <div
            id="infoPopover"
            class="info-popover hidden"
            role="dialog"
            aria-modal="false"
            aria-hidden="true"
            aria-label="About Ascend"
          >
            <p>Track which climbs you have completed.</p>
            <p>The height of each circle shows its difficulty based on community scoring.</p>
          </div>
        </div>
        <button id="signOutButton" class="sign-out">Sign out</button>
      </header>
      <div class="canvas-container">
        <canvas id="previewCanvas" aria-hidden="true"></canvas>
      </div>
    </div>
    <div
      id="routeTooltip"
      class="route-tooltip"
      role="status"
      aria-live="polite"
      aria-hidden="true"
    ></div>
    <div
      id="locationModal"
      class="location-modal hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="locationModalTitle"
    >
      <div class="location-modal-content">
        <div class="location-modal-header">
          <h2 id="locationModalTitle" class="location-modal-title">Select a wall</h2>
          <button id="locationModalClose" class="location-modal-close" type="button" aria-label="Close wall selector">
            ×
          </button>
        </div>
        <div id="locationOptions" class="location-options" role="listbox"></div>
      </div>
    </div>
    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
        updateProfile,
        deleteUser,
        getIdTokenResult,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        deleteDoc,
        serverTimestamp,
        collection,
        getDocs,
        query,
        limit,
        where,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
      import { firebaseConfig } from './config.js';

      const firebaseApp = initializeApp(firebaseConfig);
      const auth = getAuth(firebaseApp);

      const db = getFirestore(firebaseApp);

      const authOverlay = document.getElementById('authOverlay');
      const appContent = document.getElementById('appContent');
      const authForm = document.getElementById('authForm');
      const authUsername = document.getElementById('authUsername');
      const authPassword = document.getElementById('authPassword');
      const authError = document.getElementById('authError');
      const authTitle = document.getElementById('authTitle');
      const authSwitchLabel = document.getElementById('authSwitchLabel');
      const toggleAuthModeButton = document.getElementById('toggleAuthMode');
      const signOutButton = document.getElementById('signOutButton');
      const setterLink = document.getElementById('setterLink');
      const tooltip = document.getElementById('routeTooltip');
      const infoButton = document.getElementById('infoButton');
      const infoPopover = document.getElementById('infoPopover');
      const locationButton = document.getElementById('locationButton');
      const locationModal = document.getElementById('locationModal');
      const locationOptions = document.getElementById('locationOptions');
      const locationModalClose = document.getElementById('locationModalClose');

      const LOCATIONS = [
        { key: 'new-wall', name: 'New Wall', image: './location/New Wall.jpg' },
        { key: 'old-wall', name: 'Old Wall', image: './location/Old Wall.jpg' },
      ];

      const LOCATION_STORAGE_KEY = 'ascend.selectedLocation';

      const PATH_TYPE_BREZER = 'brezer';
      const PATH_TYPE_POINT = 'point';
      const DEFAULT_PATH_TYPE = PATH_TYPE_BREZER;
      const MIN_POINT_DIAMETER = 12;
      const MAX_POINT_DIAMETER = 160;
      const DEFAULT_POINT_DIAMETER = 48;
      const MIN_GRADE_BAR_HEIGHT = 0;
      const MAX_GRADE_BAR_HEIGHT = 320;
      const DEFAULT_GRADE_BAR_BASE_HEIGHT = 16;
      const DEFAULT_GRADE_BAR_MAX_HEIGHT = 96;
      const GRADE_SCALE_MIN = 1;
      const GRADE_SCALE_MAX = 25;
      const WALL_COLLECTION = 'walls';

      function normalizePathType(value) {
        if (typeof value === 'string') {
          const normalized = value.trim().toLowerCase();
          if (normalized === PATH_TYPE_POINT) {
            return PATH_TYPE_POINT;
          }
        }
        return DEFAULT_PATH_TYPE;
      }

      function normalizePointDiameter(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_POINT_DIAMETER;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_POINT_DIAMETER),
          MAX_POINT_DIAMETER,
        );
        return clamped;
      }

      function clampGradeBarHeight(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_BASE_HEIGHT;
        }
        return Math.min(
          Math.max(Math.round(numeric), MIN_GRADE_BAR_HEIGHT),
          MAX_GRADE_BAR_HEIGHT,
        );
      }

      function normalizeGradeBarHeight(value, fallback) {
        const fallbackValue = Number.isFinite(fallback)
          ? clampGradeBarHeight(fallback)
          : clampGradeBarHeight(DEFAULT_GRADE_BAR_BASE_HEIGHT);
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallbackValue;
        }
        return clampGradeBarHeight(numeric);
      }

      function normalizeWallSettings(raw = {}) {
        if (!raw || typeof raw !== 'object') {
          return {
            pointDiameter: DEFAULT_POINT_DIAMETER,
            gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
            gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
          };
        }

        const gradeBarBaseHeight = normalizeGradeBarHeight(
          raw.gradeBarBaseHeight,
          DEFAULT_GRADE_BAR_BASE_HEIGHT,
        );
        const gradeBarMaxHeightCandidate = normalizeGradeBarHeight(
          raw.gradeBarMaxHeight,
          DEFAULT_GRADE_BAR_MAX_HEIGHT,
        );
        return {
          pointDiameter: normalizePointDiameter(raw.pointDiameter),
          gradeBarBaseHeight,
          gradeBarMaxHeight: Math.max(gradeBarBaseHeight, gradeBarMaxHeightCandidate),
        };
      }

      const wallSettingsCache = new Map();

      const normalizeLocationName = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      const normalizeWallKey = (value) => normalizeLocationName(value);

      function resolveWallSettings(locationKey, fallback = null) {
        const key = normalizeWallKey(locationKey);
        if (key) {
          const cached = wallSettingsCache.get(key);
          if (cached) {
            return { ...cached };
          }
        }

        if (fallback) {
          const normalized = normalizeWallSettings(fallback);
          if (key) {
            wallSettingsCache.set(key, normalized);
          }
          return normalized;
        }

        return {
          pointDiameter: DEFAULT_POINT_DIAMETER,
          gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
          gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
        };
      }

      const findLocationByKey = (key) => LOCATIONS.find((location) => location.key === key);

      const findLocationByName = (name) => {
        const normalized = normalizeLocationName(name);
        return (
          LOCATIONS.find((location) => normalizeLocationName(location.name) === normalized) ||
          null
        );
      };

      function upsertLocation({ key = '', name = '', image = '', fallbackName = '' } = {}) {
        const trimmedName = typeof name === 'string' && name.trim() ? name.trim() : '';
        const fallback =
          trimmedName || (typeof fallbackName === 'string' && fallbackName.trim() ? fallbackName.trim() : '');
        const keySource = typeof key === 'string' && key.trim() ? key.trim() : fallback;
        const normalizedKey = normalizeWallKey(keySource);
        const displayName = fallback;
        if (!normalizedKey || !displayName) {
          return { entry: null, changed: false };
        }

        const normalizedImage = typeof image === 'string' ? image.trim() : '';
        const existingIndex = LOCATIONS.findIndex((location) => {
          if (!location) {
            return false;
          }
          if (location.key === normalizedKey) {
            return true;
          }
          return normalizeLocationName(location.name) === normalizeLocationName(displayName);
        });

        if (existingIndex >= 0) {
          const existing = LOCATIONS[existingIndex];
          const needsUpdate =
            existing.key !== normalizedKey || existing.name !== displayName || existing.image !== normalizedImage;

          if (!needsUpdate) {
            return { entry: existing, changed: false };
          }

          const updated = { ...existing, key: normalizedKey, name: displayName, image: normalizedImage };
          LOCATIONS[existingIndex] = updated;
          return { entry: updated, changed: true };
        }

        const created = { key: normalizedKey, name: displayName, image: normalizedImage };
        LOCATIONS.push(created);
        return { entry: created, changed: true };
      }

      function synchronizeCurrentLocationReference() {
        if (!currentLocation) {
          return;
        }

        const normalizedKey = normalizeWallKey(currentLocation.key || currentLocation.name);
        const refreshed =
          (normalizedKey && findLocationByKey(normalizedKey)) ||
          findLocationByName(currentLocation.name);

        if (refreshed && refreshed !== currentLocation) {
          currentLocation = refreshed;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          updateBackgroundForCurrentLocation();
        }
      }

      const DEFAULT_LOCATION = LOCATIONS[0];

      let currentLocation = DEFAULT_LOCATION;

      let backgroundReady = false;
      let backgroundImageSource = '';

      const backgroundImage = new Image();

      function updateLocationButtonLabel() {
        if (!locationButton) {
          return;
        }

        locationButton.textContent = currentLocation?.name || 'Select wall';
      }

      function updateLocationOptionsState() {
        if (!locationOptions) {
          return;
        }

        const buttons = locationOptions.querySelectorAll('[data-location-key]');
        buttons.forEach((button) => {
          const key = button?.dataset?.locationKey;
          if (key && currentLocation && key === currentLocation.key) {
            button.setAttribute('aria-current', 'true');
          } else {
            button.removeAttribute('aria-current');
          }
        });
      }

      function applyBodyBackground(imagePath) {
        if (!document.body) {
          return;
        }

        if (imagePath) {
          document.body.style.setProperty('--wall-background', `url('${imagePath}')`);
        } else {
          document.body.style.removeProperty('--wall-background');
        }
      }

      function updateBackgroundForCurrentLocation() {
        const imagePath = currentLocation?.image || '';
        applyBodyBackground(imagePath);

        if (imagePath && imagePath !== backgroundImageSource) {
          backgroundImageSource = imagePath;
          backgroundReady = false;
          backgroundImage.src = imagePath;
        } else if (!imagePath) {
          backgroundImageSource = '';
          backgroundReady = false;
        }
      }

      backgroundImage.onload = () => {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      };

      backgroundImage.onerror = () => {
        backgroundReady = false;
        resizeCanvas();
      };

      function closeLocationModal() {
        if (!locationModal) {
          return;
        }

        if (!locationModal.classList.contains('hidden')) {
          locationModal.classList.add('hidden');
          locationModal.setAttribute('aria-hidden', 'true');
          locationButton?.setAttribute('aria-expanded', 'false');
        }
      }

      function openLocationModal() {
        if (!locationModal) {
          return;
        }

        locationModal.classList.remove('hidden');
        locationModal.setAttribute('aria-hidden', 'false');
        locationButton?.setAttribute('aria-expanded', 'true');
        updateLocationOptionsState();
      }

      function handleLocationSelection(locationKey) {
        const location = findLocationByKey(locationKey);
        if (!location) {
          return;
        }

        const changed = !currentLocation || currentLocation.key !== location.key;
        currentLocation = location;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();

        try {
          window.localStorage?.setItem(LOCATION_STORAGE_KEY, location.key);
        } catch (error) {
          console.warn('Unable to persist location preference:', error);
        }

        if (changed) {
          applyLocationFilter();
        }

        closeLocationModal();
      }

      function renderLocationOptions() {
        if (!locationOptions) {
          return;
        }

        locationOptions.replaceChildren();

        LOCATIONS.forEach((location) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'location-option';
          button.dataset.locationKey = location.key;
          button.setAttribute('role', 'option');

          const preview = document.createElement('div');
          preview.className = 'location-option-preview';
          preview.style.backgroundImage = `url('${location.image}')`;
          button.appendChild(preview);

          const label = document.createElement('span');
          label.className = 'location-option-label';
          label.textContent = location.name;
          button.appendChild(label);

          button.addEventListener('click', () => {
            handleLocationSelection(location.key);
          });

          locationOptions.appendChild(button);
        });

        updateLocationOptionsState();
      }

      const SYNTHETIC_EMAIL_DOMAIN = 'users.anuascend.local';
      const USERNAME_PATTERN = /^[a-z0-9_]{3,20}$/;

      const normalizeUsername = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      function cacheAuthenticatedUsername(username) {
        const normalized = normalizeUsername(username);
        authenticatedUsernameClaim = isValidUsername(normalized) ? normalized : '';
        return authenticatedUsernameClaim;
      }

      async function resolveAuthenticatedUsername(options = {}) {
        const { forceRefresh = false } = options;

        if (!currentUser) {
          authenticatedUsernameClaim = '';
          return isValidUsername(currentUsername) ? normalizeUsername(currentUsername) : '';
        }

        if (!forceRefresh) {
          const cachedClaim = normalizeUsername(authenticatedUsernameClaim);
          if (isValidUsername(cachedClaim)) {
            return cachedClaim;
          }
        }

        const fallbackUsername = isValidUsername(currentUsername)
          ? normalizeUsername(currentUsername)
          : '';

        try {
          const tokenResult = await getIdTokenResult(currentUser, forceRefresh);
          const claimUsername = normalizeUsername(tokenResult?.claims?.username);

          if (isValidUsername(claimUsername)) {
            return cacheAuthenticatedUsername(claimUsername);
          }
        } catch (error) {
          console.warn(
            forceRefresh
              ? 'Failed to refresh authenticated username claim:'
              : 'Failed to read authenticated username claim:',
            error,
          );
        }

        if (!forceRefresh) {
          return resolveAuthenticatedUsername({ forceRefresh: true });
        }

        if (fallbackUsername) {
          return cacheAuthenticatedUsername(fallbackUsername);
        }

        return '';
      }

      const buildSyntheticEmail = (username) => {
        const normalized = normalizeUsername(username);
        return normalized ? `${normalized}@${SYNTHETIC_EMAIL_DOMAIN}` : '';
      };

      const isValidUsername = (value) => USERNAME_PATTERN.test(normalizeUsername(value));

      const tooltipColorCanvas = document.createElement('canvas');
      const tooltipColorContext = tooltipColorCanvas.getContext('2d');

      function getTextColor(bgColor) {
        const context = document.createElement('canvas').getContext('2d');
        if (!context) {
          return '#fff';
        }

        context.fillStyle = '#000';
        context.fillStyle = bgColor;
        const values = context.fillStyle.match(/\d+/g);

        if (!values || values.length < 3) {
          return '#fff';
        }

        const [r, g, b] = values.map(Number);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        return luminance > 0.5 ? '#000' : '#fff';
      }

      function parseTooltipColor(color) {
        if (!tooltipColorContext || typeof color !== 'string') {
          return null;
        }

        let normalized;
        try {
          tooltipColorContext.fillStyle = '#000000';
          tooltipColorContext.fillStyle = color;
          normalized = tooltipColorContext.fillStyle;
        } catch (error) {
          return null;
        }

        if (typeof normalized !== 'string' || !normalized) {
          return null;
        }

        if (/^#[0-9a-f]{6}$/i.test(normalized)) {
          const r = parseInt(normalized.slice(1, 3), 16);
          const g = parseInt(normalized.slice(3, 5), 16);
          const b = parseInt(normalized.slice(5, 7), 16);
          return { r, g, b, hex: normalized };
        }

        const rgbaMatch = normalized
          .replace(/\s+/g, '')
          .match(/^rgba?\((\d+),(\d+),(\d+)(?:,(0|1|0?\.\d+))?\)$/i);

        if (rgbaMatch) {
          const [, r, g, b] = rgbaMatch;
          return {
            r: Number.parseInt(r, 10),
            g: Number.parseInt(g, 10),
            b: Number.parseInt(b, 10),
            hex: null,
          };
        }

        return null;
      }

      function deriveTooltipColorScheme(color) {
        const parsed = parseTooltipColor(color);

        if (!parsed) {
          return null;
        }

        const clamp = (value) => Math.max(0, Math.min(255, value));
        const r = clamp(parsed.r);
        const g = clamp(parsed.g);
        const b = clamp(parsed.b);
        const rgbString = `${r}, ${g}, ${b}`;
        const accent = parsed.hex ? parsed.hex : `rgb(${rgbString})`;
        const soft = `rgba(${rgbString}, 0.18)`;
        const strong = `rgba(${rgbString}, 0.85)`;
        const tooltipBackground = `rgba(${rgbString}, 0.72)`;
        const onAccent = getTextColor(strong);
        const foreground = getTextColor(tooltipBackground);
        const softForeground = getTextColor(soft);

        return {
          accent,
          rgb: rgbString,
          soft,
          strong,
          onAccent,
          foreground,
          softForeground,
        };
      }

      const FALLBACK_TOOLTIP_SCHEME = (() => {
        const defaultRgb = '126, 217, 87';
        const soft = 'rgba(126, 217, 87, 0.18)';
        const strong = 'rgba(126, 217, 87, 0.85)';
        const tooltipBackground = 'rgba(126, 217, 87, 0.72)';

        return {
          accent: '#7ed957',
          rgb: defaultRgb,
          soft,
          strong,
          onAccent: getTextColor(strong),
          foreground: getTextColor(tooltipBackground),
          softForeground: getTextColor(soft),
        };
      })();

      const DEFAULT_TOOLTIP_SCHEME =
        deriveTooltipColorScheme('#7ed957') ?? FALLBACK_TOOLTIP_SCHEME;

      function applyTooltipColorScheme(route) {
        if (!tooltip) {
          return;
        }

        const base = DEFAULT_TOOLTIP_SCHEME;
        const scheme = deriveTooltipColorScheme(route?.strokeColor) ?? base;

        const accent = scheme.accent ?? base.accent;
        const rgb = scheme.rgb ?? base.rgb;
        const soft = scheme.soft ?? base.soft;
        const strong = scheme.strong ?? base.strong;
        const onAccent = scheme.onAccent ?? base.onAccent;
        const foreground = scheme.foreground ?? base.foreground;
        const softForeground = scheme.softForeground ?? base.softForeground;

        tooltip.style.setProperty('--tooltip-accent', accent);
        tooltip.style.setProperty('--tooltip-accent-rgb', rgb);
        tooltip.style.setProperty('--tooltip-accent-soft', soft);
        tooltip.style.setProperty('--tooltip-accent-strong', strong);
        tooltip.style.setProperty('--tooltip-on-accent', onAccent);
        tooltip.style.setProperty('--tooltip-foreground', foreground);
        tooltip.style.setProperty('--tooltip-soft-foreground', softForeground);
      }

      function closeInfoPopover() {
        if (!infoPopover) {
          return;
        }

        if (!infoPopover.classList.contains('hidden')) {
          infoPopover.classList.add('hidden');
          infoPopover.setAttribute('aria-hidden', 'true');
          if (infoButton) {
            infoButton.setAttribute('aria-expanded', 'false');
          }
        }
      }

      function toggleInfoPopover() {
        if (!infoPopover || !infoButton) {
          return;
        }

        const isHidden = infoPopover.classList.contains('hidden');
        if (isHidden) {
          infoPopover.classList.remove('hidden');
          infoPopover.setAttribute('aria-hidden', 'false');
          infoButton.setAttribute('aria-expanded', 'true');
        } else {
          closeInfoPopover();
        }
      }

      if (infoButton && infoPopover) {
        infoButton.addEventListener('click', (event) => {
          event.stopPropagation();
          toggleInfoPopover();
        });

        infoPopover.addEventListener('click', (event) => {
          event.stopPropagation();
        });

        document.addEventListener('click', () => {
          closeInfoPopover();
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            closeInfoPopover();
          }
        });
      }

      renderLocationOptions();

      let storedLocationKey = null;
      try {
        storedLocationKey = window.localStorage?.getItem(LOCATION_STORAGE_KEY) || null;
      } catch (error) {
        console.warn('Unable to read location preference:', error);
      }

      const storedLocation = storedLocationKey ? findLocationByKey(storedLocationKey) : null;
      if (storedLocation) {
        currentLocation = storedLocation;
      }

      updateLocationButtonLabel();
      updateLocationOptionsState();
      if (locationButton) {
        locationButton.setAttribute('aria-expanded', 'false');
      }
      updateBackgroundForCurrentLocation();

      if (locationButton) {
        locationButton.addEventListener('click', (event) => {
          event.preventDefault();
          openLocationModal();
        });
      }

      if (locationModalClose) {
        locationModalClose.addEventListener('click', (event) => {
          event.preventDefault();
          closeLocationModal();
        });
      }

      if (locationModal) {
        locationModal.addEventListener('click', (event) => {
          if (event.target === locationModal) {
            closeLocationModal();
          }
        });
      }

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeLocationModal();
        }
      });

      let authMode = 'login';
      let currentUser = null;
      let currentUsername = '';
      let authenticatedUsernameClaim = '';
      
      function setAuthMode(mode) {
        authMode = mode;
        const isLogin = authMode === 'login';
        authTitle.textContent = isLogin ? 'Sign in to continue' : 'Create your account';
        authSwitchLabel.textContent = isLogin ? "Don't have an account?" : 'Already have an account?';
        toggleAuthModeButton.textContent = isLogin ? 'Create one' : 'Sign in';
        authForm.querySelector('.auth-submit').textContent = isLogin ? 'Sign In' : 'Create Account';
        authPassword.setAttribute('autocomplete', isLogin ? 'current-password' : 'new-password');
        authError.textContent = '';
      }

      toggleAuthModeButton.addEventListener('click', () => {
        setAuthMode(authMode === 'login' ? 'register' : 'login');
      });

      async function lookupUsernameByUid(uid) {
        if (!uid) {
          return '';
        }

        try {
          const snapshot = await getDocs(
            query(collection(db, 'usernames'), where('uid', '==', uid), limit(1)),
          );

          if (snapshot.empty) {
            return '';
          }

          const docSnap = snapshot.docs[0];
          const data = docSnap.data() || {};
          const fromField = normalizeUsername(data.username);
          const fromId = normalizeUsername(docSnap.id);
          return fromField || fromId;
        } catch (error) {
          console.error('Failed to look up username by UID:', error);
          return '';
        }
      }

      async function resolveUsernameForUser(user) {
        if (!user) {
          return '';
        }

        const displayName = normalizeUsername(user.displayName);
        if (isValidUsername(displayName)) {
          return displayName;
        }

        const mapped = await lookupUsernameByUid(user.uid);
        if (isValidUsername(mapped)) {
          if (!displayName) {
            try {
              await updateProfile(user, { displayName: mapped });
            } catch (error) {
              console.warn('Unable to synchronise display name with username:', error);
            }
          }
          return mapped;
        }

        const syntheticEmail = typeof user.email === 'string' ? user.email : '';
        if (syntheticEmail.endsWith(`@${SYNTHETIC_EMAIL_DOMAIN}`)) {
          const derived = normalizeUsername(
            syntheticEmail.slice(0, -(`@${SYNTHETIC_EMAIL_DOMAIN}`.length)),
          );
          if (isValidUsername(derived)) {
            return derived;
          }
        }

        return '';
      }

      authForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        authError.textContent = '';

        const rawUsername = authUsername.value;
        const normalizedUsername = normalizeUsername(rawUsername);
        const password = authPassword.value;

        if (!normalizedUsername) {
          authError.textContent = 'Enter your username to continue.';
          return;
        }

        if (!isValidUsername(normalizedUsername)) {
          authError.textContent =
            'Usernames must be 3-20 characters using only letters, numbers, or underscores.';
          return;
        }

        const syntheticEmail = buildSyntheticEmail(normalizedUsername);

        try {
          if (authMode === 'login') {
            await signInWithEmailAndPassword(auth, syntheticEmail, password);
            return;
          }

          const credentials = await createUserWithEmailAndPassword(auth, syntheticEmail, password);
          const { user } = credentials;

          try {
            await setDoc(doc(db, 'usernames', normalizedUsername), {
              uid: user.uid,
              username: normalizedUsername,
              createdAt: serverTimestamp(),
              updatedAt: serverTimestamp(),
            });
          } catch (error) {
            console.error('Failed to reserve username:', error);
            try {
              await deleteUser(user);
            } catch (cleanupError) {
              console.warn('Unable to clean up user after username failure:', cleanupError);
            }
            const usernameError = new Error('Username unavailable');
            usernameError.code = 'auth/username-unavailable';
            throw usernameError;
          }

          try {
            await updateProfile(user, { displayName: normalizedUsername });
          } catch (profileError) {
            console.warn('Failed to update display name:', profileError);
          }
        } catch (error) {
          let message = 'Unable to complete the request. Please try again.';

          switch (error?.code) {
            case 'auth/user-not-found':
            case 'auth/wrong-password':
              message = 'Invalid username or password.';
              break;
            case 'auth/email-already-in-use':
            case 'auth/username-unavailable':
            case 'permission-denied':
              message = 'That username is already taken. Choose another one.';
              break;
            case 'auth/invalid-email':
              message = 'Enter a valid username.';
              break;
            case 'auth/weak-password':
              message = 'Choose a stronger password (at least 6 characters).';
              break;
            default:
              if (error?.message) {
                message = error.message;
              }
          }

          authError.textContent = message;
        }
      });

      signOutButton.addEventListener('click', () => {
        signOut(auth).catch((error) => {
          console.error('Failed to sign out:', error);
        });
      });

      async function ensureUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return { role: 'default' };
        }

        const roleRef = doc(db, 'roles', user.uid);
        const existingSnap = await getDoc(roleRef);

        if (existingSnap.exists()) {
          const existingData = existingSnap.data() || {};
          const storedLowerRaw =
            typeof existingData.usernameLower === 'string'
              ? existingData.usernameLower
              : typeof existingData.username === 'string'
              ? existingData.username
              : '';
          let effectiveLower = normalizeUsername(storedLowerRaw);
          const trimmedRole =
            typeof existingData.role === 'string' ? existingData.role.trim() : 'default';
          const mergedData = {
            ...existingData,
            role: trimmedRole,
          };

          if (effectiveLower !== normalizedUsername || !existingData.username) {
            try {
              await setDoc(
                roleRef,
                {
                  username: normalizedUsername,
                  usernameLower: normalizedUsername,
                  updatedAt: serverTimestamp(),
                },
                { merge: true },
              );
              mergedData.username = normalizedUsername;
              mergedData.usernameLower = normalizedUsername;
              effectiveLower = normalizedUsername;
            } catch (error) {
              console.warn('Failed to synchronise username on role document:', error);
            }
          }

          if (effectiveLower !== normalizedUsername) {
            mergedData.role = 'default';
          }

          return mergedData;
        }

        let role = 'default';

        try {
          const snapshot = await getDocs(
            query(collection(db, 'roles'), where('role', '==', 'setter'), limit(1)),
          );
          if (snapshot.empty) {
            role = 'setter';
          }
        } catch (error) {
          console.warn('Unable to inspect existing roles:', error);
        }

        const roleData = {
          role,
          username: normalizedUsername,
          usernameLower: normalizedUsername,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        };

        await setDoc(roleRef, roleData, { merge: true });
        return roleData;
      }

      async function resolveUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return 'default';
        }

        try {
          const ensuredRole = await ensureUserRole(user, normalizedUsername);
          return typeof ensuredRole?.role === 'string' ? ensuredRole.role.trim() : 'default';
        } catch (error) {
          console.error('Failed to fetch user role:', error);
          return 'default';
        }
      }

      function updateNavigationForRole(role) {
        setterLink.classList.toggle('hidden', role !== 'setter');
      }

      onAuthStateChanged(auth, async (user) => {
        if (user) {
          authOverlay.classList.add('hidden');

          currentUser = user;

          const resolvedUsername = await resolveUsernameForUser(user);
          if (!isValidUsername(resolvedUsername)) {
            authError.textContent =
              'Unable to resolve your username. Please contact a setter for assistance.';
            await signOut(auth);
            return;
          }

          currentUsername = normalizeUsername(resolvedUsername);
          authenticatedUsernameClaim = '';
          const canonicalUsername = await resolveAuthenticatedUsername();
          if (isValidUsername(canonicalUsername)) {
            currentUsername = canonicalUsername;
          }

          const role = await resolveUserRole(user, currentUsername);

          updateNavigationForRole(role);
          appContent.classList.remove('hidden');
          await loadAscents({ userId: user.uid, username: currentUsername });
          await loadRoutes();
        } else {
          authOverlay.classList.remove('hidden');
          appContent.classList.add('hidden');
          setterLink.classList.add('hidden');
          authForm.reset();
          setAuthMode('login');
          routes = [];
          currentUser = null;
          currentUsername = '';
          authenticatedUsernameClaim = '';
          ascendedRoutes.clear();
          routeGrades.clear();
          routeMedianGrades = new Map();
          hideTooltip({ force: true });
          redraw();
        }
      });

      setAuthMode('login');

      const canvasContainer = document.querySelector('.canvas-container');
      const canvas = document.getElementById('previewCanvas');
      const ctx = canvas.getContext('2d');

      const DEFAULT_CANVAS_ASPECT_RATIO = 1536 / 1024;
      let canvasAspectRatio = DEFAULT_CANVAS_ASPECT_RATIO;
      let isHorizontalScrollEnabled = false;

      let allRoutes = [];
      let routes = [];
      let routePaths = [];
      let gradeBarPlacements = [];
      let activeRouteId = null;
      let pinnedRouteId = null;
      let pinnedPosition = null;
      const ascendedRoutes = new Set();
      const routeGrades = new Map();
      let userAscentDetails = new Map();
      let routeMedianGrades = new Map();

      function clampGradeBarLeft(preferredLeft, width) {
        const numericWidth = Number(width);
        const resolvedWidth = Number.isFinite(numericWidth) ? Math.max(2, Math.round(numericWidth)) : 2;
        const maxLeft = Math.max(0, canvas.width - resolvedWidth);

        if (!Number.isFinite(preferredLeft)) {
          return Math.min(Math.max(0, Math.round(maxLeft / 2)), maxLeft);
        }

        return Math.min(Math.max(0, Math.round(preferredLeft)), maxLeft);
      }

      function resolveGradeBarPlacement(preferredLeft, width) {
        const spacing = 6;
        const sanitizedWidth = Number.isFinite(width) ? Math.max(2, Math.round(width)) : 2;
        const baseLeft = clampGradeBarLeft(preferredLeft, sanitizedWidth);
        const step = Math.max(4, sanitizedWidth + spacing);
        const maxShifts = 32;
        const offsets = [0];

        for (let distance = 1; distance <= maxShifts; distance += 1) {
          offsets.push(distance, -distance);
        }

        const halfSpacing = spacing / 2;

        for (const offset of offsets) {
          const candidateLeft = clampGradeBarLeft(baseLeft + offset * step, sanitizedWidth);
          const candidateRight = candidateLeft + sanitizedWidth;
          const overlaps = gradeBarPlacements.some((placement) => (
            candidateRight > placement.left - halfSpacing && candidateLeft < placement.right + halfSpacing
          ));

          if (!overlaps) {
            const placement = { left: candidateLeft, right: candidateRight };
            gradeBarPlacements.push(placement);
            return placement;
          }
        }

        const fallbackPlacement = { left: baseLeft, right: baseLeft + sanitizedWidth };
        gradeBarPlacements.push(fallbackPlacement);
        return fallbackPlacement;
      }

      function synchroniseAscentsWithRoutes(options = {}) {
        const { shouldRedraw = true } = options;
        ascendedRoutes.clear();
        routeGrades.clear();

        if (!Array.isArray(routes) || routes.length === 0) {
          if (shouldRedraw) {
            redraw();
          }
          return;
        }

        routes.forEach((route) => {
          if (!route?.id) {
            return;
          }

          const ascent = userAscentDetails.get(route.id);
          if (!ascent || !ascent.ascended) {
            return;
          }

          ascendedRoutes.add(route.id);
          if (typeof ascent.grade === 'number' && Number.isFinite(ascent.grade)) {
            routeGrades.set(route.id, ascent.grade);
          }
        });

        if (shouldRedraw) {
          redraw();
        }
      }

      async function loadAscents({ userId, username }) {
        ascendedRoutes.clear();
        routeGrades.clear();
        userAscentDetails = new Map();

        const normalizedUserId = typeof userId === 'string' ? userId.trim() : '';
        const normalizedUsername = normalizeUsername(username);
        const hasValidUsername = isValidUsername(normalizedUsername);
        if (!normalizedUserId && !hasValidUsername) {
          return;
        }

        try {
          let ascentData = null;

          if (normalizedUserId) {
            const ascentRef = doc(db, 'ascents', normalizedUserId);
            const ascentSnap = await getDoc(ascentRef);
            if (ascentSnap.exists()) {
              ascentData = ascentSnap.data() ?? {};
            }

            if (!ascentData && hasValidUsername && normalizedUsername !== normalizedUserId) {
              const legacyRef = doc(db, 'ascents', normalizedUsername);
              const legacySnap = await getDoc(legacyRef);

              if (legacySnap.exists()) {
                ascentData = legacySnap.data() ?? {};

                try {
                  const migrationPayload = {
                    ...ascentData,
                    climber_uid: normalizedUserId,
                    updatedAt: serverTimestamp(),
                  };

                  if (hasValidUsername) {
                    migrationPayload.climber_username = normalizedUsername;
                  }

                  await setDoc(ascentRef, migrationPayload, { merge: true });
                } catch (migrationError) {
                  console.warn('Failed to migrate legacy ascent document to UID path:', migrationError);
                }
              }
            }
          }

          if (!ascentData && hasValidUsername && normalizedUsername !== normalizedUserId) {
            const ascentRef = doc(db, 'ascents', normalizedUsername);
            const ascentSnap = await getDoc(ascentRef);

            if (!ascentSnap.exists()) {
              return;
            }

            ascentData = ascentSnap.data() ?? {};
          }

          if (!ascentData) {
            return;
          }

          const routesData = ascentData.routes;

          if (routesData && typeof routesData === 'object') {
            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!routeId || !details) {
                return;
              }

              const gradeValue = normalizeGradeValue(details?.grade);
              userAscentDetails.set(routeId, {
                ascended: true,
                grade: gradeValue,
              });
            });

            synchroniseAscentsWithRoutes();
            return;
          }

          const singleRouteId = typeof ascentData.route_id === 'string' ? ascentData.route_id : null;
          if (singleRouteId) {
            userAscentDetails.set(singleRouteId, { ascended: true, grade: null });
            synchroniseAscentsWithRoutes();
            return;
          }
        } catch (error) {
          console.error('Failed to load ascents:', error);
        }

        synchroniseAscentsWithRoutes();
      }

      function normalizeDate(value) {
        if (!value) {
          return null;
        }

        if (typeof value === 'string') {
          const date = new Date(value);
          return Number.isNaN(date.getTime()) ? null : date.toISOString();
        }

        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }

        if (typeof value?.toDate === 'function') {
          const date = value.toDate();
          if (date instanceof Date && !Number.isNaN(date.getTime())) {
            return date.toISOString();
          }
          return null;
        }

        return null;
      }

      function formatDisplayDate(isoString) {
        if (!isoString) {
          return 'Unknown';
        }

        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return 'Unknown';
        }

        return date.toLocaleDateString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
        });
      }

      function normalizeGradeValue(value) {
        if (value === null || value === undefined) {
          return null;
        }

        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return null;
        }

        if (!Number.isInteger(numeric)) {
          return null;
        }

        if (numeric < 1 || numeric > 25) {
          return null;
        }

        return numeric;
      }

      function formatGradeDisplay(value) {
        if (typeof value !== 'number' || !Number.isFinite(value)) {
          return '—';
        }

        return Number.isInteger(value) ? String(value) : value.toFixed(1);
      }

      function getUserGradeForRoute(routeId) {
        if (!routeId) {
          return null;
        }

        const stored = routeGrades.get(routeId);
        return typeof stored === 'number' && Number.isFinite(stored) ? stored : null;
      }

      function buildGradeControls(route) {
        if (!route || !route.id) {
          return null;
        }

        const container = document.createElement('div');
        container.className = 'grade-section';

        const gradeForm = document.createElement('form');
        gradeForm.className = 'grade-form';
        gradeForm.noValidate = true;

        const gradeLabel = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.textContent = 'Your grade (1-25)';
        gradeLabel.appendChild(labelText);

        const gradeInput = document.createElement('input');
        gradeInput.type = 'number';
        gradeInput.min = '1';
        gradeInput.max = '25';
        gradeInput.step = '1';
        gradeInput.inputMode = 'numeric';
        const existingGrade = getUserGradeForRoute(route.id);
        gradeInput.value = existingGrade !== null ? String(existingGrade) : '';
        gradeInput.placeholder = '—';
        gradeLabel.appendChild(gradeInput);

        gradeForm.appendChild(gradeLabel);

        const actions = document.createElement('div');
        actions.className = 'grade-form-actions';

        const saveButton = document.createElement('button');
        saveButton.type = 'submit';
        saveButton.className = 'grade-submit';
        saveButton.textContent = 'Save grade';

        const clearButton = document.createElement('button');
        clearButton.type = 'button';
        clearButton.className = 'grade-clear';
        clearButton.textContent = 'Clear grade';
        const hasExistingGrade = typeof existingGrade === 'number' && Number.isFinite(existingGrade);
        clearButton.disabled = !hasExistingGrade;

        actions.appendChild(saveButton);
        actions.appendChild(clearButton);
        gradeForm.appendChild(actions);

        const isAscended = ascendedRoutes.has(route.id);
        if (!isAscended) {
          gradeInput.disabled = true;
          saveButton.disabled = true;
          clearButton.disabled = true;
        }

        gradeForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          event.stopPropagation();

          if (!ascendedRoutes.has(route.id)) {
            return;
          }

          const rawValue = gradeInput.value.trim();
          if (!rawValue) {
            gradeInput.setCustomValidity('');
            await applyUserRouteGrade(route, null);
            gradeInput.value = '';
            return;
          }

          const parsed = normalizeGradeValue(rawValue);
          if (parsed === null) {
            gradeInput.setCustomValidity('Enter a whole number between 1 and 25.');
            gradeInput.reportValidity();
            return;
          }

          gradeInput.setCustomValidity('');
          await applyUserRouteGrade(route, parsed);
        });

        clearButton.addEventListener('click', async (event) => {
          event.preventDefault();
          event.stopPropagation();

          if (!ascendedRoutes.has(route.id)) {
            return;
          }

          gradeInput.value = '';
          gradeInput.setCustomValidity('');
          await applyUserRouteGrade(route, null);
        });

        container.appendChild(gradeForm);

        if (!isAscended) {
          const note = document.createElement('p');
          note.className = 'grade-note';
          note.textContent = 'Mark this route as ascended to record a grade.';
          container.appendChild(note);
        }

        return container;
      }

      async function applyUserRouteGrade(route, gradeValue) {
        if (!route || !route.id) {
          return;
        }

        if (!currentUser) {
          console.warn('Unable to save grade: no authenticated user.');
          return;
        }

        if (!ascendedRoutes.has(route.id)) {
          console.warn('Unable to save grade: route not marked as ascended.');
          return;
        }

        const username = await resolveAuthenticatedUsername();
        if (!username) {
          console.warn('Unable to save grade: user username missing.');
          return;
        }

        const userId = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to save grade: user ID missing.');
          return;
        }

        const sanitizedGrade = gradeValue === null ? null : normalizeGradeValue(gradeValue);
        if (sanitizedGrade === null && gradeValue !== null) {
          console.warn('Unable to save grade: invalid grade value provided.');
          return;
        }

        const ascentRef = doc(db, 'ascents', userId);

        try {
          await setDoc(
            ascentRef,
            {
              climber_uid: userId,
              climber_username: username,
              updatedAt: serverTimestamp(),
              routes: {
                [route.id]: {
                  grade: sanitizedGrade,
                  route_id: route.id,
                  climber_uid: userId,
                  climber_username: username,
                },
              },
            },
            { merge: true },
          );

          if (sanitizedGrade === null) {
            routeGrades.delete(route.id);
            const existingEntry = userAscentDetails.get(route.id) || {};
            userAscentDetails.set(route.id, { ...existingEntry, ascended: true, grade: null });
          } else {
            routeGrades.set(route.id, sanitizedGrade);
            userAscentDetails.set(route.id, { ascended: true, grade: sanitizedGrade });
          }

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          await refreshMedianGrades();
        } catch (error) {
          console.error('Failed to update route grade:', error);
        }
      }

      async function fetchMedianGrades() {
        const medianMap = new Map();

        try {
          const snapshot = await getDocs(collection(db, 'ascents'));
          const gradeBuckets = new Map();

          snapshot.forEach((docSnap) => {
            const data = docSnap.data() ?? {};
            const routesData = data.routes;

            if (!routesData || typeof routesData !== 'object') {
              return;
            }

            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!details) {
                return;
              }

              const grade = normalizeGradeValue(details.grade);
              if (grade === null) {
                return;
              }

              if (!gradeBuckets.has(routeId)) {
                gradeBuckets.set(routeId, []);
              }

              gradeBuckets.get(routeId).push(grade);
            });
          });

          gradeBuckets.forEach((grades, routeId) => {
            if (!Array.isArray(grades) || grades.length === 0) {
              return;
            }

            grades.sort((a, b) => a - b);
            const mid = Math.floor(grades.length / 2);

            if (grades.length % 2 === 0) {
              medianMap.set(routeId, (grades[mid - 1] + grades[mid]) / 2);
            } else {
              medianMap.set(routeId, grades[mid]);
            }
          });
        } catch (error) {
          console.error('Failed to load route grades:', error);
        }

        return medianMap;
      }

      async function refreshMedianGrades() {
        routeMedianGrades = await fetchMedianGrades();

        if (Array.isArray(allRoutes)) {
          allRoutes.forEach((route) => {
            const median = routeMedianGrades.get(route.id);
            route.medianGrade = typeof median === 'number' && Number.isFinite(median) ? median : null;
          });
        }

        redraw();
      }

      function updateTooltipContent(route) {
        if (!tooltip) {
          return;
        }

        applyTooltipColorScheme(route);

        const fragment = document.createDocumentFragment();
        const ariaLines = [];

        const displayTitle = (route.title || route.id || '').trim();
        if (displayTitle) {
          const titleLine = document.createElement('strong');
          titleLine.className = 'tooltip-title';
          titleLine.textContent = displayTitle;
          fragment.appendChild(titleLine);
          ariaLines.push(displayTitle);
        }

        const infoContainer = document.createElement('div');
        infoContainer.className = 'tooltip-lines';
        fragment.appendChild(infoContainer);

        const appendInfoLine = (text, className = '') => {
          if (!text) {
            return;
          }
          const line = document.createElement('div');
          line.className = className ? `tooltip-line ${className}` : 'tooltip-line';
          line.textContent = text;
          infoContainer.appendChild(line);
          ariaLines.push(text);
        };

        const setterValue = typeof route.setter === 'string' ? route.setter : '';
        appendInfoLine(`Setter: ${setterValue.trim() || 'Unknown'}`);

        const descriptionText =
          typeof route.description === 'string' ? route.description.trim() : '';
        appendInfoLine(descriptionText ? `Description: ${descriptionText}` : 'Description: —');

        appendInfoLine(`Date set: ${formatDisplayDate(route.date_set)}`);

        const medianGrade = route && typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)
          ? route.medianGrade
          : null;
        appendInfoLine(`Median grade: ${formatGradeDisplay(medianGrade)}`);

        if (ascendedRoutes.has(route.id)) {
          appendInfoLine('Ascended', 'ascend-status');
        } else {
          appendInfoLine('Not ascended', 'ascend-status not-ascended');
        }

        if (currentUser) {
          const userGrade = getUserGradeForRoute(route.id);
          appendInfoLine(`Your grade: ${formatGradeDisplay(userGrade)}`);
        }

        if (currentUser) {
          const actionButton = document.createElement('button');
          actionButton.type = 'button';
          actionButton.className = `ascend-toggle${ascendedRoutes.has(route.id) ? ' ascended' : ''}`;
          actionButton.textContent = ascendedRoutes.has(route.id) ? 'Unmark as ascended' : 'Mark as ascended';
          actionButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            toggleRouteAscent(route);
          });
          fragment.appendChild(actionButton);

          const gradeControls = buildGradeControls(route);
          if (gradeControls) {
            fragment.appendChild(gradeControls);
          }
        }

        tooltip.replaceChildren(fragment);

        if (ariaLines.length) {
          tooltip.setAttribute('aria-label', ariaLines.join('\n'));
        } else {
          tooltip.removeAttribute('aria-label');
        }
      }

      function positionTooltip(clientX, clientY) {
        if (!tooltip) {
          return;
        }

        const tooltipWidth = tooltip.offsetWidth || 0;
        const tooltipHeight = tooltip.offsetHeight || 0;
        const halfWidth = tooltipWidth / 2;

        const minX = halfWidth + 12;
        const maxX = window.innerWidth - halfWidth - 12;
        const desiredLeft = clientX;
        const clampedLeft = maxX < minX ? window.innerWidth / 2 : Math.min(maxX, Math.max(minX, desiredLeft));

        const minTop = 20;
        const maxTop = window.innerHeight - tooltipHeight + 4;
        const desiredTop = clientY - 24;
        const clampedTop = maxTop < minTop ? window.innerHeight / 2 : Math.min(maxTop, Math.max(minTop, desiredTop));

        tooltip.style.left = `${clampedLeft}px`;
        tooltip.style.top = `${clampedTop}px`;
      }

      function showTooltip(route, clientX, clientY, options = {}) {
        if (!tooltip) {
          return;
        }

        const { pin = false } = options;

        if (route.id !== activeRouteId) {
          updateTooltipContent(route);
        }

        const position = { x: clientX, y: clientY };
        positionTooltip(position.x, position.y);
        tooltip.classList.add('visible');
        tooltip.setAttribute('aria-hidden', 'false');
        activeRouteId = route.id;

        if (pin) {
          pinnedRouteId = route.id;
          pinnedPosition = { ...position };
          tooltip.classList.add('pinned');
        } else {
          pinnedRouteId = null;
          pinnedPosition = null;
          tooltip.classList.remove('pinned');
        }
      }

      function hideTooltip(options = {}) {
        if (!tooltip) {
          return;
        }

        const { force = false } = options;

        if (!force && pinnedRouteId) {
          return;
        }

        tooltip.classList.remove('visible');
        tooltip.classList.remove('pinned');
        tooltip.setAttribute('aria-hidden', 'true');
        activeRouteId = null;
        pinnedRouteId = null;
        pinnedPosition = null;
      }

      function getRouteEntryAtClientPoint(clientX, clientY) {
        if (!routePaths.length) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        for (let index = routePaths.length - 1; index >= 0; index -= 1) {
          const entry = routePaths[index];
          const previousLineWidth = ctx.lineWidth;
          ctx.lineWidth = entry.lineWidth;
          const isInside = ctx.isPointInStroke(entry.path, x, y);
          ctx.lineWidth = previousLineWidth;

          if (isInside) {
            return entry;
          }
        }

        return null;
      }

      function extractClientPoint(event) {
        if (typeof event.clientX === 'number' && typeof event.clientY === 'number') {
          return { x: event.clientX, y: event.clientY };
        }

        const touch = event.touches?.[0] ?? event.changedTouches?.[0];
        if (touch) {
          return { x: touch.clientX, y: touch.clientY };
        }

        return null;
      }

      function applyLocationFilter() {
        const desiredLocation = normalizeLocationName(currentLocation?.name);
        const fallbackLocation = normalizeLocationName(DEFAULT_LOCATION?.name);
        const targetLocation = desiredLocation || fallbackLocation;

        if (!targetLocation) {
          routes = [...allRoutes];
        } else {
          routes = allRoutes.filter((route) => {
            const routeLocation =
              typeof route?.locationKey === 'string'
                ? route.locationKey
                : normalizeLocationName(route?.location);
            return routeLocation === targetLocation;
          });
        }

        synchroniseAscentsWithRoutes({ shouldRedraw: false });
        redraw();
      }

      async function loadRoutes() {
        try {
          const [routesSnapshot, medianMap, wallSnapshot] = await Promise.all([
            getDocs(collection(db, 'routes')),
            fetchMedianGrades(),
            getDocs(collection(db, WALL_COLLECTION)),
          ]);

          routeMedianGrades = medianMap instanceof Map ? medianMap : new Map();

          wallSettingsCache.clear();
          let locationsChanged = false;
          wallSnapshot.forEach((docSnap) => {
            const data = docSnap.data();
            const settings = normalizeWallSettings(data);
            const normalizedId = normalizeWallKey(docSnap.id);
            const normalizedName = normalizeWallKey(data?.name);

            if (normalizedId) {
              wallSettingsCache.set(normalizedId, settings);
            }

            if (normalizedName) {
              wallSettingsCache.set(normalizedName, settings);
            }

            const { changed } = upsertLocation({
              key: typeof data?.key === 'string' ? data.key : docSnap.id,
              name: typeof data?.name === 'string' ? data.name : '',
              image: typeof data?.background_url === 'string' ? data.background_url : '',
              fallbackName: typeof data?.name === 'string' && data.name ? data.name : docSnap.id,
            });

            if (changed) {
              locationsChanged = true;
            }
          });

          if (locationsChanged) {
            renderLocationOptions();
            synchronizeCurrentLocationReference();
          }

          allRoutes = routesSnapshot.docs
            .map((docSnap) => {
              const data = docSnap.data();
              const normalizedPoints = Array.isArray(data.points)
                ? data.points
                    .map((point) => {
                      const x = Number(point?.x);
                      const y = Number(point?.y);
                      if (!Number.isFinite(x) || !Number.isFinite(y)) {
                        return null;
                      }
                      return { x, y };
                    })
                    .filter(Boolean)
                : [];

              const median = routeMedianGrades.get(docSnap.id);
              const medianGrade = typeof median === 'number' && Number.isFinite(median) ? median : null;
              const rawLocationValue = typeof data.location === 'string' ? data.location.trim() : '';
              const normalizedLocation =
                normalizeLocationName(rawLocationValue) || normalizeLocationName(DEFAULT_LOCATION?.name);
              const displayLocation = rawLocationValue || DEFAULT_LOCATION?.name || '';

              const fallbackWallSettings = {
                pointDiameter: data.pointDiameter,
                gradeBarBaseHeight: data.gradeBarBaseHeight,
                gradeBarMaxHeight: data.gradeBarMaxHeight,
              };
              const wallSettings = resolveWallSettings(normalizedLocation, fallbackWallSettings);

              return {
                id: docSnap.id,
                strokeColor: typeof data.strokeColor === 'string' ? data.strokeColor : '#ffde59',
                points: normalizedPoints,
                title: typeof data.title === 'string' ? data.title : '',
                setter: typeof data.setter === 'string' ? data.setter : '',
                description: typeof data.description === 'string' ? data.description : '',
                date_set: normalizeDate(data.date_set),
                date_removed: normalizeDate(data.date_removed),
                location: displayLocation,
                locationKey: normalizedLocation,
                medianGrade,
                pathType: normalizePathType(data.pathType),
                pointDiameter: wallSettings.pointDiameter,
                gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
                gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
              };
            })
            .sort((a, b) => {
              const nameA = (a.title || a.id).toLowerCase();
              const nameB = (b.title || b.id).toLowerCase();
              return nameA.localeCompare(nameB);
            });

          applyLocationFilter();
        } catch (error) {
          console.error('Failed to load routes:', error);
          allRoutes = [];
          routes = [];
          routeMedianGrades = new Map();
          redraw();
        }
      }

      async function toggleRouteAscent(route) {
        if (!currentUser) {
          return;
        }

        const username = await resolveAuthenticatedUsername();
        if (!username) {
          console.warn('Unable to mark ascent: user username missing.');
          return;
        }

        const userId = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to mark ascent: user ID missing.');
          return;
        }

        const routeId = route?.id;
        if (!routeId) {
          console.warn('Unable to mark ascent: route ID missing.');
          return;
        }
        const ascentRef = doc(db, 'ascents', userId);
        const isAscended = ascendedRoutes.has(routeId);
        let shouldRefreshMedians = false;

        try {
          if (isAscended) {
            const previousEntry = userAscentDetails.get(routeId);
            let remainingRoutes = {};

            try {
              const ascentSnap = await getDoc(ascentRef);
              if (ascentSnap.exists()) {
                const ascentData = ascentSnap.data() ?? {};
                const currentRoutes =
                  ascentData.routes && typeof ascentData.routes === 'object' ? { ...ascentData.routes } : {};
                delete currentRoutes[routeId];
                remainingRoutes = currentRoutes;
              }
            } catch (loadError) {
              console.warn('Unable to load existing ascents before removal:', loadError);
            }

            if (Object.keys(remainingRoutes).length === 0) {
              await deleteDoc(ascentRef);
            } else {
              await setDoc(ascentRef, {
                climber_uid: userId,
                climber_username: username,
                updatedAt: serverTimestamp(),
                routes: remainingRoutes,
              });
            }
            userAscentDetails.delete(routeId);
            if (previousEntry && typeof previousEntry.grade === 'number') {
              shouldRefreshMedians = true;
            }
          } else {
            const existingGrade = routeGrades.get(routeId);
            const gradeValue = typeof existingGrade === 'number' && Number.isFinite(existingGrade)
              ? existingGrade
              : null;

            await setDoc(
              ascentRef,
              {
                climber_uid: userId,
                climber_username: username,
                updatedAt: serverTimestamp(),
                routes: {
                  [routeId]: {
                    route_id: routeId,
                    date_ascended: new Date().toISOString(),
                    climber_uid: userId,
                    climber_username: username,
                    grade: gradeValue,
                },
              },
            },
            { merge: true },
            );
            userAscentDetails.set(routeId, {
              ascended: true,
              grade: gradeValue,
            });
          }

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          if (shouldRefreshMedians) {
            await refreshMedianGrades();
          } else {
            redraw();
          }
        } catch (error) {
          console.error('Failed to update ascent:', error);
        }
      }

      function computeCanvasDimensions() {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const aspectRatio = Number.isFinite(canvasAspectRatio) && canvasAspectRatio > 0
          ? canvasAspectRatio
          : DEFAULT_CANVAS_ASPECT_RATIO;
        const enableScroll = viewportWidth <= 768 && viewportHeight > viewportWidth;

        if (enableScroll) {
          const height = viewportHeight;
          const width = Math.max(viewportWidth, Math.round(height * aspectRatio));
          return { width, height, enableScroll };
        }

        return {
          width: viewportWidth,
          height: viewportHeight,
          enableScroll: false,
        };
      }

      function resizeCanvas() {
        const { width, height, enableScroll } = computeCanvasDimensions();

        if (canvasContainer) {
          canvasContainer.classList.toggle('scrollable', enableScroll);
        }

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        if (canvasContainer) {
          if (enableScroll) {
            const maxScrollLeft = Math.max(0, width - window.innerWidth);
            if (!isHorizontalScrollEnabled) {
              canvasContainer.scrollLeft = Math.max(0, maxScrollLeft / 2);
            } else if (canvasContainer.scrollLeft > maxScrollLeft) {
              canvasContainer.scrollLeft = maxScrollLeft;
            }
          } else if (isHorizontalScrollEnabled) {
            canvasContainer.scrollLeft = 0;
          }
        }

        isHorizontalScrollEnabled = enableScroll;
        redraw();
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (backgroundReady && backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        routePaths = [];
        gradeBarPlacements = [];
        const shouldPreservePinned = Boolean(pinnedRouteId && pinnedPosition);
        const pinnedRoute = shouldPreservePinned
          ? routes.find((route) => route.id === pinnedRouteId)
          : null;

        if (!shouldPreservePinned) {
          hideTooltip();
        } else if (!pinnedRoute) {
          hideTooltip({ force: true });
        }

        routes.forEach(drawRoute);

        if (pinnedRoute && tooltip) {
          updateTooltipContent(pinnedRoute);
          tooltip.classList.add('visible');
          tooltip.classList.add('pinned');
          tooltip.setAttribute('aria-hidden', 'false');
          positionTooltip(pinnedPosition.x, pinnedPosition.y);
        }
      }

      function findAnchorPointForRoute(route, scaledPoints, canvasHeight) {
        if (!Array.isArray(scaledPoints) || scaledPoints.length === 0) {
          return null;
        }

        const fallback = scaledPoints[Math.floor(scaledPoints.length / 2)] || scaledPoints[0];
        const routeMedian = typeof route?.medianGrade === 'number' && Number.isFinite(route.medianGrade)
          ? route.medianGrade
          : null;

        if (routeMedian === null || !Number.isFinite(canvasHeight) || canvasHeight <= 0) {
          return fallback ? { ...fallback } : null;
        }

        const gradeMin = GRADE_SCALE_MIN;
        const gradeMax = GRADE_SCALE_MAX;
        const gradeRange = gradeMax - gradeMin;

        if (gradeRange <= 0) {
          return fallback ? { ...fallback } : null;
        }

        const startPoint = scaledPoints[0];
        const endPoint = scaledPoints[scaledPoints.length - 1];

        if (!startPoint || !endPoint) {
          return fallback ? { ...fallback } : null;
        }

        const minAnchorY = Math.min(startPoint.y, endPoint.y);
        const maxAnchorY = Math.max(startPoint.y, endPoint.y);
        const anchorSpan = maxAnchorY - minAnchorY;

        if (anchorSpan <= 0) {
          return fallback ? { ...fallback } : null;
        }

        const normalized = (routeMedian - gradeMin) / gradeRange;
        const clamped = Math.min(1, Math.max(0, normalized));
        const targetY = maxAnchorY - clamped * anchorSpan;

        let anchorPoint = null;

        for (let index = 0; index < scaledPoints.length - 1; index += 1) {
          const start = scaledPoints[index];
          const end = scaledPoints[index + 1];

          if (!start || !end) {
            continue;
          }

          const minSegmentY = Math.min(start.y, end.y);
          const maxSegmentY = Math.max(start.y, end.y);

          if (targetY >= minSegmentY && targetY <= maxSegmentY) {
            const deltaY = end.y - start.y;
            const t = deltaY === 0 ? 0 : (targetY - start.y) / deltaY;
            const clampedT = Math.min(1, Math.max(0, t));

            anchorPoint = {
              x: start.x + (end.x - start.x) * clampedT,
              y: start.y + (end.y - start.y) * clampedT,
            };
            break;
          }
        }

        if (!anchorPoint) {
          anchorPoint = scaledPoints.reduce((closest, point) => {
            if (!point) {
              return closest;
            }

            if (!closest) {
              return point;
            }

            const closestDelta = Math.abs(closest.y - targetY);
            const currentDelta = Math.abs(point.y - targetY);

            return currentDelta < closestDelta ? point : closest;
          }, null);
        }

        if (anchorPoint) {
          return { ...anchorPoint };
        }

        return fallback ? { ...fallback } : null;
      }

      function drawRoute(route) {
        const strokeColor = typeof route.strokeColor === 'string' ? route.strokeColor : '#ffde59';
        const points = Array.isArray(route.points) ? route.points : [];

        if (!points.length) {
          return;
        }

        const scaledPoints = points
          .map((point) => {
            const x = Number(point?.x);
            const y = Number(point?.y);
            if (!Number.isFinite(x) || !Number.isFinite(y)) {
              return null;
            }
            return {
              x: x * canvas.width,
              y: y * canvas.height,
            };
          })
          .filter(Boolean);

        if (!scaledPoints.length) {
          return;
        }

        const pathType = normalizePathType(route.pathType);
        const pointDiameter = normalizePointDiameter(route.pointDiameter);

        function drawGradeBar() {
          const baseHeight = normalizeGradeBarHeight(
            route.gradeBarBaseHeight,
            DEFAULT_GRADE_BAR_BASE_HEIGHT,
          );
          const maxHeightCandidate = normalizeGradeBarHeight(
            route.gradeBarMaxHeight,
            DEFAULT_GRADE_BAR_MAX_HEIGHT,
          );
          const maxHeight = Math.max(baseHeight, maxHeightCandidate);

          const rawGrade = typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)
            ? route.medianGrade
            : null;
          const clampedGrade = rawGrade === null
            ? null
            : Math.min(Math.max(rawGrade, 0), GRADE_SCALE_MAX);

          const gradeHeight =
            clampedGrade === null
              ? baseHeight
              : baseHeight + (maxHeight - baseHeight) * (clampedGrade / GRADE_SCALE_MAX);

          const referenceDiameter = normalizePointDiameter(route.pointDiameter);
          const barWidth = Math.max(12, Math.min(64, Math.round(referenceDiameter * 0.75)));

          const xValues = scaledPoints
            .map((point) => point?.x)
            .filter((value) => Number.isFinite(value))
            .sort((a, b) => a - b);

          if (!xValues.length) {
            return;
          }

          const medianIndex = Math.floor((xValues.length - 1) / 2);
          const medianX =
            xValues.length % 2 === 0
              ? (xValues[medianIndex] + xValues[medianIndex + 1]) / 2
              : xValues[medianIndex];

          const initialLeft = clampGradeBarLeft(medianX - barWidth / 2, barWidth);
          const { left: barLeft } = resolveGradeBarPlacement(initialLeft, barWidth);

          const bottomMargin = 16;
          const availableHeight = Math.max(2, canvas.height - bottomMargin);
          const finalHeight = Math.max(2, Math.min(Math.round(gradeHeight), availableHeight));
          const topY = Math.max(0, canvas.height - bottomMargin - finalHeight);

          ctx.save();
          ctx.beginPath();
          ctx.rect(barLeft, topY, barWidth, finalHeight);

          const hasGrade = clampedGrade !== null;
          if (hasGrade && ascendedRoutes.has(route.id)) {
            ctx.fillStyle = strokeColor;
            ctx.globalAlpha = 0.9;
            ctx.fill();
            ctx.globalAlpha = 1;
          }

          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.lineWidth = Math.max(2, Math.min(6, barWidth * 0.18));
          ctx.strokeStyle = strokeColor;

          if (!hasGrade) {
            ctx.setLineDash([6, 4]);
          }

          ctx.stroke();
          ctx.restore();
        }

        if (pathType === PATH_TYPE_POINT) {
          const circleRadius = Math.max(1, pointDiameter / 2);
          const strokeWidth = Math.max(2, Math.round(pointDiameter / 10));
          const path = new Path2D();

          scaledPoints.forEach((point) => {
            path.moveTo(point.x + circleRadius, point.y);
            path.arc(point.x, point.y, circleRadius, 0, Math.PI * 2);
          });

          ctx.save();
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = strokeColor;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.stroke(path);
          ctx.restore();

          const anchorIndex = Math.floor(scaledPoints.length / 2);
          const anchor = scaledPoints[anchorIndex] || scaledPoints[0] || null;

          routePaths.push({
            route,
            path,
            lineWidth: strokeWidth,
            anchor,
          });

          drawGradeBar();
          return;
        }

        if (scaledPoints.length < 2) {
          return;
        }

        const path = new Path2D();
        path.moveTo(scaledPoints[0].x, scaledPoints[0].y);

        for (let i = 0; i < scaledPoints.length - 1; i++) {
          const p0 = i === 0 ? scaledPoints[0] : scaledPoints[i - 1];
          const p1 = scaledPoints[i];
          const p2 = scaledPoints[i + 1];
          const p3 = i + 2 < scaledPoints.length ? scaledPoints[i + 2] : scaledPoints[i + 1];

          const cp1x = p1.x + (p2.x - p0.x) / 6;
          const cp1y = p1.y + (p2.y - p0.y) / 6;
          const cp2x = p2.x - (p3.x - p1.x) / 6;
          const cp2y = p2.y - (p3.y - p1.y) / 6;

          path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }

        const lineWidth = 10;
        const anchorIndex = Math.floor(scaledPoints.length / 2);
        const fallbackAnchor = scaledPoints[anchorIndex] || scaledPoints[0] || null;
        const computedAnchor = findAnchorPointForRoute(route, scaledPoints, canvas.height);
        const anchor = computedAnchor || (fallbackAnchor ? { ...fallbackAnchor } : null);

        ctx.save();
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = strokeColor;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        ctx.stroke(path);
        ctx.restore();

        routePaths.push({
          route,
          path,
          lineWidth,
          anchor,
        });

        drawGradeBar();
      }

      function handlePointerMove(event) {
        if (pinnedRouteId) {
          return;
        }

        if ('pointerType' in event) {
          const pointerType = event.pointerType;
          if (pointerType && pointerType !== 'mouse' && pointerType !== 'pen') {
            hideTooltip();
            return;
          }
        }

        const entry = getRouteEntryAtClientPoint(event.clientX, event.clientY);

        if (entry) {
          showTooltip(entry.route, event.clientX, event.clientY);
          return;
        }

        hideTooltip();
      }

      function handlePointerLeave() {
        if (pinnedRouteId) {
          return;
        }

        hideTooltip();
      }

      function handleCanvasPointerDown(event) {
        const point = extractClientPoint(event);
        if (!point) {
          return;
        }

        const entry = getRouteEntryAtClientPoint(point.x, point.y);

        if (entry) {
          showTooltip(entry.route, point.x, point.y, { pin: true });
        } else {
          hideTooltip({ force: true });
        }
      }

      function handleDocumentPointerDown(event) {
        if (!tooltip) {
          return;
        }

        if (event.target === canvas) {
          return;
        }

        if (tooltip.contains(event.target)) {
          return;
        }

        hideTooltip({ force: true });
      }

      if ('PointerEvent' in window) {
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerleave', handlePointerLeave);
        canvas.addEventListener('pointerdown', handleCanvasPointerDown);
        document.addEventListener('pointerdown', handleDocumentPointerDown);
      } else {
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseleave', handlePointerLeave);
        canvas.addEventListener('mousedown', handleCanvasPointerDown);
        canvas.addEventListener('touchstart', handleCanvasPointerDown);
        document.addEventListener('mousedown', handleDocumentPointerDown);
        document.addEventListener('touchstart', handleDocumentPointerDown);
      }

      window.addEventListener('resize', resizeCanvas);

      if (backgroundImage.complete) {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      } else {
        resizeCanvas();
      }
    </script>
  </body>
</html>
