<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ascend</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #000;
        --wall-background: url('./location/New Wall.jpg');
        background-image: var(--wall-background);
        background-position: center;
        background-size: 100% 100%;
        background-repeat: no-repeat;
        background-attachment: fixed;
        color: #fff;
        overflow: hidden;
      }

      .hidden {
        display: none !important;
      }

      .canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .canvas-container.scrollable {
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
      }

      .tutorial-prompt {
        position: fixed;
        left: 50%;
        bottom: 1.5rem;
        transform: translate(-50%, 0);
        width: 3.5rem;
        height: 3.5rem;
        border-radius: 50%;
        border: none;
        background-color: rgba(126, 217, 87, 0.95);
        background-image: linear-gradient(135deg, rgba(126, 217, 87, 0.95), rgba(63, 142, 45, 0.95));
        color: #0b1a05;
        font-size: 1.75rem;
        font-weight: 700;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        z-index: 20;
        animation: tutorial-bounce 1.2s ease-in-out infinite;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .tutorial-prompt:hover,
      .tutorial-prompt:focus-visible {
        transform: translate(-50%, -6px) scale(1.02);
        box-shadow: 0 22px 48px rgba(0, 0, 0, 0.55);
        outline: none;
      }

      .tutorial-prompt:focus-visible {
        box-shadow: 0 0 0 4px rgba(126, 217, 87, 0.45), 0 22px 48px rgba(0, 0, 0, 0.55);
      }

      @keyframes tutorial-bounce {
        0%,
        100% {
          transform: translate(-50%, 0);
          background-color: rgba(126, 217, 87, 0.95);
          background-image: linear-gradient(
            135deg,
            rgba(126, 217, 87, 0.95),
            rgba(63, 142, 45, 0.95)
          );
        }
        50% {
          transform: translate(-50%, calc(-200% / 3));
          background-color: #ff8c42;
          background-image: none;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .tutorial-prompt {
          animation: none;
        }
      }

      .tutorial-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
        background: rgba(8, 12, 9, 0);
        z-index: 30;
      }

      .tutorial-overlay.is-bottom-aligned {
        align-items: flex-end;
      }

      .tutorial-overlay.is-bottom-aligned .tutorial-card {
        margin-bottom: clamp(1.5rem, 8vh, 4rem);
      }

      .tutorial-card {
        width: min(520px, 100%);
        background: rgba(12, 18, 15, 0.95);
        border-radius: 1rem;
        padding: 1.75rem;
        display: flex;
        flex-direction: column;
        gap: 1.15rem;
        box-shadow: 0 30px 60px rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(126, 217, 87, 0.2);
      }

      .tutorial-progress {
        font-size: 0.85rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(126, 217, 87, 0.8);
      }

      .tutorial-title {
        font-size: 1.35rem;
        font-weight: 700;
        line-height: 1.3;
      }

      .tutorial-description {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        color: rgba(248, 250, 252, 0.92);
        font-size: 0.98rem;
        line-height: 1.55;
      }

      .tutorial-description p {
        margin: 0;
      }

      .tutorial-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: flex-end;
      }

      .tutorial-button {
        border-radius: 999px;
        border: none;
        padding: 0.65rem 1.4rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          color 0.2s ease, border-color 0.2s ease;
      }

      .tutorial-primary {
        background: #7ed957;
        color: #0c1a07;
        box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
      }

      .tutorial-primary:hover,
      .tutorial-primary:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 18px 30px rgba(126, 217, 87, 0.35);
        outline: none;
      }

      .tutorial-secondary {
        background: transparent;
        color: rgba(248, 250, 252, 0.9);
        border: 1px solid rgba(248, 250, 252, 0.3);
      }

      .tutorial-secondary:hover,
      .tutorial-secondary:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        outline: none;
        border-color: rgba(248, 250, 252, 0.6);
      }

      .tutorial-highlight {
        box-shadow: 0 0 0 5px rgba(126, 217, 87, 0.75), 0 0 26px rgba(126, 217, 87, 0.6);
      }

      .tutorial-illuminated {
        animation: tutorial-illuminate 1.2s ease-in-out infinite;
        box-shadow: 0 0 0 7px rgba(126, 217, 87, 0.85), 0 0 36px rgba(126, 217, 87, 0.7);
      }

      .tutorial-pointer {
        position: fixed;
        width: 34px;
        height: 54px;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        z-index: 60;
        transform: translate(-50%, 0);
      }

      .tutorial-pointer.hidden {
        display: none;
      }

      .tutorial-pointer svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 10px 18px rgba(0, 0, 0, 0.45));
        animation: tutorial-pointer-bounce 1.05s ease-in-out infinite;
      }

      @keyframes tutorial-pointer-bounce {
        0%,
        100% {
          transform: translateY(4px);
        }
        50% {
          transform: translateY(-6px);
        }
      }

      @keyframes tutorial-illuminate {
        0%,
        100% {
          box-shadow: 0 0 0 6px rgba(126, 217, 87, 0.7), 0 0 28px rgba(126, 217, 87, 0.55);
        }
        50% {
          box-shadow: 0 0 0 10px rgba(255, 140, 66, 0.85), 0 0 42px rgba(255, 140, 66, 0.75);
        }
      }

      .tutorial-route-pulse {
        animation: tutorial-route-pulse 1.8s ease-in-out infinite;
      }

      @keyframes tutorial-route-pulse {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.35);
        }
      }

      .is-tutorial-disabled {
        pointer-events: none !important;
        opacity: 0.55 !important;
      }

      canvas {
        display: block;
        height: 100%;
        width: auto;
        min-width: 100%;
      }

      .auth-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        padding: 1.5rem;
        backdrop-filter: blur(2px);
        z-index: 10;
      }

      .auth-card {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1rem;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: min(90vw, 360px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      }

      .auth-card h1 {
        font-size: 1.4rem;
        text-align: center;
      }

      .auth-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.95rem;
      }

      .auth-field input {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        padding: 0.65rem 1rem;
        font-size: 1rem;
      }

      .auth-submit {
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1rem;
        background: #7ed957;
        color: #111;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .auth-submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
      }

      .auth-switch {
        font-size: 0.9rem;
        text-align: center;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        justify-content: center;
        align-items: center;
      }

      .auth-switch button {
        background: none;
        border: none;
        color: #7ed957;
        font-weight: 600;
        cursor: pointer;
        text-decoration: underline;
      }

      .auth-error {
        min-height: 1.25rem;
        color: #ff7a7a;
        text-align: center;
        font-size: 0.85rem;
      }

      .app-header {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 5;
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      .header-icon-button {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
        color: #fff;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          border-color 0.2s ease;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        padding: 0;
      }

      .header-icon-button svg {
        width: 20px;
        height: 20px;
        display: block;
      }

      .view-toggle {
        position: relative;
      }

      .view-toggle .view-toggle-icon {
        display: none;
        width: 20px;
        height: 20px;
      }

      .view-toggle .view-toggle-icon svg {
        width: 100%;
        height: 100%;
      }

      .view-toggle[aria-pressed='false'] .view-toggle-icon-grade,
      .view-toggle[aria-pressed='true'] .view-toggle-icon-difficulty {
        display: block;
      }

      .header-icon-button:hover,
      .header-icon-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
        outline: none;
      }

      .view-toggle[aria-pressed='true'] {
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.85), rgba(126, 217, 87, 0.4));
        color: #0f1a08;
        border-color: rgba(126, 217, 87, 0.65);
        box-shadow: 0 10px 24px rgba(126, 217, 87, 0.35);
      }

      .location-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(3px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        z-index: 20;
      }

      .location-modal.hidden {
        display: none !important;
      }

      .location-modal.is-top-aligned {
        align-items: flex-start;
        padding-top: clamp(4.5rem, 14vh, 7.5rem);
      }

      .location-modal.is-top-aligned .location-modal-content {
        margin-top: 0;
      }

      .progression-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(3px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        z-index: 20;
      }

      .progression-modal.hidden {
        display: none !important;
      }

      .location-modal-content {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1.25rem;
        width: min(720px, 92vw);
        max-height: 90vh;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .progression-modal-content {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1.25rem;
        width: min(540px, 92vw);
        max-height: 90vh;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .location-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .location-modal-title {
        font-size: 1.35rem;
        font-weight: 700;
      }

      .progression-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .progression-modal-title {
        font-size: 1.35rem;
        font-weight: 700;
      }

      .location-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.4rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .location-modal-close:hover,
      .location-modal-close:focus-visible {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .progression-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.4rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .progression-modal-close:hover,
      .progression-modal-close:focus-visible {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .location-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
      }

      .progression-description {
        color: rgba(255, 255, 255, 0.75);
        font-size: 0.95rem;
      }

      .progression-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        overflow-y: auto;
        padding-right: 0.25rem;
      }

      .progression-entry {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border-radius: 0.85rem;
        background: rgba(255, 255, 255, 0.08);
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      }

      .progression-entry:hover {
        background: rgba(255, 255, 255, 0.14);
        transform: translateY(-1px);
      }

      .progression-entry:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.16);
      }

      .progression-entry.is-focused {
        background: rgba(255, 255, 255, 0.18);
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.45);
      }

      .progression-entry-grade {
        font-variant-numeric: tabular-nums;
        font-weight: 600;
        min-width: 3ch;
        text-align: right;
      }

      .progression-entry-name {
        font-size: 1rem;
        font-weight: 600;
      }

      .progression-entry-status {
        font-size: 1.15rem;
        width: 1.5rem;
        text-align: center;
        color: rgba(255, 255, 255, 0.45);
      }

      .progression-entry-status.is-ascended {
        color: #7ed957;
      }

      .progression-empty-message {
        text-align: center;
        color: rgba(255, 255, 255, 0.75);
        font-size: 0.95rem;
        padding: 2rem 0;
      }

      .location-option {
        border: none;
        border-radius: 1rem;
        padding: 0;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        cursor: pointer;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        text-align: left;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .location-option:hover,
      .location-option:focus-visible {
        transform: translateY(-4px);
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.4);
        outline: none;
        background: rgba(255, 255, 255, 0.18);
      }

      .location-option[aria-current='true'] {
        box-shadow: 0 0 0 3px rgba(126, 217, 87, 0.75);
        background: rgba(126, 217, 87, 0.18);
      }

      .location-option-preview {
        position: relative;
        width: 100%;
        padding-top: 66%;
        background-size: cover;
        background-position: center;
      }

      .location-option-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.9rem 1rem;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      .location-option-name {
        flex: 1;
      }

      .info-wrapper {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 6;
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
      }

      .info-button {
        width: 40px;
        height: 40px;
        border: 2px solid rgba(255, 255, 255, 0.35);
        background: linear-gradient(135deg, rgba(36, 36, 36, 0.9), rgba(92, 92, 92, 0.45));
        color: #f8fafc;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease,
          background 0.2s ease, color 0.2s ease;
      }

      .info-button.is-active {
        border-color: rgba(126, 217, 87, 0.65);
        background: #7ed957;
        color: #0c1905;
        box-shadow: 0 8px 22px rgba(126, 217, 87, 0.35);
      }

      .info-button:hover,
      .info-button:focus-visible {
        transform: translateY(-2px);
      }

      .info-button:not(.is-active):hover,
      .info-button:not(.is-active):focus-visible {
        border-color: rgba(255, 255, 255, 0.55);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.5);
        outline: none;
      }

      .info-button.is-active:hover,
      .info-button.is-active:focus-visible {
        box-shadow: 0 12px 28px rgba(126, 217, 87, 0.45);
        border-color: rgba(126, 217, 87, 0.9);
        outline: none;
      }

      .info-button.is-active:focus-visible {
        box-shadow: 0 0 0 4px rgba(126, 217, 87, 0.25), 0 12px 28px rgba(126, 217, 87, 0.45);
      }

      .setter-link {
        text-decoration: none;
        color: inherit;
      }

      .setter-link.header-icon-button {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.82), rgba(255, 255, 255, 0.4));
        color: #0c1905;
        border-color: rgba(255, 255, 255, 0.6);
      }

      .walls-button {
        backdrop-filter: blur(6px);
      }

      .login-link {
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.85), rgba(126, 217, 87, 0.55));
        color: #0f1a08;
        border-color: rgba(183, 244, 153, 0.65);
      }

      .login-link:hover,
      .login-link:focus-visible {
        border-color: rgba(206, 248, 178, 0.9);
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.95), rgba(126, 217, 87, 0.65));
      }

      .info-popover {
        position: absolute;
        top: calc(100% + 0.75rem);
        left: 0;
        width: min(280px, 70vw);
        padding: 0.9rem 1rem;
        border-radius: 0.75rem;
        background: rgba(0, 0, 0, 0.85);
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.85rem;
        line-height: 1.4;
        text-align: left;
        pointer-events: auto;
      }

      .info-popover p {
        color: rgba(255, 255, 255, 0.85);
      }

      .info-popover p + p {
        margin-top: 0.5rem;
      }

      .info-highlights {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 40;
      }

      .info-callout {
        --info-callout-bg: rgba(10, 16, 11, 0.94);
        --info-callout-border: rgba(126, 217, 87, 0.55);
        position: absolute;
        min-width: 200px;
        max-width: 260px;
        padding: 0.85rem 1rem;
        border-radius: 0.85rem;
        background: var(--info-callout-bg);
        border: 1px solid var(--info-callout-border);
        color: rgba(255, 255, 255, 0.94);
        box-shadow: 0 18px 42px rgba(0, 0, 0, 0.45);
        transform: translate(-50%, 0);
        pointer-events: none;
        line-height: 1.45;
      }

      .info-callout::before {
        content: '';
        position: absolute;
        width: 0;
        height: 0;
        border: 10px solid transparent;
        left: var(--callout-arrow-offset, 50%);
        transform: translateX(-50%);
      }

      .info-callout[data-arrow='top']::before {
        top: -18px;
        border-bottom-color: var(--info-callout-bg);
      }

      .info-callout[data-arrow='bottom']::before {
        bottom: -18px;
        border-top-color: var(--info-callout-bg);
      }

      .info-callout strong {
        display: block;
        font-weight: 600;
        letter-spacing: 0.01em;
        margin-bottom: 0.35rem;
      }

      .info-callout p {
        font-size: 0.82rem;
        color: rgba(255, 255, 255, 0.88);
      }

      .info-callout p + p {
        margin-top: 0.4rem;
      }

      .info-callout-chart {
        margin-top: 0.75rem;
        display: flex;
        align-items: flex-end;
        gap: 0.18rem;
        height: 52px;
        padding: 0 0.15rem;
      }

      .info-callout-chart-bar {
        flex: 1;
        min-width: 0.15rem;
        border-radius: 0.4rem 0.4rem 0 0;
        background: #2f9e44;
        height: 45%;
        opacity: 0.95;
      }

      .info-callout-chart-bar:first-child {
        border-top-left-radius: 0.45rem;
      }

      .info-callout-chart-bar:last-child {
        border-top-right-radius: 0.45rem;
      }

      .nav-links {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .nav-links a {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.55));
        color: #0c1905;
        border-color: rgba(255, 255, 255, 0.65);
        box-shadow: 0 10px 22px rgba(255, 255, 255, 0.25);
      }

      .nav-links a:hover,
      .nav-links a:focus-visible {
        box-shadow: 0 14px 28px rgba(255, 255, 255, 0.35);
      }

      .login-link {
        background: linear-gradient(135deg, rgba(126, 217, 87, 0.85), rgba(126, 217, 87, 0.6));
        border-color: rgba(183, 244, 153, 0.7);
      }

      .route-tooltip {
        --tooltip-accent: #7ed957;
        --tooltip-accent-rgb: 126, 217, 87;
        --tooltip-accent-soft: rgba(126, 217, 87, 0.18);
        --tooltip-accent-strong: rgba(126, 217, 87, 0.85);
        --tooltip-on-accent: #000;
        --tooltip-foreground: #fff;
        --tooltip-soft-foreground: #000;
        --tooltip-muted-foreground: #d1d5db;
        --tooltip-surface: #0e150f;
        --tooltip-border-color: #7ed957;
        --tooltip-grade-size: 7.5rem;
        position: fixed;
        pointer-events: none;
        color: var(--tooltip-foreground, #fff);
        padding: 0.75rem 1rem;
        padding-right: calc(1rem + var(--tooltip-grade-size, 7.5rem) * 0.7);
        border-radius: 0.75rem;
        font-size: 0.85rem;
        line-height: 1.4;
        max-width: min(280px, 80vw);
        z-index: 6;
        opacity: 0;
        transform: translate(-50%, -12px);
        transition: opacity 0.12s ease, transform 0.12s ease;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        overflow: visible;
        background-color: var(--tooltip-surface, #0e150f);
        background: var(--tooltip-surface, #0e150f);
        border: 1px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.45);
      }

      .route-tooltip.pinned {
        pointer-events: auto;
      }

      .route-tooltip.visible {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      .route-tooltip .tooltip-header {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 0.5rem;
        margin-bottom: 0.35rem;
      }

      .route-tooltip .tooltip-title {
        display: block;
        font-size: 0.95rem;
        font-weight: 600;
      }

      .route-tooltip .tooltip-lines {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        white-space: pre-line;
      }

      .route-tooltip .tooltip-line {
        display: block;
      }

      .route-tooltip .tooltip-grade-cluster {
        position: absolute;
        top: 0;
        right: 0;
        transform: translate(50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.55rem;
        min-width: var(--tooltip-grade-size, 7.5rem);
        z-index: 1;
      }

      .route-tooltip .tooltip-grade-badge {
        width: var(--tooltip-grade-size, 7.5rem);
        height: var(--tooltip-grade-size, 7.5rem);
        border-radius: 50%;
        border: var(--tooltip-grade-stroke-width, 2px) solid var(--tooltip-accent, #7ed957);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: calc(var(--tooltip-grade-size, 7.5rem) * 0.32);
        line-height: 1;
        color: var(--tooltip-on-accent, #000);
        background: rgb(var(--tooltip-accent-rgb, 126, 217, 87));
        pointer-events: none;
        overflow: hidden;
      }

      .route-tooltip .tooltip-actions {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        margin-top: 0.5rem;
        width: 100%;
        pointer-events: auto;
      }

      .route-tooltip .tooltip-action-button {
        width: 100%;
        border-radius: 999px;
        padding: 0.6rem 0.9rem;
        font-size: 0.82rem;
        font-weight: 600;
        border: 2px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
        text-align: center;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease,
          color 0.15s ease, border-color 0.15s ease;
      }

      .route-tooltip .tooltip-action-button:hover,
      .route-tooltip .tooltip-action-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        outline: none;
      }

      .route-tooltip .tooltip-action-button.is-quiet {
        background: var(--tooltip-surface, #0e150f);
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-action-button.is-quiet:hover,
      .route-tooltip .tooltip-action-button.is-quiet:focus-visible {
        border-color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .tooltip-action-button[aria-pressed='true'] {
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      }

      .route-tooltip .ascend-toggle[aria-pressed='true'] {
        background: var(--tooltip-on-accent, #000);
        color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .focus-toggle {
        text-align: center;
      }

      .route-tooltip .focus-toggle[aria-pressed='true'] {
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
      }

      .route-tooltip .tooltip-grade-value {
        position: relative;
        z-index: 1;
      }

      .route-tooltip .tooltip-grade-badge.ascended {
        box-shadow: 0 0 0 0.35rem rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
      }

      .grade-section {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        margin-top: 0.75rem;
      }

      .grade-form {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .grade-form label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.8rem;
        font-weight: 600;
      }

      .grade-input-row {
        display: flex;
        gap: 0.5rem;
        align-items: stretch;
      }

      .grade-input-row label {
        flex: 1;
      }

      .grade-input-row input[type='number'] {
        flex: 1;
      }

      .grade-form input[type='number'] {
        border-radius: 0.65rem;
        border: 1px solid #fff;
        background: #fff;
        color: #111;
        padding: 0.45rem 0.6rem;
        font-size: 0.85rem;
      }

      .grade-form input[type='number']:disabled {
        cursor: not-allowed;
      }

      .grade-note {
        font-size: 0.75rem;
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-close-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.15rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: rgba(0, 0, 0, 0.25);
        color: var(--tooltip-foreground, #fff);
        font-size: 1rem;
        line-height: 1;
        min-width: 0;
        transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease,
          box-shadow 0.2s ease;
      }

      .route-tooltip .tooltip-close-button:hover,
      .route-tooltip .tooltip-close-button:focus-visible {
        border-color: rgba(255, 255, 255, 0.6);
        background: rgba(255, 255, 255, 0.2);
        color: #0b0f03;
        box-shadow: 0 0 0 0.15rem rgba(255, 255, 255, 0.2);
      }

      .route-tooltip .tooltip-close-button svg {
        width: 1em;
        height: 1em;
        display: block;
      }

    </style>
  </head>
  <body>
    <div
      id="authOverlay"
      class="auth-overlay hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="authTitle"
    >
      <form id="authForm" class="auth-card">
        <h1 id="authTitle">Sign in to continue</h1>
        <label class="auth-field">
          <span>Username</span>
          <input id="authUsername" type="text" name="username" autocomplete="username" required />
        </label>
        <label class="auth-field">
          <span>Password</span>
          <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="6" required />
        </label>
        <p id="authError" class="auth-error" role="alert" aria-live="assertive"></p>
        <button type="submit" class="auth-submit">Sign In</button>
        <p class="auth-switch">
          <span id="authSwitchLabel">Don't have an account?</span>
          <button type="button" id="toggleAuthMode">Create one</button>
        </p>
      </form>
    </div>
    <div id="appContent" class="app" aria-live="polite">
      <div class="info-wrapper">
        <button
          id="infoButton"
          class="header-icon-button info-button"
          type="button"
          aria-label="Learn about Ascend"
          aria-haspopup="dialog"
          aria-pressed="false"
          aria-expanded="false"
          aria-controls="infoPopover"
          title="Learn about Ascend"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2" />
            <rect x="11" y="10" width="2" height="7" rx="1" />
            <circle cx="12" cy="7" r="1.5" />
          </svg>
        </button>
        <div
          id="infoPopover"
          class="info-popover hidden"
          role="dialog"
          aria-modal="false"
          aria-hidden="true"
          aria-label="About Ascend"
          tabindex="-1"
        >
          <p>Tap a header button to learn what it does.</p>
          <p>The next button you press will open its tooltip and close this message.</p>
        </div>
      </div>
      <header class="app-header">
        <button
          id="viewToggle"
          class="header-icon-button view-toggle"
          type="button"
          aria-pressed="false"
          aria-label="Show Grade Colors"
          title="Show Grade Colors"
        >
          <span class="view-toggle-icon view-toggle-icon-grade" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
              <path
                d="M6 19a3 3 0 0 1 0-6h12a2 2 0 0 0 0-4H8a4 4 0 0 1 0-8h10v2H8a2 2 0 0 0 0 4h10a4 4 0 0 1 0 8H6a1 1 0 0 0 0 2h12v2H6a3 3 0 0 1-3-3Z"
                fill="currentColor"
              />
            </svg>
          </span>
          <span class="view-toggle-icon view-toggle-icon-difficulty" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
              <rect x="5" y="13.5" width="3.5" height="6" rx="1.75" fill="#2f9e44" />
              <rect x="10.25" y="9.5" width="3.5" height="10" rx="1.75" fill="#facc15" />
              <rect x="15.5" y="5" width="3.5" height="14.5" rx="1.75" fill="#ef4444" />
              <rect x="4" y="20" width="16" height="1.5" rx="0.75" fill="#ffffff" fill-opacity="0.55" />
            </svg>
          </span>
        </button>
        <button
          id="locationButton"
          class="header-icon-button walls-button"
          type="button"
          aria-haspopup="dialog"
          aria-label="Select wall"
          title="Select wall"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M12 2a7 7 0 0 1 7 7c0 4.42-4.56 9.52-6.38 11.34a0.88 0.88 0 0 1-1.24 0C9.56 18.52 5 13.42 5 9a7 7 0 0 1 7-7Zm0 4a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <a
          id="loginButton"
          class="header-icon-button login-link"
          href="personal.html"
          aria-label="Log in"
          title="Log in"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M11 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-3h2v2h5V5h-5v2h-2V4Z"
              fill="currentColor"
            />
            <path
              d="m5.7 11.3 2.3-2.3 1.4 1.4L8.83 11H14v2H8.83l0.57 0.59-1.4 1.41-2.3-2.3a1 1 0 0 1 0-1.4Z"
              fill="currentColor"
            />
          </svg>
        </a>
      </header>
      <div class="canvas-container">
        <canvas id="previewCanvas" aria-hidden="true"></canvas>
      </div>
    </div>
    <button
      id="tutorialPromptButton"
      class="tutorial-prompt hidden"
      type="button"
      aria-label="Open tutorial"
      aria-hidden="true"
      title="Show a quick tour"
      data-tutorial-exempt="true"
    >
      ?
    </button>
    <div
      id="tutorialOverlay"
      class="tutorial-overlay hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="tutorialTitle"
      aria-describedby="tutorialDescription"
    >
      <div id="tutorialDialogCard" class="tutorial-card" role="document" tabindex="-1">
        <div id="tutorialProgress" class="tutorial-progress hidden" aria-live="polite"></div>
        <h2 id="tutorialTitle" class="tutorial-title"></h2>
        <div id="tutorialDescription" class="tutorial-description"></div>
        <div class="tutorial-actions">
          <button
            id="tutorialSecondaryAction"
            class="tutorial-button tutorial-secondary hidden"
            type="button"
            data-tutorial-exempt="true"
          ></button>
          <button
            id="tutorialPrimaryAction"
            class="tutorial-button tutorial-primary"
            type="button"
            data-tutorial-exempt="true"
          ></button>
        </div>
      </div>
    </div>
    <div
      id="routeTooltip"
      class="route-tooltip"
      role="status"
      aria-live="polite"
      aria-hidden="true"
    ></div>
    <div
      id="locationModal"
      class="location-modal hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="locationModalTitle"
    >
      <div class="location-modal-content">
        <div class="location-modal-header">
          <h2 id="locationModalTitle" class="location-modal-title">Select a wall</h2>
          <button id="locationModalClose" class="location-modal-close" type="button" aria-label="Close wall selector">
            ×
          </button>
        </div>
        <div id="locationOptions" class="location-options" role="listbox"></div>
      </div>
    </div>
    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
        updateProfile,
        deleteUser,
        getIdTokenResult,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        serverTimestamp,
        collection,
        getDocs,
        query,
        limit,
        where,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
      import { firebaseConfig } from './config.js';

      const firebaseApp = initializeApp(firebaseConfig);
      const auth = getAuth(firebaseApp);

      const db = getFirestore(firebaseApp);

      const authOverlay = document.getElementById('authOverlay');
      const appContent = document.getElementById('appContent');
      const authForm = document.getElementById('authForm');
      const authUsername = document.getElementById('authUsername');
      const authPassword = document.getElementById('authPassword');
      const authError = document.getElementById('authError');
      const authTitle = document.getElementById('authTitle');
      const authSwitchLabel = document.getElementById('authSwitchLabel');
      const toggleAuthModeButton = document.getElementById('toggleAuthMode');
      const loginButton = document.getElementById('loginButton');
      const setterLink = document.getElementById('setterLink');
      const setterLinkBaseHref = setterLink?.getAttribute('href') || 'setter.html';
      const tooltip = document.getElementById('routeTooltip');
      const infoButton = document.getElementById('infoButton');
      const infoPopover = document.getElementById('infoPopover');
      const locationButton = document.getElementById('locationButton');
      const viewToggleButton = document.getElementById('viewToggle');
      const progressionButton = document.getElementById('progressionButton');
      const locationModal = document.getElementById('locationModal');
      const locationOptions = document.getElementById('locationOptions');
      const locationModalClose = document.getElementById('locationModalClose');
      const progressionModal = document.getElementById('progressionModal');
      const progressionModalClose = document.getElementById('progressionModalClose');
      const progressionList = document.getElementById('progressionList');
      const tutorialPromptButton = document.getElementById('tutorialPromptButton');
      const tutorialOverlay = document.getElementById('tutorialOverlay');
      const tutorialDialogCard = document.getElementById('tutorialDialogCard');
      const tutorialTitle = document.getElementById('tutorialTitle');
      const tutorialDescription = document.getElementById('tutorialDescription');
      const tutorialPrimaryAction = document.getElementById('tutorialPrimaryAction');
      const tutorialSecondaryAction = document.getElementById('tutorialSecondaryAction');
      const tutorialProgress = document.getElementById('tutorialProgress');

      let infoHighlightsContainer = null;
      let infoModeActive = false;
      let awaitingInfoTargetSelection = false;
      let activeInfoCallout = null;
      let pendingInfoRepositionFrame = null;
      let ephemeralCalloutDismissTimer = null;
      let tutorialPromptTimeoutId = null;
      let tutorialPromptVisible = false;
      let tutorialInviteOpen = false;
      let tutorialActive = false;
      let tutorialCompleted = false;
      let tutorialStepIndex = -1;
      let tutorialTransitionInProgress = false;
      let tutorialHighlightedRouteId = null;
      let tutorialHighlightedElement = null;
      let tutorialHighlightedElementOptions = { illuminate: false };
      let tutorialPreviousFocus = null;
      let tutorialOverlayMode = 'hidden';
      let tutorialLastActivityTimestamp = 0;
      let tutorialPreviousViewMode = null;

      const LOCATIONS = [
        { key: 'new-wall', name: 'New Wall', image: './location/New Wall.jpg', hidden: false },
        { key: 'old-wall', name: 'Old Wall', image: './location/Old Wall.jpg', hidden: false },
      ];

      const isLocationVisible = (location) => !!location && location.hidden !== true;

      const getDefaultLocation = () => LOCATIONS.find(isLocationVisible) || null;

      const LOCATION_STORAGE_KEY = 'ascend.selectedWall';
      const WALL_QUERY_PARAM = 'wall';

      function ensureInfoHighlightsContainer() {
        if (infoHighlightsContainer && document.body?.contains(infoHighlightsContainer)) {
          return infoHighlightsContainer;
        }

        if (!document.body) {
          return null;
        }

        const container = document.createElement('div');
        container.id = 'infoHighlights';
        container.className = 'info-highlights hidden';
        document.body.appendChild(container);
        infoHighlightsContainer = container;
        return container;
      }

      function clearInfoHighlights() {
        const container = ensureInfoHighlightsContainer();
        if (!container) {
          return;
        }

        if (pendingInfoRepositionFrame) {
          cancelAnimationFrame(pendingInfoRepositionFrame);
          pendingInfoRepositionFrame = null;
        }

        if (ephemeralCalloutDismissTimer) {
          clearTimeout(ephemeralCalloutDismissTimer);
          ephemeralCalloutDismissTimer = null;
        }

        container.innerHTML = '';
        container.classList.add('hidden');
        activeInfoCallout = null;
      }

      function createBasicCallout(title, lines = []) {
        const callout = document.createElement('div');
        callout.className = 'info-callout';

        if (title) {
          const heading = document.createElement('strong');
          heading.textContent = title;
          callout.appendChild(heading);
        }

        lines
          .filter((line) => typeof line === 'string' && line.trim().length)
          .forEach((line) => {
            const paragraph = document.createElement('p');
            paragraph.textContent = line;
            callout.appendChild(paragraph);
          });

        return callout;
      }

      function createGradeChartElement() {
        const chart = document.createElement('div');
        chart.className = 'info-callout-chart';
        chart.setAttribute('aria-hidden', 'true');

        const gradeEntries = Array.from(GRADE_COLOR_MAP.entries());
        const totalGrades = gradeEntries.length;
        const minimumHeight = 22;
        const maximumHeight = 100;
        const heightRange = maximumHeight - minimumHeight;

        gradeEntries.forEach(([grade, color], index) => {
          const bar = document.createElement('span');
          bar.className = 'info-callout-chart-bar';
          const relative = totalGrades > 1 ? index / (totalGrades - 1) : 0;
          const heightPercent = minimumHeight + relative * heightRange;
          bar.style.height = `${heightPercent}%`;
          bar.style.backgroundColor = color;
          bar.dataset.grade = String(grade);
          chart.appendChild(bar);
        });

        return chart;
      }

      function isElementVisible(element) {
        if (!element) {
          return false;
        }

        if (element.classList?.contains('hidden')) {
          return false;
        }

        const rect = element.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0;
      }

      function buildViewModeCallout() {
        if (!viewToggleButton) {
          return null;
        }

        const showingGradeColors = viewMode === VIEW_MODE_GRADE_COLORS;
        const title = showingGradeColors ? 'Grade colors' : 'Hold colors';
        const lines = showingGradeColors
          ? [
              'Routes are tinted by difficulty right now.',
              'The spectrum below runs from the easiest greens on the left to the hardest reds on the right, covering every grade color.',
            ]
          : [
              'Routes are showing the color of each hold set.',
              'Toggle to reveal grade colors and compare difficulty at a glance.',
            ];

        const callout = createBasicCallout(title, lines);
        if (showingGradeColors) {
          callout.appendChild(createGradeChartElement());
        }

        return {
          target: viewToggleButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildSetterCallout() {
        if (!setterLink || !isElementVisible(setterLink)) {
          return null;
        }

        const callout = createBasicCallout('Setter tools', [
          'Open the route-setting workspace to draw climbs for this wall.',
        ]);

        return {
          target: setterLink,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildLocationCallout() {
        if (!locationButton) {
          return null;
        }

        const callout = createBasicCallout('Wall selector', [
          'Choose a different wall or angle to load its background and routes.',
        ]);

        return {
          target: locationButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildProgressionCallout() {
        if (!progressionButton) {
          return null;
        }

        const callout = createBasicCallout('Progression tracker', [
          'Open a sortable list of every visible climb.',
          'Completed routes show a green tick beside their grade.',
        ]);

        return {
          target: progressionButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildLoginCallout() {
        if (!loginButton || !isElementVisible(loginButton)) {
          return null;
        }

        const callout = createBasicCallout('Log in', [
          'Visit your personal dashboard to sign in or manage ascents.',
        ]);

        return {
          target: loginButton,
          element: callout,
          options: { placement: 'bottom', offset: 14 },
        };
      }

      function buildRouteAscentCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const isMarkedAscended = target.getAttribute('aria-pressed') === 'true';
        const title = isMarkedAscended ? 'Marked ascended' : 'Not ascended';
        const callout = createBasicCallout(title, [
          'Toggle this when you send the climb to track your personal ascents.',
          'Turn it off again to keep projects on your list.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function buildRouteFocusCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const isFocused = target.getAttribute('aria-pressed') === 'true';
        const callout = createBasicCallout('Focus view', [
          isFocused
            ? 'All routes are visible again. Toggle Focus to isolate a single climb.'
            : 'Show only this route to inspect its holds without distractions.',
          'Use it to study beta before hopping back to the full wall.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function buildRouteGradeCallout(context = {}) {
        const target = context?.target instanceof Element ? context.target : null;
        if (!target || !isElementVisible(target)) {
          return null;
        }

        const callout = createBasicCallout('Your grade', [
          'This is your personal grade — how you think the climb feels.',
          'Your grade helps shape the community average shown in the top right.',
        ]);

        return {
          target,
          element: callout,
          options: { placement: 'top', offset: 12 },
        };
      }

      function positionCallout(entry) {
        if (!entry?.target || !entry?.element) {
          return;
        }

        const targetRect = entry.target.getBoundingClientRect();
        if (targetRect.width === 0 && targetRect.height === 0) {
          entry.element.style.opacity = '0';
          return;
        }

        entry.element.style.opacity = '1';

        const placement = entry.options?.placement === 'top' ? 'top' : 'bottom';
        const offset = Number.isFinite(entry.options?.offset) ? entry.options.offset : 14;
        const margin = Number.isFinite(entry.options?.margin) ? entry.options.margin : 16;
        const targetCenterX = targetRect.left + targetRect.width / 2;

        if (placement === 'top') {
          entry.element.dataset.arrow = 'bottom';
          entry.element.style.top = `${targetRect.top - offset}px`;
          entry.element.style.transform = 'translate(-50%, -100%)';
        } else {
          entry.element.dataset.arrow = 'top';
          entry.element.style.top = `${targetRect.bottom + offset}px`;
          entry.element.style.transform = 'translate(-50%, 0)';
        }

        const calloutRect = entry.element.getBoundingClientRect();
        const calloutWidth = calloutRect.width;
        const minCenter = margin + calloutWidth / 2;
        const maxCenter = window.innerWidth - margin - calloutWidth / 2;
        const clampedCenter = clamp(targetCenterX, minCenter, maxCenter);
        entry.element.style.left = `${clampedCenter}px`;

        const updatedRect = entry.element.getBoundingClientRect();
        const arrowOffset = clamp(targetCenterX - updatedRect.left, 12, updatedRect.width - 12);
        entry.element.style.setProperty('--callout-arrow-offset', `${arrowOffset}px`);
      }

      function scheduleInfoHighlightsReposition() {
        if (!activeInfoCallout) {
          return;
        }

        if (pendingInfoRepositionFrame) {
          cancelAnimationFrame(pendingInfoRepositionFrame);
        }

        pendingInfoRepositionFrame = requestAnimationFrame(() => {
          pendingInfoRepositionFrame = null;
          if (activeInfoCallout) {
            positionCallout(activeInfoCallout);
          }
        });
      }

      function showInfoCallout(entry) {
        if (!entry?.element) {
          return;
        }

        const container = ensureInfoHighlightsContainer();
        if (!container) {
          return;
        }

        container.innerHTML = '';
        container.classList.remove('hidden');
        container.appendChild(entry.element);
        activeInfoCallout = entry;

        requestAnimationFrame(() => {
          if (activeInfoCallout === entry) {
            positionCallout(entry);
          }
        });
      }

      function showTemporaryInfoCallout(entry, duration = 8000) {
        if (!entry) {
          return;
        }

        showInfoCallout(entry);

        if (ephemeralCalloutDismissTimer) {
          clearTimeout(ephemeralCalloutDismissTimer);
        }

        const timeout = Number.isFinite(duration) && duration > 0 ? duration : 8000;
        ephemeralCalloutDismissTimer = window.setTimeout(() => {
          ephemeralCalloutDismissTimer = null;
          if (activeInfoCallout === entry) {
            clearInfoHighlights();
          }
        }, timeout);
      }

      function setInfoButtonActiveState(active) {
        if (!infoButton) {
          return;
        }

        infoButton.setAttribute('aria-pressed', active ? 'true' : 'false');
        infoButton.setAttribute('aria-expanded', active ? 'true' : 'false');
        infoButton.classList.toggle('is-active', active);
      }

      function hideInfoPopover() {
        if (!infoPopover) {
          return;
        }

        infoPopover.classList.add('hidden');
        infoPopover.setAttribute('aria-hidden', 'true');
      }

      function activateInfoMode() {
        infoModeActive = true;
        awaitingInfoTargetSelection = true;
        setInfoButtonActiveState(true);
        clearInfoHighlights();

        if (infoPopover) {
          infoPopover.classList.remove('hidden');
          infoPopover.setAttribute('aria-hidden', 'false');
          if (typeof infoPopover.focus === 'function') {
            infoPopover.focus({ preventScroll: true });
          }
        }
      }

      function deactivateInfoMode({ clearCallout = false } = {}) {
        awaitingInfoTargetSelection = false;

        if (infoModeActive) {
          infoModeActive = false;
        }

        setInfoButtonActiveState(false);
        hideInfoPopover();

        if (clearCallout) {
          clearInfoHighlights();
        }

      }

      function toggleInfoMode() {
        if (infoModeActive) {
          deactivateInfoMode({ clearCallout: true });
        } else {
          activateInfoMode();
        }
      }

      function handleInfoRequestFor(targetKey, event, context = {}) {
        if (!infoModeActive || !awaitingInfoTargetSelection) {
          return false;
        }

        awaitingInfoTargetSelection = false;

        if (event) {
          if (typeof event.preventDefault === 'function') {
            event.preventDefault();
          }
          if (typeof event.stopPropagation === 'function') {
            event.stopPropagation();
          }
        }

        let entry = null;
        switch (targetKey) {
          case 'view-toggle':
            entry = buildViewModeCallout();
            break;
          case 'setter-link':
            entry = buildSetterCallout();
            break;
          case 'location':
            entry = buildLocationCallout();
            break;
          case 'progression':
            entry = buildProgressionCallout();
            break;
          case 'log-in':
            entry = buildLoginCallout();
            break;
          case 'route-ascent':
            entry = buildRouteAscentCallout(context);
            break;
          case 'route-focus':
            entry = buildRouteFocusCallout(context);
            break;
          case 'route-grade':
            entry = buildRouteGradeCallout(context);
            break;
          default:
            break;
        }

        if (entry) {
          showInfoCallout(entry);
          deactivateInfoMode({ clearCallout: false });
        } else {
          deactivateInfoMode({ clearCallout: true });
        }

        return true;
      }

      const PATH_TYPE_BREZER = 'brezer';
      const PATH_TYPE_POINT = 'point';
      const PATH_TYPE_RECTANGLE = 'rectangle';
      const DEFAULT_PATH_TYPE = PATH_TYPE_BREZER;
      const MIN_POINT_DIAMETER = 12;
      const MAX_POINT_DIAMETER = 160;
      const DEFAULT_POINT_DIAMETER = 48;
      const MIN_RECTANGLE_SIZE = 12;
      const MAX_RECTANGLE_SIZE = 200;
      const DEFAULT_RECTANGLE_WIDTH = 80;
      const DEFAULT_RECTANGLE_HEIGHT = 60;
      const MIN_GRADE_VALUE = 1;
      const MAX_GRADE_VALUE = 31;
      const MIN_GRADE_BAR_BASE_HEIGHT = 0;
      const MAX_GRADE_BAR_HEIGHT = 1000;
      const DEFAULT_GRADE_BAR_BASE_HEIGHT = 40;
      const DEFAULT_GRADE_BAR_MAX_HEIGHT = 220;
      const MIN_GRADE_BAR_WIDTH = 4;
      const MAX_GRADE_BAR_WIDTH = 160;
      const DEFAULT_GRADE_BAR_WIDTH = 24;
      const DEFAULT_GRADE_BAR_TRANSPARENCY = 0.85;
      const MIN_UNFOCUSED_TRANSPARENCY = 0;
      const MAX_UNFOCUSED_TRANSPARENCY = 1;
      const DEFAULT_UNFOCUSED_TRANSPARENCY = 0.25;
      const WALL_COLLECTION = 'walls';
      const GRADE_COLOR_MAP = new Map([
        [1, '#2F7E13'],
        [2, '#378B14'],
        [3, '#3E9015'],
        [4, '#459616'],
        [5, '#4BA218'],
        [6, '#50AE1A'],
        [7, '#59B51A'],
        [8, '#60BA19'],
        [9, '#68BF16'],
        [10, '#71C314'],
        [11, '#87C112'],
        [12, '#92C510'],
        [13, '#C6D208'],
        [14, '#DDD805'],
        [15, '#F3DF01'],
        [16, '#F6C20E'],
        [17, '#EEA21C'],
        [18, '#EA9621'],
        [19, '#E78A27'],
        [20, '#E37B27'],
        [21, '#E06A23'],
        [22, '#DC5A1E'],
        [23, '#D94A1B'],
        [24, '#D63F18'],
        [25, '#D33314'],
        [26, '#D02711'],
        [27, '#CE1A0D'],
        [28, '#C90E0B'],
        [29, '#C50809'],
        [30, '#C10407'],
        [31, '#BD0306'],
      ]);
      const VIEW_MODE_HOLD_COLORS = 'hold-colors';
      const VIEW_MODE_GRADE_COLORS = 'grade-colors';

      function normalizePathType(value) {
        if (typeof value === 'string') {
          const normalized = value.trim().toLowerCase();
          if (normalized === PATH_TYPE_POINT) {
            return PATH_TYPE_POINT;
          }
          if (normalized === PATH_TYPE_RECTANGLE) {
            return PATH_TYPE_RECTANGLE;
          }
        }
        return DEFAULT_PATH_TYPE;
      }

      function normalizePointDiameter(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_POINT_DIAMETER;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_POINT_DIAMETER),
          MAX_POINT_DIAMETER,
        );
        return clamped;
      }

      function normalizeRectangleSize(value, fallback = DEFAULT_RECTANGLE_WIDTH) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallback;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_RECTANGLE_SIZE),
          MAX_RECTANGLE_SIZE,
        );
        return clamped;
      }

      function normalizeGradeBarHeight(value, fallback) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallback;
        }
        const clamped = Math.min(
          Math.max(numeric, MIN_GRADE_BAR_BASE_HEIGHT),
          MAX_GRADE_BAR_HEIGHT,
        );
        return Math.round(clamped);
      }

      function normalizeGradeBarWidth(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_WIDTH;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_GRADE_BAR_WIDTH),
          MAX_GRADE_BAR_WIDTH,
        );
        return clamped;
      }

      function normalizeGradeBarTransparency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_TRANSPARENCY;
        }
        const clamped = Math.min(Math.max(numeric, 0), 1);
        return Math.round(clamped * 1000) / 1000;
      }

      function normalizeUnfocusedTransparency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_UNFOCUSED_TRANSPARENCY;
        }
        const clamped = Math.min(
          Math.max(numeric, MIN_UNFOCUSED_TRANSPARENCY),
          MAX_UNFOCUSED_TRANSPARENCY,
        );
        return Math.round(clamped * 1000) / 1000;
      }

      function normalizeWallSettings(raw = {}) {
        if (!raw || typeof raw !== 'object') {
          return {
            pointDiameter: DEFAULT_POINT_DIAMETER,
            rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
            rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
            gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
            gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
            gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
            gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
            unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
          };
        }

        const pointDiameter = normalizePointDiameter(raw.pointDiameter);
        const rectangleWidth = normalizeRectangleSize(
          raw.rectangleWidth,
          DEFAULT_RECTANGLE_WIDTH,
        );
        const rectangleHeight = normalizeRectangleSize(
          raw.rectangleHeight,
          DEFAULT_RECTANGLE_HEIGHT,
        );
        const gradeBarBaseHeight = normalizeGradeBarHeight(
          raw.gradeBarBaseHeight,
          DEFAULT_GRADE_BAR_BASE_HEIGHT,
        );
        const gradeBarMaxHeight = Math.max(
          gradeBarBaseHeight,
          normalizeGradeBarHeight(raw.gradeBarMaxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
        );
        const gradeBarWidth = normalizeGradeBarWidth(raw.gradeBarWidth);
        const gradeBarTransparency = normalizeGradeBarTransparency(
          raw.gradeBarTransparency ?? raw.transparency,
        );
        const unfocusedTransparency = normalizeUnfocusedTransparency(
          raw.unfocusedTransparency ?? raw.unfocused_transparency,
        );

        return {
          pointDiameter,
          rectangleWidth,
          rectangleHeight,
          gradeBarBaseHeight,
          gradeBarMaxHeight,
          gradeBarWidth,
          gradeBarTransparency,
          unfocusedTransparency,
        };
      }

      const wallSettingsCache = new Map();

      const normalizeLocationName = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      const normalizeWallKey = (value) => normalizeLocationName(value);

      function resolveWallSettings(locationKey, fallback = null) {
        const key = normalizeWallKey(locationKey);
        if (key) {
          const cached = wallSettingsCache.get(key);
          if (cached) {
            return { ...cached };
          }
        }

        if (fallback) {
          const normalized = normalizeWallSettings(fallback);
          if (key) {
            wallSettingsCache.set(key, normalized);
          }
          return normalized;
        }

        return {
          pointDiameter: DEFAULT_POINT_DIAMETER,
          rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
          rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
          gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
          gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
          gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
          gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
          unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
        };
      }

      const findLocationByKey = (key) =>
        LOCATIONS.find((location) => location.key === key && isLocationVisible(location));

      const findLocationByName = (name) => {
        const normalized = normalizeLocationName(name);
        return (
          LOCATIONS.find(
            (location) => normalizeLocationName(location.name) === normalized && isLocationVisible(location),
          ) || null
        );
      };

      function buildWallAwareHref(baseHref, wallKey) {
        const normalizedKey = normalizeWallKey(wallKey);
        if (typeof baseHref !== 'string' || !baseHref) {
          return '';
        }

        try {
          const url = new URL(baseHref, window.location.origin);
          if (normalizedKey) {
            url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
          } else {
            url.searchParams.delete(WALL_QUERY_PARAM);
          }
          url.hash = '';
          const relativePath = `${url.pathname.replace(/^\//, '')}${url.search}`;
          return relativePath || baseHref;
        } catch (error) {
          if (!normalizedKey) {
            return baseHref;
          }

          const separator = baseHref.includes('?') ? '&' : '?';
          return `${baseHref}${separator}${encodeURIComponent(WALL_QUERY_PARAM)}=${encodeURIComponent(normalizedKey)}`;
        }
      }

      function getWallKeyFromQuery() {
        try {
          const params = new URLSearchParams(window.location.search);
          const raw = params.get(WALL_QUERY_PARAM);
          return normalizeWallKey(raw);
        } catch (error) {
          console.warn('Unable to read wall from query string:', error);
          return '';
        }
      }

      function updateWallQueryParam(wallKey) {
        try {
          const normalizedKey = normalizeWallKey(wallKey);
          const url = new URL(window.location.href);
          if (normalizedKey) {
            url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
          } else {
            url.searchParams.delete(WALL_QUERY_PARAM);
          }
          url.hash = '';
          const next = url.toString();
          if (next !== window.location.href) {
            window.history.replaceState({}, '', next);
          }
        } catch (error) {
          console.warn('Unable to update wall query parameter:', error);
        }
      }

      function persistSelectedWall(wallKey) {
        const normalizedKey = normalizeWallKey(wallKey);
        try {
          if (normalizedKey) {
            window.localStorage?.setItem(LOCATION_STORAGE_KEY, normalizedKey);
          } else {
            window.localStorage?.removeItem(LOCATION_STORAGE_KEY);
          }
        } catch (error) {
          console.warn('Unable to persist location preference:', error);
        }
      }

      function upsertLocation({
        key = '',
        name = '',
        image = '',
        fallbackName = '',
        hidden = false,
      } = {}) {
        const trimmedName = typeof name === 'string' && name.trim() ? name.trim() : '';
        const fallback =
          trimmedName || (typeof fallbackName === 'string' && fallbackName.trim() ? fallbackName.trim() : '');
        const keySource = typeof key === 'string' && key.trim() ? key.trim() : fallback;
        const normalizedKey = normalizeWallKey(keySource);
        const displayName = fallback;
        if (!normalizedKey || !displayName) {
          return { entry: null, changed: false };
        }

        const normalizedImage = typeof image === 'string' ? image.trim() : '';
        const normalizedHidden = Boolean(hidden);
        const existingIndex = LOCATIONS.findIndex((location) => {
          if (!location) {
            return false;
          }
          if (location.key === normalizedKey) {
            return true;
          }
          return normalizeLocationName(location.name) === normalizeLocationName(displayName);
        });

        if (existingIndex >= 0) {
          const existing = LOCATIONS[existingIndex];
          const needsUpdate =
            existing.key !== normalizedKey || existing.name !== displayName || existing.image !== normalizedImage;

          if (!needsUpdate) {
            const hiddenChanged = Boolean(existing.hidden) !== normalizedHidden;
            if (hiddenChanged) {
              existing.hidden = normalizedHidden;
              return { entry: existing, changed: true };
            }
            return { entry: existing, changed: false };
          }

          const updated = {
            ...existing,
            key: normalizedKey,
            name: displayName,
            image: normalizedImage,
            hidden: normalizedHidden,
          };
          LOCATIONS[existingIndex] = updated;
          return { entry: updated, changed: true };
        }

        const created = {
          key: normalizedKey,
          name: displayName,
          image: normalizedImage,
          hidden: normalizedHidden,
        };
        LOCATIONS.push(created);
        return { entry: created, changed: true };
      }

      function ensureCurrentLocationVisible() {
        if (isLocationVisible(currentLocation)) {
          return;
        }

        const fallback = getDefaultLocation();
        if (fallback) {
          const changed = !currentLocation || currentLocation.key !== fallback.key;
          currentLocation = fallback;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          updateBackgroundForCurrentLocation();
          const fallbackKey = getCurrentLocationKey();
          if (fallbackKey) {
            persistSelectedWall(fallbackKey);
            updateWallQueryParam(fallbackKey);
          } else {
            persistSelectedWall('');
            updateWallQueryParam('');
          }
          updateSetterLinkHref();
          if (changed) {
            applyLocationFilter();
          }
          return;
        }

        currentLocation = null;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();
        persistSelectedWall('');
        updateWallQueryParam('');
        updateSetterLinkHref();
        applyLocationFilter();
      }

      function synchronizeCurrentLocationReference() {
        if (!currentLocation) {
          ensureCurrentLocationVisible();
          return;
        }

        const normalizedKey = normalizeWallKey(currentLocation.key || currentLocation.name);
        const refreshed =
          (normalizedKey && findLocationByKey(normalizedKey)) ||
          findLocationByName(currentLocation.name);

        if (refreshed && refreshed !== currentLocation) {
          currentLocation = refreshed;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          updateBackgroundForCurrentLocation();
          const refreshedKey = getCurrentLocationKey();
          if (refreshedKey) {
            persistSelectedWall(refreshedKey);
            updateWallQueryParam(refreshedKey);
          } else {
            persistSelectedWall('');
            updateWallQueryParam('');
          }
          updateSetterLinkHref();
        }

        ensureCurrentLocationVisible();
      }

      let currentLocation = getDefaultLocation();

      function getCurrentLocationKey() {
        return normalizeWallKey(currentLocation?.key || currentLocation?.name);
      }

      function updateSetterLinkHref() {
        if (!setterLink) {
          return;
        }

        const wallKey = getCurrentLocationKey();
        setterLink.href = buildWallAwareHref(setterLinkBaseHref, wallKey);
      }

      let backgroundReady = false;
      let backgroundImageSource = '';
      let viewMode = VIEW_MODE_HOLD_COLORS;

      const backgroundImage = new Image();

      function updateLocationButtonLabel() {
        const labelText = currentLocation?.name || 'Select wall';
        if (locationButton) {
          locationButton.setAttribute('aria-label', `Select wall: ${labelText}`);
          locationButton.setAttribute('title', labelText);
        }
      }

      function syncViewModeState() {
        if (!document.body) {
          return;
        }
        document.body.classList.toggle('view-mode-grade-colors', viewMode === VIEW_MODE_GRADE_COLORS);
        document.body.classList.toggle('view-mode-hold-colors', viewMode === VIEW_MODE_HOLD_COLORS);
      }

      function updateViewToggleButton() {
        if (!viewToggleButton) {
          return;
        }

        const showingGradeColors = viewMode === VIEW_MODE_GRADE_COLORS;
        const labelText = showingGradeColors ? 'Show Hold Colors' : 'Show Grade Colors';
        viewToggleButton.setAttribute('aria-pressed', showingGradeColors ? 'true' : 'false');
        viewToggleButton.setAttribute('aria-label', labelText);
        viewToggleButton.setAttribute('title', labelText);
      }

      function setViewMode(mode) {
        const normalized =
          mode === VIEW_MODE_GRADE_COLORS ? VIEW_MODE_GRADE_COLORS : VIEW_MODE_HOLD_COLORS;
        if (viewMode === normalized) {
          return;
        }

        viewMode = normalized;
        syncViewModeState();
        updateViewToggleButton();
        hideTooltip({ force: true });
        if (canvas) {
          canvas.style.cursor = '';
        }
        redraw();
      }

      function updateLocationOptionsState() {
        if (!locationOptions) {
          return;
        }

        const buttons = locationOptions.querySelectorAll('[data-location-key]');
        buttons.forEach((button) => {
          const key = button?.dataset?.locationKey;
          if (key && currentLocation && key === currentLocation.key) {
            button.setAttribute('aria-current', 'true');
          } else {
            button.removeAttribute('aria-current');
          }
        });
      }

      function applyBodyBackground(imagePath) {
        if (!document.body) {
          return;
        }

        if (imagePath) {
          document.body.style.setProperty('--wall-background', `url('${imagePath}')`);
        } else {
          document.body.style.removeProperty('--wall-background');
        }
      }

      function updateBackgroundForCurrentLocation() {
        const imagePath = currentLocation?.image || '';
        applyBodyBackground(imagePath);

        if (imagePath && imagePath !== backgroundImageSource) {
          backgroundImageSource = imagePath;
          backgroundReady = false;
          backgroundImage.src = imagePath;
        } else if (!imagePath) {
          backgroundImageSource = '';
          backgroundReady = false;
        }
      }

      backgroundImage.onload = () => {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      };

      backgroundImage.onerror = () => {
        backgroundReady = false;
        resizeCanvas();
      };

      function closeLocationModal() {
        if (!locationModal) {
          return;
        }

        if (!locationModal.classList.contains('hidden')) {
          locationModal.classList.add('hidden');
          locationModal.setAttribute('aria-hidden', 'true');
          locationButton?.setAttribute('aria-expanded', 'false');
        }

        locationModal.classList.remove('is-top-aligned');
      }

      function openLocationModal() {
        if (!locationModal) {
          return;
        }

        locationModal.classList.remove('hidden');
        locationModal.setAttribute('aria-hidden', 'false');
        locationButton?.setAttribute('aria-expanded', 'true');
        updateLocationOptionsState();
      }

      function handleLocationSelection(locationKey) {
        const location = findLocationByKey(locationKey);
        if (!location) {
          return;
        }

        const changed = !currentLocation || currentLocation.key !== location.key;
        currentLocation = location;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();

        const nextLocationKey = getCurrentLocationKey();
        if (nextLocationKey) {
          persistSelectedWall(nextLocationKey);
        }
        updateWallQueryParam(nextLocationKey);
        updateSetterLinkHref();

        if (changed) {
          applyLocationFilter();
        }

        closeLocationModal();
      }

      function renderLocationOptions() {
        if (!locationOptions) {
          return;
        }

        locationOptions.replaceChildren();

        LOCATIONS.filter(isLocationVisible).forEach((location) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'location-option';
          button.dataset.locationKey = location.key;
          button.setAttribute('role', 'option');

          const preview = document.createElement('div');
          preview.className = 'location-option-preview';
          preview.style.backgroundImage = `url('${location.image}')`;
          button.appendChild(preview);

          const label = document.createElement('span');
          label.className = 'location-option-label';
          label.textContent = location.name;
          button.appendChild(label);

          button.addEventListener('click', () => {
            handleLocationSelection(location.key);
          });

          locationOptions.appendChild(button);
        });

        updateLocationOptionsState();
      }

      const SYNTHETIC_EMAIL_DOMAIN = 'users.anuascend.local';
      const USERNAME_PATTERN = /^[a-z0-9_]{3,20}$/;

      const normalizeUsername = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      function cacheAuthenticatedUsername(username) {
        const normalized = normalizeUsername(username);
        authenticatedUsernameClaim = isValidUsername(normalized) ? normalized : '';
        return authenticatedUsernameClaim;
      }

      async function resolveAuthenticatedUsername(options = {}) {
        const { forceRefresh = false } = options;

        if (!currentUser) {
          authenticatedUsernameClaim = '';
          return isValidUsername(currentUsername) ? normalizeUsername(currentUsername) : '';
        }

        if (!forceRefresh) {
          const cachedClaim = normalizeUsername(authenticatedUsernameClaim);
          if (isValidUsername(cachedClaim)) {
            return cachedClaim;
          }
        }

        const fallbackUsername = isValidUsername(currentUsername)
          ? normalizeUsername(currentUsername)
          : '';

        try {
          const tokenResult = await getIdTokenResult(currentUser, forceRefresh);
          const claimUsername = normalizeUsername(tokenResult?.claims?.username);

          if (isValidUsername(claimUsername)) {
            return cacheAuthenticatedUsername(claimUsername);
          }
        } catch (error) {
          console.warn(
            forceRefresh
              ? 'Failed to refresh authenticated username claim:'
              : 'Failed to read authenticated username claim:',
            error,
          );
        }

        if (!forceRefresh) {
          return resolveAuthenticatedUsername({ forceRefresh: true });
        }

        if (fallbackUsername) {
          return cacheAuthenticatedUsername(fallbackUsername);
        }

        return '';
      }

      const buildSyntheticEmail = (username) => {
        const normalized = normalizeUsername(username);
        return normalized ? `${normalized}@${SYNTHETIC_EMAIL_DOMAIN}` : '';
      };

      const isValidUsername = (value) => USERNAME_PATTERN.test(normalizeUsername(value));

      const tooltipColorCanvas = document.createElement('canvas');
      const tooltipColorContext = tooltipColorCanvas.getContext('2d');

      function getTextColor(bgColor) {
        const context = document.createElement('canvas').getContext('2d');
        if (!context) {
          return '#fff';
        }

        context.fillStyle = '#000';
        context.fillStyle = bgColor;
        const values = context.fillStyle.match(/\d+/g);

        if (!values || values.length < 3) {
          return '#fff';
        }

        const [r, g, b] = values.map(Number);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        return luminance > 0.5 ? '#000' : '#fff';
      }

      function parseTooltipColor(color) {
        if (!tooltipColorContext || typeof color !== 'string') {
          return null;
        }

        let normalized;
        try {
          tooltipColorContext.fillStyle = '#000000';
          tooltipColorContext.fillStyle = color;
          normalized = tooltipColorContext.fillStyle;
        } catch (error) {
          return null;
        }

        if (typeof normalized !== 'string' || !normalized) {
          return null;
        }

        if (/^#[0-9a-f]{6}$/i.test(normalized)) {
          const r = parseInt(normalized.slice(1, 3), 16);
          const g = parseInt(normalized.slice(3, 5), 16);
          const b = parseInt(normalized.slice(5, 7), 16);
          return { r, g, b, hex: normalized };
        }

        const rgbaMatch = normalized
          .replace(/\s+/g, '')
          .match(/^rgba?\((\d+),(\d+),(\d+)(?:,(0|1|0?\.\d+))?\)$/i);

        if (rgbaMatch) {
          const [, r, g, b] = rgbaMatch;
          return {
            r: Number.parseInt(r, 10),
            g: Number.parseInt(g, 10),
            b: Number.parseInt(b, 10),
            hex: null,
          };
        }

        return null;
      }

      function deriveTooltipColorScheme(color) {
        const parsed = parseTooltipColor(color);

        if (!parsed) {
          return null;
        }

        const clamp = (value) => Math.max(0, Math.min(255, value));
        const r = clamp(parsed.r);
        const g = clamp(parsed.g);
        const b = clamp(parsed.b);
        const rgbString = `${r}, ${g}, ${b}`;
        const accent = parsed.hex ? parsed.hex : `rgb(${rgbString})`;
        const soft = `rgba(${rgbString}, 0.18)`;
        const strong = `rgba(${rgbString}, 0.85)`;
        const surfaceFactor = 0.22;
        const surfaceOffset = 18;
        const mixChannel = (channel) => clamp(Math.round(channel * surfaceFactor + surfaceOffset));
        const surface = `rgb(${mixChannel(r)}, ${mixChannel(g)}, ${mixChannel(b)})`;
        const onAccent = getTextColor(strong);
        const foreground = getTextColor(surface);
        const softForeground = foreground;
        const mutedForeground = foreground === '#000' ? '#333333' : '#d1d5db';

        return {
          accent,
          rgb: rgbString,
          soft,
          strong,
          onAccent,
          foreground,
          softForeground,
          mutedForeground,
          surface,
          border: accent,
        };
      }

      const FALLBACK_TOOLTIP_SCHEME = (() => {
        const defaultRgb = '126, 217, 87';
        const soft = 'rgba(126, 217, 87, 0.18)';
        const strong = 'rgba(126, 217, 87, 0.85)';
        const surface = 'rgb(43, 71, 47)';
        const foreground = getTextColor(surface);

        return {
          accent: '#7ed957',
          rgb: defaultRgb,
          soft,
          strong,
          onAccent: getTextColor(strong),
          foreground,
          softForeground: foreground,
          mutedForeground: foreground === '#000' ? '#333333' : '#d1d5db',
          surface,
          border: '#7ed957',
        };
      })();

      const DEFAULT_TOOLTIP_SCHEME =
        deriveTooltipColorScheme('#7ed957') ?? FALLBACK_TOOLTIP_SCHEME;

      function applyTooltipColorScheme(route) {
        if (!tooltip) {
          return;
        }

        const base = DEFAULT_TOOLTIP_SCHEME;
        const scheme = deriveTooltipColorScheme(getRouteDisplayColor(route)) ?? base;

        const accent = scheme.accent ?? base.accent;
        const rgb = scheme.rgb ?? base.rgb;
        const soft = scheme.soft ?? base.soft;
        const strong = scheme.strong ?? base.strong;
        const onAccent = scheme.onAccent ?? base.onAccent;
        const foreground = scheme.foreground ?? base.foreground;
        const softForeground = scheme.softForeground ?? base.softForeground;
        const mutedForeground = scheme.mutedForeground ?? base.mutedForeground;
        const surface = scheme.surface ?? base.surface;
        const border = scheme.border ?? base.border ?? accent;

        tooltip.style.setProperty('--tooltip-accent', accent);
        tooltip.style.setProperty('--tooltip-accent-rgb', rgb);
        tooltip.style.setProperty('--tooltip-accent-soft', soft);
        tooltip.style.setProperty('--tooltip-accent-strong', strong);
        tooltip.style.setProperty('--tooltip-on-accent', onAccent);
        tooltip.style.setProperty('--tooltip-foreground', foreground);
        tooltip.style.setProperty('--tooltip-soft-foreground', softForeground);
        tooltip.style.setProperty('--tooltip-muted-foreground', mutedForeground);
        tooltip.style.setProperty('--tooltip-surface', surface);
        tooltip.style.setProperty('--tooltip-border-color', border);
      }

      if (infoButton) {
        infoButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleInfoMode();
        });
      }

      if (infoPopover) {
        infoPopover.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }

      document.addEventListener(
        'pointerdown',
        (event) => {
          if (!infoModeActive || !awaitingInfoTargetSelection) {
            return;
          }

          const targetElement =
            event.target instanceof Element ? event.target.closest('[data-info-target]') : null;
          if (!targetElement) {
            return;
          }

          const infoKey = targetElement.getAttribute('data-info-target');
          if (!infoKey) {
            return;
          }

          handleInfoRequestFor(infoKey, event, { target: targetElement });
        },
        true,
      );

      document.addEventListener(
        'keydown',
        (event) => {
          if (!infoModeActive || !awaitingInfoTargetSelection) {
            return;
          }

          const key = event.key;
          if (key !== 'Enter' && key !== ' ' && key !== 'Spacebar') {
            return;
          }

          const targetElement =
            event.target instanceof Element ? event.target.closest('[data-info-target]') : null;
          if (!targetElement) {
            return;
          }

          const infoKey = targetElement.getAttribute('data-info-target');
          if (!infoKey) {
            return;
          }

          handleInfoRequestFor(infoKey, event, { target: targetElement });
        },
        true,
      );

      renderLocationOptions();

      const wallKeyFromQuery = getWallKeyFromQuery();
      let initialLocation = wallKeyFromQuery
        ? findLocationByKey(wallKeyFromQuery) || findLocationByName(wallKeyFromQuery)
        : null;

      let storedLocationKey = null;
      if (!initialLocation) {
        try {
          storedLocationKey = window.localStorage?.getItem(LOCATION_STORAGE_KEY) || null;
        } catch (error) {
          console.warn('Unable to read location preference:', error);
        }

        if (storedLocationKey) {
          const normalizedStoredKey = normalizeWallKey(storedLocationKey);
          initialLocation =
            findLocationByKey(normalizedStoredKey) || findLocationByName(normalizedStoredKey);
        }
      }

      if (initialLocation) {
        currentLocation = initialLocation;
      }

      ensureCurrentLocationVisible();

      const currentLocationKey = getCurrentLocationKey();
      if (currentLocationKey) {
        persistSelectedWall(currentLocationKey);
      }
      updateWallQueryParam(currentLocationKey);
      updateSetterLinkHref();

      updateLocationButtonLabel();
      updateLocationOptionsState();
      if (locationButton) {
        locationButton.setAttribute('aria-expanded', 'false');
      }
      updateBackgroundForCurrentLocation();

      if (locationButton) {
        locationButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('location', event)) {
            return;
          }
          if (activeInfoCallout?.target === locationButton) {
            clearInfoHighlights();
          }
          event.preventDefault();
          openLocationModal();
        });
      }

      if (viewToggleButton) {
        viewToggleButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('view-toggle', event)) {
            return;
          }
          if (activeInfoCallout?.target === viewToggleButton) {
            clearInfoHighlights();
          }
          const nextMode =
            viewMode === VIEW_MODE_HOLD_COLORS ? VIEW_MODE_GRADE_COLORS : VIEW_MODE_HOLD_COLORS;
          setViewMode(nextMode);
        });
      }

      if (progressionButton) {
        progressionButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('progression', event)) {
            return;
          }
          if (activeInfoCallout?.target === progressionButton) {
            clearInfoHighlights();
          }
          event.preventDefault();
          if (isProgressionModalOpen()) {
            closeProgressionModal();
          } else {
            openProgressionModal();
          }
        });
      }

      if (setterLink) {
        setterLink.addEventListener('click', (event) => {
          if (handleInfoRequestFor('setter-link', event)) {
            return;
          }
          if (activeInfoCallout?.target === setterLink) {
            clearInfoHighlights();
          }
        });
      }

      if (locationModalClose) {
        locationModalClose.addEventListener('click', (event) => {
          event.preventDefault();
          closeLocationModal();
        });
      }

      if (locationModal) {
        locationModal.addEventListener('click', (event) => {
          if (event.target === locationModal) {
            closeLocationModal();
          }
        });
      }

      if (progressionModalClose) {
        progressionModalClose.addEventListener('click', (event) => {
          event.preventDefault();
          closeProgressionModal();
        });
      }

      if (progressionModal) {
        progressionModal.addEventListener('click', (event) => {
          if (event.target === progressionModal) {
            closeProgressionModal();
          }
        });
      }

      window.addEventListener('resize', scheduleInfoHighlightsReposition);
      window.addEventListener('scroll', scheduleInfoHighlightsReposition, true);

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeLocationModal();
          closeProgressionModal();
          if (infoModeActive) {
            deactivateInfoMode({ clearCallout: true });
            if (infoButton) {
              infoButton.focus();
            }
          } else if (activeInfoCallout) {
            clearInfoHighlights();
            if (infoButton) {
              infoButton.focus();
            }
          }
        }
      });

      let authMode = 'login';
      let currentUser = null;
      let currentUsername = '';
      let authenticatedUsernameClaim = '';
      
      function setAuthMode(mode) {
        authMode = mode;
        const isLogin = authMode === 'login';
        authTitle.textContent = isLogin ? 'Sign in to continue' : 'Create your account';
        authSwitchLabel.textContent = isLogin ? "Don't have an account?" : 'Already have an account?';
        toggleAuthModeButton.textContent = isLogin ? 'Create one' : 'Sign in';
        authForm.querySelector('.auth-submit').textContent = isLogin ? 'Sign In' : 'Create Account';
        authPassword.setAttribute('autocomplete', isLogin ? 'current-password' : 'new-password');
        authError.textContent = '';
      }

      toggleAuthModeButton.addEventListener('click', () => {
        setAuthMode(authMode === 'login' ? 'register' : 'login');
      });

      async function lookupUsernameByUid(uid) {
        if (!uid) {
          return '';
        }

        try {
          const snapshot = await getDocs(
            query(collection(db, 'usernames'), where('uid', '==', uid), limit(1)),
          );

          if (snapshot.empty) {
            return '';
          }

          const docSnap = snapshot.docs[0];
          const data = docSnap.data() || {};
          const fromField = normalizeUsername(data.username);
          const fromId = normalizeUsername(docSnap.id);
          return fromField || fromId;
        } catch (error) {
          console.error('Failed to look up username by UID:', error);
          return '';
        }
      }

      async function resolveUsernameForUser(user) {
        if (!user) {
          return '';
        }

        const displayName = normalizeUsername(user.displayName);
        if (isValidUsername(displayName)) {
          return displayName;
        }

        const mapped = await lookupUsernameByUid(user.uid);
        if (isValidUsername(mapped)) {
          if (!displayName) {
            try {
              await updateProfile(user, { displayName: mapped });
            } catch (error) {
              console.warn('Unable to synchronise display name with username:', error);
            }
          }
          return mapped;
        }

        const syntheticEmail = typeof user.email === 'string' ? user.email : '';
        if (syntheticEmail.endsWith(`@${SYNTHETIC_EMAIL_DOMAIN}`)) {
          const derived = normalizeUsername(
            syntheticEmail.slice(0, -(`@${SYNTHETIC_EMAIL_DOMAIN}`.length)),
          );
          if (isValidUsername(derived)) {
            return derived;
          }
        }

        return '';
      }

      authForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        authError.textContent = '';

        const rawUsername = authUsername.value;
        const normalizedUsername = normalizeUsername(rawUsername);
        const password = authPassword.value;

        if (!normalizedUsername) {
          authError.textContent = 'Enter your username to continue.';
          return;
        }

        if (!isValidUsername(normalizedUsername)) {
          authError.textContent =
            'Usernames must be 3-20 characters using only letters, numbers, or underscores.';
          return;
        }

        const syntheticEmail = buildSyntheticEmail(normalizedUsername);

        try {
          if (authMode === 'login') {
            await signInWithEmailAndPassword(auth, syntheticEmail, password);
            return;
          }

          const credentials = await createUserWithEmailAndPassword(auth, syntheticEmail, password);
          const { user } = credentials;

          try {
            await setDoc(doc(db, 'usernames', normalizedUsername), {
              uid: user.uid,
              username: normalizedUsername,
              createdAt: serverTimestamp(),
              updatedAt: serverTimestamp(),
            });
          } catch (error) {
            console.error('Failed to reserve username:', error);
            try {
              await deleteUser(user);
            } catch (cleanupError) {
              console.warn('Unable to clean up user after username failure:', cleanupError);
            }
            const usernameError = new Error('Username unavailable');
            usernameError.code = 'auth/username-unavailable';
            throw usernameError;
          }

          try {
            await updateProfile(user, { displayName: normalizedUsername });
          } catch (profileError) {
            console.warn('Failed to update display name:', profileError);
          }
        } catch (error) {
          let message = 'Unable to complete the request. Please try again.';

          switch (error?.code) {
            case 'auth/user-not-found':
            case 'auth/wrong-password':
              message = 'Invalid username or password.';
              break;
            case 'auth/email-already-in-use':
            case 'auth/username-unavailable':
            case 'permission-denied':
              message = 'That username is already taken. Choose another one.';
              break;
            case 'auth/invalid-email':
              message = 'Enter a valid username.';
              break;
            case 'auth/weak-password':
              message = 'Choose a stronger password (at least 6 characters).';
              break;
            default:
              if (error?.message) {
                message = error.message;
              }
          }

          authError.textContent = message;
        }
      });

      if (loginButton) {
        loginButton.addEventListener('click', (event) => {
          if (handleInfoRequestFor('log-in', event)) {
            return;
          }
          if (activeInfoCallout?.target === loginButton) {
            clearInfoHighlights();
          }
          // Allow default navigation to the personal dashboard.
        });
      }

      async function ensureUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return { role: 'default' };
        }

        const roleRef = doc(db, 'roles', user.uid);
        const existingSnap = await getDoc(roleRef);

        if (existingSnap.exists()) {
          const existingData = existingSnap.data() || {};
          const storedLowerRaw =
            typeof existingData.usernameLower === 'string'
              ? existingData.usernameLower
              : typeof existingData.username === 'string'
              ? existingData.username
              : '';
          let effectiveLower = normalizeUsername(storedLowerRaw);
          const trimmedRole =
            typeof existingData.role === 'string'
              ? existingData.role.trim().toLowerCase()
              : 'default';
          const mergedData = {
            ...existingData,
            role: trimmedRole,
          };

          if (effectiveLower !== normalizedUsername || !existingData.username) {
            try {
              await setDoc(
                roleRef,
                {
                  username: normalizedUsername,
                  usernameLower: normalizedUsername,
                  updatedAt: serverTimestamp(),
                },
                { merge: true },
              );
              mergedData.username = normalizedUsername;
              mergedData.usernameLower = normalizedUsername;
              effectiveLower = normalizedUsername;
            } catch (error) {
              console.warn('Failed to synchronise username on role document:', error);
            }
          }

          if (effectiveLower !== normalizedUsername) {
            mergedData.role = 'default';
          }

          return mergedData;
        }

        let role = 'default';

        try {
          const snapshot = await getDocs(
            query(collection(db, 'roles'), where('role', '==', 'setter'), limit(1)),
          );
          if (snapshot.empty) {
            role = 'setter';
          }
        } catch (error) {
          console.warn('Unable to inspect existing roles:', error);
        }

        const roleData = {
          role,
          username: normalizedUsername,
          usernameLower: normalizedUsername,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        };

        await setDoc(roleRef, roleData, { merge: true });
        return roleData;
      }

      async function resolveUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return 'default';
        }

        try {
          const ensuredRole = await ensureUserRole(user, normalizedUsername);
          return typeof ensuredRole?.role === 'string'
            ? ensuredRole.role.trim().toLowerCase()
            : 'default';
        } catch (error) {
          console.error('Failed to fetch user role:', error);
          return 'default';
        }
      }

      function updateNavigationForRole(role) {
        updateSetterLinkHref();
        if (!setterLink) {
          return;
        }

        const shouldHideSetterLink = role !== 'setter';
        setterLink.classList.toggle('hidden', shouldHideSetterLink);

        if (shouldHideSetterLink && activeInfoCallout?.target === setterLink) {
          clearInfoHighlights();
        }
      }

      async function presentGuestExperience() {
        if (authOverlay) {
          authOverlay.classList.add('hidden');
          authOverlay.setAttribute('aria-hidden', 'true');
        }

        appContent.classList.remove('hidden');
        updateNavigationForRole('default');

        if (setterLink) {
          setterLink.classList.add('hidden');
        }

        if (infoModeActive) {
          deactivateInfoMode({ clearCallout: true });
        } else if (activeInfoCallout) {
          clearInfoHighlights();
        }

        authForm?.reset();
        if (authError) {
          authError.textContent = '';
        }
        setAuthMode('login');

        focusedRouteId = null;
        currentUser = null;
        currentUsername = '';
        authenticatedUsernameClaim = '';
        ascendedRoutes.clear();
        routeGrades.clear();
        userAscentDetails = new Map();
        routeMedianGrades = new Map();
        hideTooltip({ force: true });

        await loadRoutes();
      }

      function clearTutorialPromptTimer() {
        if (tutorialPromptTimeoutId !== null) {
          clearTimeout(tutorialPromptTimeoutId);
          tutorialPromptTimeoutId = null;
        }
      }

      function showTutorialPrompt() {
        clearTutorialPromptTimer();

        if (!tutorialPromptButton || tutorialPromptVisible || tutorialActive || tutorialInviteOpen || tutorialCompleted) {
          return;
        }

        tutorialPromptVisible = true;
        tutorialPromptButton.classList.remove('hidden');
        tutorialPromptButton.setAttribute('aria-hidden', 'false');
        tutorialPromptTimeoutId = null;
        resetTutorialInactivityTimer();
      }

      function hideTutorialPromptButton() {
        if (!tutorialPromptButton) {
          return;
        }

        tutorialPromptVisible = false;
        tutorialPromptButton.classList.add('hidden');
        tutorialPromptButton.setAttribute('aria-hidden', 'true');
      }

      function resetTutorialInactivityTimer() {
        if (tutorialCompleted || tutorialActive || tutorialInviteOpen) {
          return;
        }

        clearTutorialPromptTimer();
        tutorialPromptTimeoutId = window.setTimeout(() => {
          showTutorialPrompt();
        }, 60000);
      }

      function registerTutorialActivity() {
        if (tutorialCompleted || tutorialActive || tutorialInviteOpen) {
          return;
        }

        const now = Date.now();
        if (now - tutorialLastActivityTimestamp < 1000) {
          return;
        }

        tutorialLastActivityTimestamp = now;

        if (tutorialPromptVisible) {
          return;
        }

        resetTutorialInactivityTimer();
      }

      function openTutorialOverlay() {
        if (!tutorialOverlay || !tutorialDialogCard) {
          return;
        }

        tutorialPreviousFocus =
          document.activeElement instanceof HTMLElement ? document.activeElement : null;

        tutorialOverlay.classList.remove('hidden');
        tutorialOverlay.setAttribute('aria-hidden', 'false');

        window.setTimeout(() => {
          tutorialDialogCard.focus();
        }, 0);
      }

      function closeTutorialOverlay() {
        if (!tutorialOverlay) {
          return;
        }

        tutorialOverlay.classList.add('hidden');
        tutorialOverlay.setAttribute('aria-hidden', 'true');

        if (tutorialPreviousFocus && typeof tutorialPreviousFocus.focus === 'function') {
          tutorialPreviousFocus.focus();
        }

        tutorialPreviousFocus = null;
      }

      function setTutorialDescriptionContent(lines) {
        if (!tutorialDescription) {
          return;
        }

        tutorialDescription.innerHTML = '';

        if (!Array.isArray(lines)) {
          return;
        }

        const fragment = document.createDocumentFragment();

        lines.forEach((item) => {
          if (typeof item === 'string') {
            const trimmed = item.trim();
            if (trimmed.length === 0) {
              return;
            }
            const paragraph = document.createElement('p');
            paragraph.textContent = trimmed;
            fragment.appendChild(paragraph);
            return;
          }

          let node = null;

          if (typeof item === 'function') {
            try {
              node = item();
            } catch (error) {
              console.warn('Unable to render tutorial content item:', error);
            }
          } else if (item instanceof Node) {
            node = item;
          }

          if (node instanceof Node) {
            fragment.appendChild(node);
          }
        });

        tutorialDescription.appendChild(fragment);
      }

      let tutorialPointer = null;
      let tutorialPointerTarget = null;

      function ensureTutorialPointer() {
        if (tutorialPointer) {
          return tutorialPointer;
        }

        tutorialPointer = document.createElement('div');
        tutorialPointer.className = 'tutorial-pointer hidden';
        tutorialPointer.setAttribute('aria-hidden', 'true');
        tutorialPointer.innerHTML =
          '<svg viewBox="0 0 48 72" role="presentation" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><path fill="#7ED957" d="M24 0l12 18h-8v30h12L24 72 4 48h12V18H8z"/></svg>';
        document.body.appendChild(tutorialPointer);

        return tutorialPointer;
      }

      function updateTutorialPointerPosition() {
        if (!tutorialPointer || tutorialPointer.classList.contains('hidden')) {
          return;
        }

        if (!tutorialPointerTarget || !isElementVisible(tutorialPointerTarget)) {
          hideTutorialPointer();
          return;
        }

        const rect = tutorialPointerTarget.getBoundingClientRect();
        const verticalOffset = 12;

        tutorialPointer.style.left = `${rect.left + rect.width / 2}px`;
        tutorialPointer.style.top = `${rect.bottom + verticalOffset}px`;
      }

      function showTutorialPointerFor(element) {
        if (!(element instanceof HTMLElement) || !isElementVisible(element)) {
          hideTutorialPointer();
          return;
        }

        ensureTutorialPointer();

        tutorialPointerTarget = element;
        tutorialPointer.classList.remove('hidden');
        tutorialPointer.setAttribute('aria-hidden', 'false');
        updateTutorialPointerPosition();
      }

      function hideTutorialPointer() {
        if (!tutorialPointer) {
          tutorialPointerTarget = null;
          return;
        }

        tutorialPointerTarget = null;
        tutorialPointer.classList.add('hidden');
        tutorialPointer.setAttribute('aria-hidden', 'true');
      }

      window.addEventListener('resize', updateTutorialPointerPosition);
      window.addEventListener('scroll', updateTutorialPointerPosition, true);

      function highlightTutorialElement(element, options = {}) {
        const shouldIlluminate = options?.illuminate === true;

        if (tutorialHighlightedElement) {
          if (tutorialHighlightedElement !== element || !element) {
            tutorialHighlightedElement.classList.remove('tutorial-highlight');
            tutorialHighlightedElement.classList.remove('tutorial-illuminated');
            tutorialHighlightedElementOptions = { illuminate: false };
          } else if (tutorialHighlightedElementOptions.illuminate !== shouldIlluminate) {
            tutorialHighlightedElement.classList.toggle('tutorial-illuminated', shouldIlluminate);
            tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
            return;
          }
        }

        if (element && element.classList) {
          element.classList.add('tutorial-highlight');
          element.classList.toggle('tutorial-illuminated', shouldIlluminate);
          tutorialHighlightedElement = element;
          tutorialHighlightedElementOptions = { illuminate: shouldIlluminate };
        } else {
          tutorialHighlightedElement = null;
          tutorialHighlightedElementOptions = { illuminate: false };
        }
      }

      function disableInteractiveElementsForTutorial() {
        const interactiveElements = document.querySelectorAll('button, a, [role="button"]');

        interactiveElements.forEach((element) => {
          if (!(element instanceof HTMLElement)) {
            return;
          }

          if (element.dataset.tutorialExempt === 'true') {
            return;
          }

          if (element instanceof HTMLButtonElement) {
            element.dataset.tutorialWasDisabled = element.disabled ? 'true' : 'false';
            element.disabled = true;
          } else {
            const alreadyDisabled = element.getAttribute('aria-disabled') === 'true';
            element.dataset.tutorialWasDisabled = alreadyDisabled ? 'true' : 'false';
            element.setAttribute('aria-disabled', 'true');
          }

          element.classList.add('is-tutorial-disabled');
        });
      }

      function restoreInteractiveElementsAfterTutorial() {
        const interactiveElements = document.querySelectorAll('button, a, [role="button"]');

        interactiveElements.forEach((element) => {
          if (!(element instanceof HTMLElement)) {
            return;
          }

          if (element.dataset.tutorialExempt === 'true') {
            return;
          }

          const wasDisabled = element.dataset.tutorialWasDisabled === 'true';

          if (element instanceof HTMLButtonElement) {
            if (!wasDisabled) {
              element.disabled = false;
            }
          } else if (!wasDisabled) {
            element.removeAttribute('aria-disabled');
          }

          element.classList.remove('is-tutorial-disabled');
          delete element.dataset.tutorialWasDisabled;
        });
      }

      async function ensureRoutesAvailableForTutorial() {
        if (Array.isArray(routes) && routes.length) {
          return routes;
        }

        if (Array.isArray(allRoutes) && allRoutes.length) {
          return allRoutes;
        }

        try {
          await loadRoutes();
        } catch (error) {
          console.warn('Unable to refresh routes for tutorial:', error);
        }

        if (Array.isArray(routes) && routes.length) {
          return routes;
        }

        if (Array.isArray(allRoutes) && allRoutes.length) {
          return allRoutes;
        }

        return [];
      }

      async function showTutorialRouteTooltip() {
        const availableRoutes = await ensureRoutesAvailableForTutorial();
        if (!Array.isArray(availableRoutes) || availableRoutes.length === 0) {
          return;
        }

        const targetRoute = availableRoutes.find((route) => route && typeof route.id === 'string');
        if (!targetRoute) {
          return;
        }

        tutorialHighlightedRouteId = targetRoute.id;
        focusRoute(targetRoute);
        showTooltip(targetRoute, window.innerWidth / 2, window.innerHeight / 2, { pin: true });
      }

      function closeTutorialRouteTooltip() {
        if (tutorialHighlightedRouteId) {
          const targetRoute =
            (Array.isArray(routes) ? routes : []).find((route) => route?.id === tutorialHighlightedRouteId) ||
            (Array.isArray(allRoutes) ? allRoutes : []).find((route) => route?.id === tutorialHighlightedRouteId);

          if (targetRoute) {
            setRouteFocus(targetRoute, false);
          } else if (focusedRouteId === tutorialHighlightedRouteId) {
            focusedRouteId = null;
            redraw();
          }
        }

        tutorialHighlightedRouteId = null;
        hideTooltip({ force: true });
      }

      function setTutorialOverlayAlignment(alignment = 'center') {
        if (!tutorialOverlay) {
          return;
        }

        const shouldAlignBottom = alignment === 'bottom';
        tutorialOverlay.classList.toggle('is-bottom-aligned', shouldAlignBottom);
      }

      function startTutorialRoutePulse() {
        if (!canvas) {
          return;
        }

        canvas.classList.add('tutorial-route-pulse');
      }

      function stopTutorialRoutePulse() {
        if (!canvas) {
          return;
        }

        canvas.classList.remove('tutorial-route-pulse');
      }

      const tutorialSteps = [
        {
          title: 'Welcome to Ascend',
          body: [
            'Ascend helps you explore the latest problems on the wall and stay up to date with the gym.',
            'Use this public view to browse climbs and see what sets are available right now.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('center');
            highlightTutorialElement(null);
            hideTooltip({ force: true });
            hideTutorialPointer();
          },
          onExit: () => {
            highlightTutorialElement(null);
          },
        },
        { 
          title: 'Route details',
          body: [
            'Click any climb to open its tooltip for more information.',
            'You\'ll see the setter, description, and consensus grade gathered from other climbers.',
          ],
          onEnter: async () => {
            setTutorialOverlayAlignment('bottom');
            highlightTutorialElement(null);
            await showTutorialRouteTooltip();
          },
          onExit: () => {
            hideTutorialPointer();
            stopTutorialRoutePulse();
            closeTutorialRouteTooltip();
            setTutorialOverlayAlignment('center');
          },
        },
        {
          title: 'Show hold colors',
          body: [
            'Toggle the Show Hold Colors button to switch between route outlines and grade colors.',
            'Routes are tinted by difficulty right now.',
            'The spectrum below runs from the easiest greens on the left to the hardest reds on the right, covering every grade color.',
            () => createGradeChartElement(),
            'It\'s perfect when you want to scan the wall by difficulty at a glance.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('center');
            if (viewToggleButton) {
              tutorialPreviousViewMode = viewMode;
              if (viewMode !== VIEW_MODE_GRADE_COLORS) {
                setViewMode(VIEW_MODE_GRADE_COLORS);
              }
              highlightTutorialElement(viewToggleButton, { illuminate: true });
              showTutorialPointerFor(viewToggleButton);
            } else {
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
            if (tutorialPreviousViewMode && tutorialPreviousViewMode !== viewMode) {
              setViewMode(tutorialPreviousViewMode);
            }
            tutorialPreviousViewMode = null;
          },
        },
        {
          title: 'Choose a wall',
          body: [
            'Use the wall selector to jump between different locations in the gym.',
            'Each wall has its own background and set of climbs to explore.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('bottom');
            if (locationModal) {
              locationModal.classList.add('is-top-aligned');
            }
            if (locationButton) {
              highlightTutorialElement(locationButton, { illuminate: true });
              showTutorialPointerFor(locationButton);
              openLocationModal();
              updateTutorialPointerPosition();
            } else {
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
            if (locationModal) {
              locationModal.classList.remove('is-top-aligned');
            }
            closeLocationModal();
            setTutorialOverlayAlignment('center');
          },
        },
        {
          title: 'Sign in to track progress',
          body: [
            'The Log in button takes you to the personal dashboard where you can create an account or sign in.',
            'Members can record ascents and personal grades once they\'re logged in.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('center');
            if (loginButton) {
              highlightTutorialElement(loginButton, { illuminate: true });
              showTutorialPointerFor(loginButton);
            } else {
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
        {
          title: 'Need more info later?',
          body: [
            'Tap the info button to activate quick explanations for the controls around the screen.',
            'It\'s a handy refresher whenever you want to revisit what each tool does.',
          ],
          onEnter: () => {
            setTutorialOverlayAlignment('center');
            if (infoButton) {
              highlightTutorialElement(infoButton, { illuminate: true });
              showTutorialPointerFor(infoButton);
            } else {
              hideTutorialPointer();
            }
          },
          onExit: () => {
            hideTutorialPointer();
            highlightTutorialElement(null);
          },
        },
      ];

      function renderTutorialStep() {
        if (!tutorialActive) {
          return;
        }

        const step = tutorialSteps[tutorialStepIndex];
        if (!step) {
          return;
        }

        if (tutorialTitle) {
          tutorialTitle.textContent = step.title || '';
        }

        setTutorialDescriptionContent(step.body || []);

        if (tutorialProgress) {
          tutorialProgress.textContent = `Step ${tutorialStepIndex + 1} of ${tutorialSteps.length}`;
          tutorialProgress.classList.toggle('hidden', tutorialSteps.length === 0);
        }

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.textContent =
            tutorialStepIndex === tutorialSteps.length - 1 ? 'Finish' : 'Next';
        }

        if (tutorialSecondaryAction) {
          tutorialSecondaryAction.textContent = 'Back';
          tutorialSecondaryAction.classList.toggle('hidden', tutorialStepIndex <= 0);
        }
      }

      async function goToTutorialStep(index) {
        if (!tutorialActive || tutorialTransitionInProgress) {
          return;
        }

        if (index < 0 || index >= tutorialSteps.length) {
          return;
        }

        tutorialTransitionInProgress = true;

        if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
          const currentStep = tutorialSteps[tutorialStepIndex];
          if (currentStep && typeof currentStep.onExit === 'function') {
            try {
              await currentStep.onExit();
            } catch (error) {
              console.warn('Tutorial step cleanup failed:', error);
            }
          }
        }

        tutorialStepIndex = index;
        tutorialOverlayMode = 'step';
        renderTutorialStep();

        const nextStep = tutorialSteps[tutorialStepIndex];
        if (nextStep && typeof nextStep.onEnter === 'function') {
          try {
            await nextStep.onEnter();
          } catch (error) {
            console.warn('Tutorial step setup failed:', error);
          }
        }

        tutorialTransitionInProgress = false;

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.focus();
        }
      }

      function renderTutorialInvite() {
        tutorialOverlayMode = 'invite';
        tutorialInviteOpen = true;
        tutorialActive = false;

        if (tutorialProgress) {
          tutorialProgress.classList.add('hidden');
        }

        highlightTutorialElement(null);
        stopTutorialRoutePulse();
        hideTutorialPointer();
        setTutorialOverlayAlignment('center');
        closeTutorialRouteTooltip();

        if (tutorialTitle) {
          tutorialTitle.textContent = 'Need a quick tour?';
        }

        setTutorialDescriptionContent([
          'It looks like you\'ve been away for a moment. Would you like a guided tour of the main controls?',
          'You can always open it again later from the question mark button.',
        ]);

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.textContent = 'Start tutorial';
        }

        if (tutorialSecondaryAction) {
          tutorialSecondaryAction.textContent = 'Not now';
          tutorialSecondaryAction.classList.remove('hidden');
        }
      }

      async function startTutorial() {
        if (tutorialActive) {
          return;
        }

        tutorialInviteOpen = false;
        tutorialOverlayMode = 'step';
        tutorialActive = true;
        tutorialStepIndex = -1;
        tutorialCompleted = false;
        tutorialTransitionInProgress = false;

        if (tutorialProgress) {
          tutorialProgress.classList.remove('hidden');
        }

        stopTutorialRoutePulse();
        setTutorialOverlayAlignment('center');

        hideTutorialPromptButton();
        clearTutorialPromptTimer();
        disableInteractiveElementsForTutorial();

        await goToTutorialStep(0);
      }

      async function finishTutorial() {
        if (!tutorialActive) {
          return;
        }

        tutorialTransitionInProgress = true;

        if (tutorialStepIndex >= 0 && tutorialStepIndex < tutorialSteps.length) {
          const finalStep = tutorialSteps[tutorialStepIndex];
          if (finalStep && typeof finalStep.onExit === 'function') {
            try {
              await finalStep.onExit();
            } catch (error) {
              console.warn('Tutorial completion cleanup failed:', error);
            }
          }
        }

        tutorialActive = false;
        tutorialCompleted = true;
        tutorialInviteOpen = false;
        tutorialOverlayMode = 'hidden';
        tutorialStepIndex = -1;
        tutorialTransitionInProgress = false;

        highlightTutorialElement(null);
        closeTutorialRouteTooltip();
        stopTutorialRoutePulse();
        hideTutorialPointer();
        setTutorialOverlayAlignment('center');
        restoreInteractiveElementsAfterTutorial();
        hideTutorialPromptButton();

        if (tutorialProgress) {
          tutorialProgress.classList.add('hidden');
        }

        closeTutorialOverlay();
        clearTutorialPromptTimer();
      }

      function declineTutorial() {
        tutorialInviteOpen = false;
        tutorialOverlayMode = 'hidden';
        highlightTutorialElement(null);
        closeTutorialRouteTooltip();
        stopTutorialRoutePulse();
        hideTutorialPointer();
        setTutorialOverlayAlignment('center');
        closeTutorialOverlay();
        hideTutorialPromptButton();
        resetTutorialInactivityTimer();
      }

      async function handleTutorialPrimaryAction() {
        if (tutorialOverlayMode === 'invite') {
          await startTutorial();
          return;
        }

        if (tutorialOverlayMode === 'step') {
          if (tutorialTransitionInProgress) {
            return;
          }

          if (tutorialStepIndex >= tutorialSteps.length - 1) {
            await finishTutorial();
          } else {
            await goToTutorialStep(tutorialStepIndex + 1);
          }
        }
      }

      async function handleTutorialSecondaryAction() {
        if (tutorialOverlayMode === 'invite') {
          declineTutorial();
          return;
        }

        if (tutorialOverlayMode === 'step') {
          if (tutorialTransitionInProgress || tutorialStepIndex <= 0) {
            return;
          }

          await goToTutorialStep(tutorialStepIndex - 1);
        }
      }

      function setupTutorialInteractions() {
        tutorialLastActivityTimestamp = Date.now();

        showTutorialPrompt();

        if (tutorialPromptButton) {
          tutorialPromptButton.addEventListener('click', () => {
            if (tutorialActive || tutorialInviteOpen || tutorialCompleted) {
              return;
            }

            hideTutorialPromptButton();
            clearTutorialPromptTimer();
            renderTutorialInvite();
            openTutorialOverlay();

            if (tutorialPrimaryAction) {
              tutorialPrimaryAction.focus();
            }
          });
        }

        if (tutorialPrimaryAction) {
          tutorialPrimaryAction.addEventListener('click', () => {
            void handleTutorialPrimaryAction();
          });
        }

        if (tutorialSecondaryAction) {
          tutorialSecondaryAction.addEventListener('click', () => {
            void handleTutorialSecondaryAction();
          });
        }

        const activityEvents = ['pointerdown', 'keydown', 'touchstart', 'mousemove'];
        activityEvents.forEach((eventName) => {
          document.addEventListener(
            eventName,
            () => {
              registerTutorialActivity();
            },
            { passive: true },
          );
        });

        resetTutorialInactivityTimer();
      }

      onAuthStateChanged(auth, async (user) => {
        if (user && !user.isAnonymous) {
          if (authOverlay) {
            authOverlay.classList.add('hidden');
            authOverlay.setAttribute('aria-hidden', 'true');
          }

          currentUser = user;

          const resolvedUsername = await resolveUsernameForUser(user);
          if (!isValidUsername(resolvedUsername)) {
            authError.textContent =
              'Unable to resolve your username. Please contact a setter for assistance.';
            await signOut(auth);
            return;
          }

          currentUsername = normalizeUsername(resolvedUsername);
          authenticatedUsernameClaim = '';
          const canonicalUsername = await resolveAuthenticatedUsername();
          if (isValidUsername(canonicalUsername)) {
            currentUsername = canonicalUsername;
          }

          const role = await resolveUserRole(user, currentUsername);

          updateNavigationForRole(role);
          appContent.classList.remove('hidden');

          await loadAscents({ userId: user.uid, username: currentUsername });
          await loadRoutes();

          return;
        }

        await presentGuestExperience();
      });

      setAuthMode('login');

      const canvasContainer = document.querySelector('.canvas-container');
      const canvas = document.getElementById('previewCanvas');
      const ctx = canvas.getContext('2d');

      syncViewModeState();
      updateViewToggleButton();

      const DEFAULT_CANVAS_ASPECT_RATIO = 1536 / 1024;
      let canvasAspectRatio = DEFAULT_CANVAS_ASPECT_RATIO;
      let isHorizontalScrollEnabled = false;

      let allRoutes = [];
      let routes = [];
      let focusedRouteId = null;
      let routeInteractionEntries = [];
      let activeRouteId = null;
      let pinnedRouteId = null;
      let pinnedPosition = null;
      const ascendedRoutes = new Set();
      const routeGrades = new Map();
      let userAscentDetails = new Map();
      let routeMedianGrades = new Map();
      let progressionPreviouslyFocusedElement = null;

      function synchroniseAscentsWithRoutes(options = {}) {
        const { shouldRedraw = true } = options;
        ascendedRoutes.clear();
        routeGrades.clear();

        if (!Array.isArray(routes) || routes.length === 0) {
          renderProgressionList();
          if (shouldRedraw) {
            redraw();
          }
          return;
        }

        routes.forEach((route) => {
          if (!route?.id) {
            return;
          }

          const ascent = userAscentDetails.get(route.id);
          if (!ascent) {
            return;
          }

          if (typeof ascent.grade === 'number' && Number.isFinite(ascent.grade)) {
            routeGrades.set(route.id, ascent.grade);
          }

          if (ascent.ascended) {
            ascendedRoutes.add(route.id);
          }
        });

        renderProgressionList();

        if (shouldRedraw) {
          redraw();
        }
      }

      async function loadAscents({ userId, username }) {
        ascendedRoutes.clear();
        routeGrades.clear();
        userAscentDetails = new Map();

        const normalizedUserId = typeof userId === 'string' ? userId.trim() : '';
        const normalizedUsername = normalizeUsername(username);
        const hasValidUsername = isValidUsername(normalizedUsername);
        if (!normalizedUserId && !hasValidUsername) {
          return;
        }

        try {
          let ascentData = null;

          if (normalizedUserId) {
            const ascentRef = doc(db, 'ascents', normalizedUserId);
            const ascentSnap = await getDoc(ascentRef);
            if (ascentSnap.exists()) {
              ascentData = ascentSnap.data() ?? {};
            }

            if (!ascentData && hasValidUsername && normalizedUsername !== normalizedUserId) {
              const legacyRef = doc(db, 'ascents', normalizedUsername);
              const legacySnap = await getDoc(legacyRef);

              if (legacySnap.exists()) {
                ascentData = legacySnap.data() ?? {};

                try {
                  const migrationPayload = {
                    ...ascentData,
                    climber_uid: normalizedUserId,
                    updatedAt: serverTimestamp(),
                  };

                  if (hasValidUsername) {
                    migrationPayload.climber_username = normalizedUsername;
                  }

                  await setDoc(ascentRef, migrationPayload, { merge: true });
                } catch (migrationError) {
                  console.warn('Failed to migrate legacy ascent document to UID path:', migrationError);
                }
              }
            }
          }

          if (!ascentData && hasValidUsername && normalizedUsername !== normalizedUserId) {
            const ascentRef = doc(db, 'ascents', normalizedUsername);
            const ascentSnap = await getDoc(ascentRef);

            if (!ascentSnap.exists()) {
              return;
            }

            ascentData = ascentSnap.data() ?? {};
          }

          if (!ascentData) {
            return;
          }

          const routesData = ascentData.routes;

          if (routesData && typeof routesData === 'object') {
            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!routeId || !details) {
                return;
              }

              const gradeValue = normalizeGradeValue(details?.grade);
              const normalizedDate = normalizeDate(details?.date_ascended);
              const ascended = details?.ascended === true || Boolean(normalizedDate);

              const entry = {
                ascended,
                grade: gradeValue,
              };

              if (normalizedDate) {
                entry.dateAscended = normalizedDate;
              }

              userAscentDetails.set(routeId, entry);
            });

            synchroniseAscentsWithRoutes();
            return;
          }

          const singleRouteId = typeof ascentData.route_id === 'string' ? ascentData.route_id : null;
          if (singleRouteId) {
            userAscentDetails.set(singleRouteId, { ascended: true, grade: null });
            synchroniseAscentsWithRoutes();
            return;
          }
        } catch (error) {
          console.error('Failed to load ascents:', error);
        }

        synchroniseAscentsWithRoutes();
      }

      function normalizeDate(value) {
        if (!value) {
          return null;
        }

        if (typeof value === 'string') {
          const date = new Date(value);
          return Number.isNaN(date.getTime()) ? null : date.toISOString();
        }

        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }

        if (typeof value?.toDate === 'function') {
          const date = value.toDate();
          if (date instanceof Date && !Number.isNaN(date.getTime())) {
            return date.toISOString();
          }
          return null;
        }

        return null;
      }

      function formatDisplayDate(isoString) {
        if (!isoString) {
          return 'Unknown';
        }

        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return 'Unknown';
        }

        return date.toLocaleDateString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
        });
      }

      function normalizeGradeValue(value) {
        if (value === null || value === undefined) {
          return null;
        }

        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return null;
        }

        if (!Number.isInteger(numeric)) {
          return null;
        }

        if (numeric < MIN_GRADE_VALUE || numeric > MAX_GRADE_VALUE) {
          return null;
        }

        return numeric;
      }

      function formatGradeDisplay(value) {
        if (typeof value !== 'number' || !Number.isFinite(value)) {
          return '—';
        }

        return Number.isInteger(value) ? String(value) : value.toFixed(1);
      }

      function resolveProgressionGradeValue(route) {
        if (!route) {
          return null;
        }

        if (typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)) {
          return route.medianGrade;
        }

        const stored = routeGrades.get(route.id);
        if (typeof stored === 'number' && Number.isFinite(stored)) {
          return stored;
        }

        return null;
      }

      function renderProgressionList() {
        if (!progressionList) {
          return;
        }

        progressionList.innerHTML = '';

        const desiredLocation = normalizeLocationName(currentLocation?.name);
        const fallbackLocation = normalizeLocationName(getDefaultLocation()?.name);
        const targetLocation = desiredLocation || fallbackLocation || null;

        const relevantRoutes = Array.isArray(routes)
          ? routes.filter((route) => {
              if (!route) {
                return false;
              }

              if (!targetLocation) {
                return true;
              }

              const routeLocationKey =
                typeof route.locationKey === 'string' && route.locationKey
                  ? route.locationKey
                  : normalizeLocationName(route.location);

              return routeLocationKey === targetLocation;
            })
          : [];

        if (!relevantRoutes.length) {
          const emptyMessage = document.createElement('p');
          emptyMessage.className = 'progression-empty-message';
          emptyMessage.textContent = 'No routes available for this wall yet.';
          progressionList.appendChild(emptyMessage);
          return;
        }

        const sorted = relevantRoutes.slice().sort((routeA, routeB) => {
          const gradeA = resolveProgressionGradeValue(routeA);
          const gradeB = resolveProgressionGradeValue(routeB);

          if (gradeA === null && gradeB === null) {
            const nameA = (routeA.title || routeA.id || '').toLowerCase();
            const nameB = (routeB.title || routeB.id || '').toLowerCase();
            return nameA.localeCompare(nameB);
          }

          if (gradeA === null) {
            return 1;
          }

          if (gradeB === null) {
            return -1;
          }

          if (gradeA !== gradeB) {
            return gradeA - gradeB;
          }

          const nameA = (routeA.title || routeA.id || '').toLowerCase();
          const nameB = (routeB.title || routeB.id || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });

        sorted.forEach((route) => {
          if (!route) {
            return;
          }

          const listItem = document.createElement('div');
          listItem.className = 'progression-entry';
          listItem.setAttribute('role', 'listitem');
          listItem.setAttribute('tabindex', '0');

          if (route.id) {
            listItem.dataset.routeId = route.id;
          }

          const isFocused = typeof route.id === 'string' && route.id === focusedRouteId;
          if (isFocused) {
            listItem.classList.add('is-focused');
            listItem.setAttribute('aria-current', 'true');
          }

          const grade = document.createElement('span');
          grade.className = 'progression-entry-grade';
          const gradeValue = resolveProgressionGradeValue(route);
          grade.textContent = formatGradeDisplay(gradeValue);

          const gradeColor = getRouteGradeColor(route);
          if (gradeColor) {
            grade.style.color = gradeColor;
          }

          listItem.appendChild(grade);

          const details = document.createElement('div');
          const title = document.createElement('span');
          title.className = 'progression-entry-name';
          title.textContent = route.title || route.id || 'Untitled route';

          if (gradeColor) {
            title.style.color = gradeColor;
          }

          details.appendChild(title);
          listItem.appendChild(details);

          const status = document.createElement('span');
          status.className = 'progression-entry-status';
          const isAscended = Boolean(route.id && ascendedRoutes.has(route.id));

          if (isAscended) {
            status.textContent = '✓';
            status.classList.add('is-ascended');
            status.setAttribute('aria-label', 'Ascended');
            status.setAttribute('title', 'Ascended');
          } else {
            status.textContent = '';
            status.setAttribute('aria-hidden', 'true');
          }

          listItem.appendChild(status);

          listItem.addEventListener('click', (event) => {
            event.preventDefault();
            focusRoute(route);
          });

          listItem.addEventListener('keydown', (event) => {
            const { key } = event;
            if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
              event.preventDefault();
              focusRoute(route);
            }
          });

          progressionList.appendChild(listItem);
        });
      }

      function isProgressionModalOpen() {
        if (!progressionModal) {
          return false;
        }

        return !progressionModal.classList.contains('hidden');
      }

      function closeProgressionModal() {
        if (!progressionModal) {
          return;
        }

        progressionModal.classList.add('hidden');
        progressionModal.setAttribute('aria-hidden', 'true');

        if (progressionButton) {
          progressionButton.setAttribute('aria-expanded', 'false');
        }

        document.removeEventListener('keydown', handleProgressionKeydown, true);

        if (progressionPreviouslyFocusedElement && typeof progressionPreviouslyFocusedElement.focus === 'function') {
          progressionPreviouslyFocusedElement.focus();
        }
        progressionPreviouslyFocusedElement = null;
      }

      function handleProgressionKeydown(event) {
        if (event.key === 'Escape' && isProgressionModalOpen()) {
          event.preventDefault();
          closeProgressionModal();
        }
      }

      function openProgressionModal() {
        if (!progressionModal) {
          return;
        }

        renderProgressionList();

        progressionPreviouslyFocusedElement =
          document.activeElement instanceof HTMLElement ? document.activeElement : null;

        progressionModal.classList.remove('hidden');
        progressionModal.setAttribute('aria-hidden', 'false');

        if (progressionButton) {
          progressionButton.setAttribute('aria-expanded', 'true');
        }

        document.addEventListener('keydown', handleProgressionKeydown, true);

        const focusTarget =
          progressionModalClose && typeof progressionModalClose.focus === 'function'
            ? progressionModalClose
            : progressionModal;
        focusTarget.focus();
      }

      function getUserGradeForRoute(routeId) {
        if (!routeId) {
          return null;
        }

        const stored = routeGrades.get(routeId);
        return typeof stored === 'number' && Number.isFinite(stored) ? stored : null;
      }

      function createTooltipCloseButton() {
        const closeButton = document.createElement('button');
        closeButton.type = 'button';
        closeButton.className = 'tooltip-close-button';
        closeButton.setAttribute('aria-label', 'Close route details');
        closeButton.setAttribute('title', 'Close route details');
        closeButton.innerHTML = `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M6.34 6.34a1 1 0 0 1 1.32-.08l.1.08L12 10.59l4.24-4.25a1 1 0 0 1 1.5 1.32l-.08.1L13.41 12l4.25 4.24a1 1 0 0 1-1.32 1.5l-.1-.08L12 13.41l-4.24 4.25a1 1 0 0 1-1.5-1.32l.08-.1L10.59 12 6.34 7.76a1 1 0 0 1 0-1.42Z"
              fill="currentColor"
            />
          </svg>
        `;
        closeButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          hideTooltip({ force: true });
        });
        return closeButton;
      }

      function buildGradeControls(route) {
        if (!route || !route.id) {
          return null;
        }

        const container = document.createElement('div');
        container.className = 'grade-section';

        const gradeForm = document.createElement('form');
        gradeForm.className = 'grade-form';
        gradeForm.noValidate = true;

        const gradeLabel = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.textContent = `Your grade (${MIN_GRADE_VALUE}-${MAX_GRADE_VALUE})`;
        gradeLabel.appendChild(labelText);

        const gradeInput = document.createElement('input');
        gradeInput.type = 'number';
        gradeInput.min = String(MIN_GRADE_VALUE);
        gradeInput.max = String(MAX_GRADE_VALUE);
        gradeInput.step = '1';
        gradeInput.inputMode = 'numeric';
        const existingGrade = getUserGradeForRoute(route.id);
        gradeInput.value = existingGrade !== null ? String(existingGrade) : '';
        gradeInput.placeholder = '—';
        gradeInput.dataset.infoTarget = 'route-grade';

        gradeLabel.appendChild(gradeInput);

        const gradeInputRow = document.createElement('div');
        gradeInputRow.className = 'grade-input-row';
        gradeInputRow.appendChild(gradeLabel);

        gradeForm.appendChild(gradeInputRow);

        let isSubmittingGrade = false;
        let lastSubmittedValue = gradeInput.value.trim();

        const commitGradeFromInput = async () => {
          if (isSubmittingGrade) {
            return;
          }

          const rawValue = gradeInput.value.trim();
          if (rawValue === lastSubmittedValue) {
            return;
          }

          isSubmittingGrade = true;

          try {
            if (!rawValue) {
              gradeInput.setCustomValidity('');
              await applyUserRouteGrade(route, null);
              lastSubmittedValue = '';
              gradeInput.value = '';
              return;
            }

            const parsed = normalizeGradeValue(rawValue);
            if (parsed === null) {
              gradeInput.setCustomValidity(
                `Enter a whole number between ${MIN_GRADE_VALUE} and ${MAX_GRADE_VALUE}.`,
              );
              gradeInput.reportValidity();
              return;
            }

            gradeInput.setCustomValidity('');
            await applyUserRouteGrade(route, parsed);
            lastSubmittedValue = String(parsed);
            gradeInput.value = String(parsed);
          } finally {
            isSubmittingGrade = false;
          }
        };

        gradeInput.addEventListener('input', () => {
          gradeInput.setCustomValidity('');
        });

        gradeInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            gradeForm.requestSubmit();
          }
        });

        gradeInput.addEventListener('blur', () => {
          void commitGradeFromInput();
        });

        gradeForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          event.stopPropagation();
          await commitGradeFromInput();
        });

        container.appendChild(gradeForm);

        return container;
      }

      async function applyUserRouteGrade(route, gradeValue) {
        if (!route || !route.id) {
          return;
        }

        if (!currentUser) {
          console.warn('Unable to save grade: no authenticated user.');
          return;
        }

        const username = await resolveAuthenticatedUsername();
        if (!username) {
          console.warn('Unable to save grade: user username missing.');
          return;
        }

        const userId = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to save grade: user ID missing.');
          return;
        }

        const sanitizedGrade = gradeValue === null ? null : normalizeGradeValue(gradeValue);
        if (sanitizedGrade === null && gradeValue !== null) {
          console.warn('Unable to save grade: invalid grade value provided.');
          return;
        }

        const ascentRef = doc(db, 'ascents', userId);

        try {
          await setDoc(
            ascentRef,
            {
              climber_uid: userId,
              climber_username: username,
              updatedAt: serverTimestamp(),
              routes: {
                [route.id]: {
                  grade: sanitizedGrade,
                  route_id: route.id,
                  climber_uid: userId,
                  climber_username: username,
                },
              },
            },
            { merge: true },
          );

          const existingEntry = userAscentDetails.get(route.id);
          const isAscended = existingEntry?.ascended === true;

          if (sanitizedGrade === null) {
            routeGrades.delete(route.id);

            if (existingEntry) {
              userAscentDetails.set(route.id, { ...existingEntry, ascended: isAscended, grade: null });
            } else {
              userAscentDetails.delete(route.id);
            }
          } else {
            routeGrades.set(route.id, sanitizedGrade);
            const nextEntry = { ...(existingEntry || {}), ascended: isAscended, grade: sanitizedGrade };
            userAscentDetails.set(route.id, nextEntry);
          }

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          await refreshMedianGrades();
        } catch (error) {
          console.error('Failed to update route grade:', error);
        }
      }

      async function fetchMedianGrades() {
        const medianMap = new Map();

        try {
          const snapshot = await getDocs(collection(db, 'ascents'));
          const gradeBuckets = new Map();

          snapshot.forEach((docSnap) => {
            const data = docSnap.data() ?? {};
            const routesData = data.routes;

            if (!routesData || typeof routesData !== 'object') {
              return;
            }

            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!details) {
                return;
              }

              const grade = normalizeGradeValue(details.grade);
              if (grade === null) {
                return;
              }

              if (!gradeBuckets.has(routeId)) {
                gradeBuckets.set(routeId, []);
              }

              gradeBuckets.get(routeId).push(grade);
            });
          });

          gradeBuckets.forEach((grades, routeId) => {
            if (!Array.isArray(grades) || grades.length === 0) {
              return;
            }

            grades.sort((a, b) => a - b);
            const mid = Math.floor(grades.length / 2);

            if (grades.length % 2 === 0) {
              medianMap.set(routeId, (grades[mid - 1] + grades[mid]) / 2);
            } else {
              medianMap.set(routeId, grades[mid]);
            }
          });
        } catch (error) {
          console.error('Failed to load route grades:', error);
        }

        return medianMap;
      }

      async function refreshMedianGrades() {
        routeMedianGrades = await fetchMedianGrades();

        if (Array.isArray(allRoutes)) {
          allRoutes.forEach((route) => {
            const median = routeMedianGrades.get(route.id);
            route.medianGrade = typeof median === 'number' && Number.isFinite(median) ? median : null;
          });
        }

        redraw();
      }

      function updateTooltipContent(route) {
        if (!tooltip) {
          return;
        }

        applyTooltipColorScheme(route);

        const fragment = document.createDocumentFragment();
        const ariaLines = [];

        const header = document.createElement('div');
        header.className = 'tooltip-header';
        header.appendChild(createTooltipCloseButton());

        const displayTitle = (route.title || route.id || '').trim();
        const titleLine = document.createElement('strong');
        titleLine.className = 'tooltip-title';
        titleLine.textContent = displayTitle || 'Route details';
        header.appendChild(titleLine);
        fragment.appendChild(header);
        if (titleLine.textContent) {
          ariaLines.push(titleLine.textContent);
        }

        const medianGrade =
          route && typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)
            ? route.medianGrade
            : null;
        const gradeDisplay = formatGradeDisplay(medianGrade);
        const gradeBadge = document.createElement('div');
        gradeBadge.className = 'tooltip-grade-badge';
        gradeBadge.setAttribute('aria-hidden', 'true');
        gradeBadge.setAttribute('data-grade', gradeDisplay);
        const gradeValue = document.createElement('span');
        gradeValue.className = 'tooltip-grade-value';
        gradeValue.textContent = gradeDisplay;
        gradeBadge.appendChild(gradeValue);
        const isAscended = Boolean(route && ascendedRoutes.has(route.id));
        if (isAscended) {
          gradeBadge.classList.add('ascended');
        }
        const gradeStrokeWidth = Math.max(2, Math.round(calculateRouteStrokeWidth(route)) || 2);
        gradeBadge.style.setProperty('--tooltip-grade-stroke-width', `${gradeStrokeWidth}px`);
        tooltip.style.setProperty('--tooltip-grade-stroke-width', `${gradeStrokeWidth}px`);
        const gradeCluster = document.createElement('div');
        gradeCluster.className = 'tooltip-grade-cluster';
        gradeCluster.appendChild(gradeBadge);

        let actionsContainer = null;
        const ensureActionsContainer = () => {
          if (!actionsContainer) {
            actionsContainer = document.createElement('div');
            actionsContainer.className = 'tooltip-actions';
          }
          return actionsContainer;
        };

        const focusButton = document.createElement('button');
        focusButton.type = 'button';
        focusButton.className = 'tooltip-action-button focus-toggle';
        const isFocused = focusedRouteId === route.id;
        if (!isFocused) {
          focusButton.classList.add('is-quiet');
        }
        focusButton.textContent = isFocused ? 'Remove focus' : 'Focus';
        focusButton.setAttribute('aria-pressed', isFocused ? 'true' : 'false');
        focusButton.dataset.infoTarget = 'route-focus';
        focusButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleRouteFocus(route);
        });
        ensureActionsContainer().appendChild(focusButton);

        fragment.appendChild(gradeCluster);
        if (actionsContainer) {
          fragment.appendChild(actionsContainer);
        }
        ariaLines.push(`Grade: ${gradeDisplay}`);

        const infoContainer = document.createElement('div');
        infoContainer.className = 'tooltip-lines';
        fragment.appendChild(infoContainer);

        const appendInfoLine = (text, className = '') => {
          if (!text) {
            return;
          }
          const line = document.createElement('div');
          line.className = className ? `tooltip-line ${className}` : 'tooltip-line';
          line.textContent = text;
          infoContainer.appendChild(line);
          ariaLines.push(text);
        };

        const setterValue = typeof route.setter === 'string' ? route.setter : '';
        appendInfoLine(`Setter: ${setterValue.trim() || 'Unknown'}`);

        const descriptionText =
          typeof route.description === 'string' ? route.description.trim() : '';
        appendInfoLine(descriptionText ? `Description: ${descriptionText}` : 'Description: —');

        appendInfoLine(`Date set: ${formatDisplayDate(route.date_set)}`);

        tooltip.replaceChildren(fragment);

        if (ariaLines.length) {
          tooltip.setAttribute('aria-label', ariaLines.join('\n'));
        } else {
          tooltip.removeAttribute('aria-label');
        }
      }

      function positionTooltip() {
        if (!tooltip) {
          return null;
        }

        const tooltipWidth = tooltip.offsetWidth || 0;
        const tooltipHeight = tooltip.offsetHeight || 0;
        const halfWidth = tooltipWidth / 2;

        const minHorizontalMargin = 12;
        const minLeft = halfWidth + minHorizontalMargin;
        const maxLeft = window.innerWidth - halfWidth - minHorizontalMargin;
        const desiredLeft = window.innerWidth / 2;
        const clampedLeft =
          maxLeft < minLeft ? window.innerWidth / 2 : Math.min(maxLeft, Math.max(minLeft, desiredLeft));

        const minVerticalMargin = 12;
        const maxTop = window.innerHeight - tooltipHeight - minVerticalMargin;
        const safeMaxTop = maxTop < minVerticalMargin ? Math.max(minVerticalMargin, maxTop) : maxTop;
        const isMobileViewport =
          typeof window.matchMedia === 'function'
            ? window.matchMedia('(max-width: 768px)').matches
            : window.innerWidth <= 768;
        const desiredTop =
          tutorialActive && isMobileViewport
            ? minVerticalMargin
            : (window.innerHeight - tooltipHeight) / 2;
        const clampedTop = Math.min(safeMaxTop, Math.max(minVerticalMargin, desiredTop));

        tooltip.style.left = `${clampedLeft}px`;
        tooltip.style.top = `${clampedTop}px`;

        return { x: clampedLeft, y: clampedTop };
      }

      function showTooltip(route, clientX, clientY, options = {}) {
        if (!tooltip) {
          return;
        }

        const { pin = false } = options;

        if (route.id !== activeRouteId) {
          updateTooltipContent(route);
        }

        const position = positionTooltip();
        tooltip.classList.add('visible');
        tooltip.setAttribute('aria-hidden', 'false');
        activeRouteId = route.id;

        if (pin) {
          pinnedRouteId = route.id;
          pinnedPosition = position;
          tooltip.classList.add('pinned');
        } else {
          pinnedRouteId = null;
          pinnedPosition = null;
          tooltip.classList.remove('pinned');
        }
      }

      function hideTooltip(options = {}) {
        if (!tooltip) {
          return;
        }

        const { force = false } = options;

        if (!force && pinnedRouteId) {
          return;
        }

        tooltip.classList.remove('visible');
        tooltip.classList.remove('pinned');
        tooltip.setAttribute('aria-hidden', 'true');
        activeRouteId = null;
        pinnedRouteId = null;
        pinnedPosition = null;
      }

      function setRouteFocus(route, shouldFocus) {
        if (!route || typeof route.id !== 'string') {
          return;
        }

        const nextFocusedId = shouldFocus ? route.id : null;
        const shouldRestoreProgressionFocus = Boolean(
          shouldFocus && progressionList && isProgressionModalOpen()
        );

        if (focusedRouteId === nextFocusedId) {
          redraw();

          if (tooltip && tooltip.classList.contains('visible') && activeRouteId === route.id) {
            updateTooltipContent(route);
          }

          renderProgressionList();

          if (shouldRestoreProgressionFocus) {
            const entry = progressionList.querySelector(
              `[data-route-id="${route.id}"]`,
            );
            if (entry && typeof entry.focus === 'function') {
              entry.focus();
            }
          }
          return;
        }

        focusedRouteId = nextFocusedId;

        redraw();

        if (tooltip && tooltip.classList.contains('visible') && activeRouteId === route.id) {
          updateTooltipContent(route);
        }

        renderProgressionList();

        if (shouldRestoreProgressionFocus) {
          const entry = progressionList.querySelector(`[data-route-id="${route.id}"]`);
          if (entry && typeof entry.focus === 'function') {
            entry.focus();
          }
        }
      }

      function focusRoute(route) {
        setRouteFocus(route, true);
      }

      function toggleRouteFocus(route) {
        if (!route || typeof route.id !== 'string') {
          return;
        }

        setRouteFocus(route, focusedRouteId !== route.id);
      }

      function extractClientPoint(event) {
        if (typeof event.clientX === 'number' && typeof event.clientY === 'number') {
          return { x: event.clientX, y: event.clientY };
        }

        const touch = event.touches?.[0] ?? event.changedTouches?.[0];
        if (touch) {
          return { x: touch.clientX, y: touch.clientY };
        }

        return null;
      }

      function distanceSquared(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return dx * dx + dy * dy;
      }

      function isPointNearSegment(px, py, x1, y1, x2, y2, padding = 0) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSquared = dx * dx + dy * dy;

        if (lengthSquared <= 0.0001) {
          return distanceSquared(px, py, x1, y1) <= padding * padding;
        }

        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));

        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        return distanceSquared(px, py, projX, projY) <= padding * padding;
      }

      function getRouteEntryAtClientPoint(clientX, clientY) {
        if (!Array.isArray(routeInteractionEntries) || routeInteractionEntries.length === 0) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        for (let index = routeInteractionEntries.length - 1; index >= 0; index -= 1) {
          const entry = routeInteractionEntries[index];
          if (!entry || !entry.route) {
            continue;
          }

          if (entry.type === 'circle') {
            const radius = Number(entry.r) || 0;
            if (radius > 0) {
              const distance = distanceSquared(x, y, Number(entry.cx), Number(entry.cy));
              if (distance <= radius * radius) {
                return { route: entry.route, canvasX: entry.cx, canvasY: entry.cy };
              }
            }
          } else if (entry.type === 'rect') {
            const left = Number(entry.left);
            const right = Number(entry.right);
            const top = Number(entry.top);
            const bottom = Number(entry.bottom);
            if (x >= left && x <= right && y >= top && y <= bottom) {
              return {
                route: entry.route,
                canvasX: (left + right) / 2,
                canvasY: (top + bottom) / 2,
              };
            }
          } else if (entry.type === 'segment') {
            const padding = Number(entry.padding) || 0;
            const x1 = Number(entry.x1);
            const y1 = Number(entry.y1);
            const x2 = Number(entry.x2);
            const y2 = Number(entry.y2);
            if (isPointNearSegment(x, y, x1, y1, x2, y2, padding)) {
              return {
                route: entry.route,
                canvasX: (x1 + x2) / 2,
                canvasY: (y1 + y2) / 2,
              };
            }
          }
        }

        return null;
      }

      function applyLocationFilter() {
        const desiredLocation = normalizeLocationName(currentLocation?.name);
        const fallbackLocation = normalizeLocationName(getDefaultLocation()?.name);
        const targetLocation = desiredLocation || fallbackLocation;

        if (!targetLocation) {
          routes = [...allRoutes];
        } else {
          routes = allRoutes.filter((route) => {
            const routeLocation =
              typeof route?.locationKey === 'string'
                ? route.locationKey
                : normalizeLocationName(route?.location);
            return routeLocation === targetLocation;
          });
        }

        if (focusedRouteId) {
          const hasFocusedRoute = routes.some((route) => route.id === focusedRouteId);
          if (!hasFocusedRoute) {
            focusedRouteId = null;
            hideTooltip({ force: true });
          }
        }

        synchroniseAscentsWithRoutes({ shouldRedraw: false });
        redraw();
      }

      async function loadRoutes() {
        try {
          const [routesSnapshot, medianMap, wallSnapshot] = await Promise.all([
            getDocs(collection(db, 'routes')),
            fetchMedianGrades(),
            getDocs(collection(db, WALL_COLLECTION)),
          ]);

          routeMedianGrades = medianMap instanceof Map ? medianMap : new Map();

          wallSettingsCache.clear();
          const hiddenWallKeys = new Set();
          let locationsChanged = false;
          wallSnapshot.forEach((docSnap) => {
            const data = docSnap.data();
            const settings = normalizeWallSettings(data);
            const normalizedId = normalizeWallKey(docSnap.id);
            const normalizedName = normalizeWallKey(data?.name);
            const normalizedKeyField = normalizeWallKey(data?.key);
            const isHidden = data?.hidden === true;

            if (normalizedId) {
              wallSettingsCache.set(normalizedId, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedId);
              }
            }

            if (normalizedName) {
              wallSettingsCache.set(normalizedName, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedName);
              }
            }

            if (normalizedKeyField) {
              wallSettingsCache.set(normalizedKeyField, settings);
              if (isHidden) {
                hiddenWallKeys.add(normalizedKeyField);
              }
            }

            const { changed } = upsertLocation({
              key: typeof data?.key === 'string' ? data.key : docSnap.id,
              name: typeof data?.name === 'string' ? data.name : '',
              image: typeof data?.background_url === 'string' ? data.background_url : '',
              fallbackName: typeof data?.name === 'string' && data.name ? data.name : docSnap.id,
              hidden: isHidden,
            });

            if (changed) {
              locationsChanged = true;
            }
          });

          if (locationsChanged) {
            renderLocationOptions();
            synchronizeCurrentLocationReference();
          } else {
            ensureCurrentLocationVisible();
          }

          allRoutes = routesSnapshot.docs
            .map((docSnap) => {
              const data = docSnap.data();
              const normalizedPoints = Array.isArray(data.points)
                ? data.points
                    .map((point) => {
                      const x = Number(point?.x);
                      const y = Number(point?.y);
                      if (!Number.isFinite(x) || !Number.isFinite(y)) {
                        return null;
                      }
                      return { x, y };
                    })
                    .filter(Boolean)
                : [];

              const median = routeMedianGrades.get(docSnap.id);
              const medianGrade = typeof median === 'number' && Number.isFinite(median) ? median : null;
              const rawLocationValue = typeof data.location === 'string' ? data.location.trim() : '';
              const defaultLocation = getDefaultLocation();
              const normalizedLocation =
                normalizeLocationName(rawLocationValue) || normalizeLocationName(defaultLocation?.name);
              const displayLocation = rawLocationValue || defaultLocation?.name || '';

              if (normalizedLocation && hiddenWallKeys.has(normalizedLocation)) {
                return null;
              }

              const fallbackWallSettings = {
                pointDiameter: data.pointDiameter,
                rectangleWidth: data.rectangleWidth,
                rectangleHeight: data.rectangleHeight,
                gradeBarBaseHeight: data.gradeBarBaseHeight,
                gradeBarMaxHeight: data.gradeBarMaxHeight,
                gradeBarWidth: data.gradeBarWidth,
                transparency: data.transparency ?? data.gradeBarTransparency,
                unfocusedTransparency: data.unfocusedTransparency,
              };
              const wallSettings = resolveWallSettings(normalizedLocation, fallbackWallSettings);

              return {
                id: docSnap.id,
                strokeColor: typeof data.strokeColor === 'string' ? data.strokeColor : '#ffde59',
                points: normalizedPoints,
                title: typeof data.title === 'string' ? data.title : '',
                setter: typeof data.setter === 'string' ? data.setter : '',
                description: typeof data.description === 'string' ? data.description : '',
                date_set: normalizeDate(data.date_set),
                date_removed: normalizeDate(data.date_removed),
                location: displayLocation,
                locationKey: normalizedLocation,
                medianGrade,
                pathType: normalizePathType(data.pathType),
                pointDiameter: wallSettings.pointDiameter,
                rectangleWidth: wallSettings.rectangleWidth,
                rectangleHeight: wallSettings.rectangleHeight,
                gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
                gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
                gradeBarWidth: wallSettings.gradeBarWidth,
                gradeBarTransparency: wallSettings.gradeBarTransparency,
                unfocusedTransparency: wallSettings.unfocusedTransparency,
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              const nameA = (a.title || a.id).toLowerCase();
              const nameB = (b.title || b.id).toLowerCase();
              return nameA.localeCompare(nameB);
            });

          applyLocationFilter();
        } catch (error) {
          console.error('Failed to load routes:', error);
          allRoutes = [];
          routes = [];
          focusedRouteId = null;
          routeMedianGrades = new Map();
          renderProgressionList();
          redraw();
        }
      }

      async function toggleRouteAscent(route) {
        if (!currentUser) {
          return;
        }

        const username = await resolveAuthenticatedUsername();
        if (!username) {
          console.warn('Unable to mark ascent: user username missing.');
          return;
        }

        const userId = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to mark ascent: user ID missing.');
          return;
        }

        const routeId = route?.id;
        if (!routeId) {
          console.warn('Unable to mark ascent: route ID missing.');
          return;
        }
        const ascentRef = doc(db, 'ascents', userId);
        const isAscended = ascendedRoutes.has(routeId);
        const previousEntry = userAscentDetails.get(routeId) || {};
        const persistedGrade =
          typeof previousEntry.grade === 'number' && Number.isFinite(previousEntry.grade)
            ? previousEntry.grade
            : getUserGradeForRoute(routeId);
        const normalizedGrade =
          typeof persistedGrade === 'number' && Number.isFinite(persistedGrade)
            ? persistedGrade
            : null;

        try {
          if (isAscended) {
            await setDoc(
              ascentRef,
              {
                climber_uid: userId,
                climber_username: username,
                updatedAt: serverTimestamp(),
                routes: {
                  [routeId]: {
                    route_id: routeId,
                    climber_uid: userId,
                    climber_username: username,
                    grade: normalizedGrade,
                    ascended: false,
                    date_ascended: null,
                  },
                },
              },
              { merge: true },
            );

            userAscentDetails.set(routeId, {
              ascended: false,
              grade: normalizedGrade,
            });
          } else {
            const now = new Date().toISOString();
            await setDoc(
              ascentRef,
              {
                climber_uid: userId,
                climber_username: username,
                updatedAt: serverTimestamp(),
                routes: {
                  [routeId]: {
                    route_id: routeId,
                    date_ascended: now,
                    climber_uid: userId,
                    climber_username: username,
                    grade: normalizedGrade,
                    ascended: true,
                  },
                },
              },
              { merge: true },
            );
            userAscentDetails.set(routeId, {
              ascended: true,
              grade: normalizedGrade,
              dateAscended: now,
            });
          }

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          redraw();
        } catch (error) {
          console.error('Failed to update ascent:', error);
        }
      }

      function computeCanvasDimensions() {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const aspectRatio = Number.isFinite(canvasAspectRatio) && canvasAspectRatio > 0
          ? canvasAspectRatio
          : DEFAULT_CANVAS_ASPECT_RATIO;
        const enableScroll = viewportWidth <= 768 && viewportHeight > viewportWidth;

        if (enableScroll) {
          const height = viewportHeight;
          const width = Math.max(viewportWidth, Math.round(height * aspectRatio));
          return { width, height, enableScroll };
        }

        return {
          width: viewportWidth,
          height: viewportHeight,
          enableScroll: false,
        };
      }

      function resizeCanvas() {
        const { width, height, enableScroll } = computeCanvasDimensions();

        if (canvasContainer) {
          canvasContainer.classList.toggle('scrollable', enableScroll);
        }

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        if (canvasContainer) {
          if (enableScroll) {
            const maxScrollLeft = Math.max(0, width - window.innerWidth);
            if (!isHorizontalScrollEnabled) {
              canvasContainer.scrollLeft = Math.max(0, maxScrollLeft / 2);
            } else if (canvasContainer.scrollLeft > maxScrollLeft) {
              canvasContainer.scrollLeft = maxScrollLeft;
            }
          } else if (isHorizontalScrollEnabled) {
            canvasContainer.scrollLeft = 0;
          }
        }

        isHorizontalScrollEnabled = enableScroll;
        redraw();
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (backgroundReady && backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        routeInteractionEntries = [];
        let isFocusActive = false;
        let resolvedFocusRoute = null;
        let focusedRoutePointKeys = null;

        if (focusedRouteId) {
          resolvedFocusRoute = routes.find((route) => route.id === focusedRouteId) || null;
          if (resolvedFocusRoute) {
            isFocusActive = true;
            focusedRoutePointKeys = buildNormalizedPointKeySet(resolvedFocusRoute.points);
          } else {
            focusedRouteId = null;
          }
        }

        const shouldPreservePinned = Boolean(
          pinnedRouteId &&
            pinnedPosition &&
            (!isFocusActive || pinnedRouteId === focusedRouteId),
        );
        const pinnedRoute = shouldPreservePinned
          ? routes.find((route) => route.id === pinnedRouteId)
          : null;

        if (!shouldPreservePinned) {
          hideTooltip();
        } else if (!pinnedRoute) {
          hideTooltip({ force: true });
        }

        const overlapGroups = buildOverlappingShapeGroups(routes);
        const routeAlphaMap = new Map();

        routes.forEach((route) => {
          if (!route || typeof route.id !== 'string') {
            return;
          }
          const isFocused = isFocusActive && route.id === focusedRouteId;
          const routeAlpha = isFocused
            ? 1
            : isFocusActive
              ? normalizeUnfocusedTransparency(route.unfocusedTransparency)
              : 1;
          routeAlphaMap.set(route.id, routeAlpha);
        });

        const handledOverlapKeys = new Set();

        routes.forEach((route) => {
          const isFocused = isFocusActive && route.id === focusedRouteId;
          const routeAlpha = routeAlphaMap.get(route?.id) ?? 1;
          const omitOverlaps = !isFocused && focusedRoutePointKeys?.size ? focusedRoutePointKeys : null;
          drawRoute(route, {
            alpha: routeAlpha,
            omitOverlappingPointKeys: omitOverlaps,
            overlapGroups,
            handledOverlapKeys,
            routeAlphaMap,
            isFocused,
          });
        });
        if (pinnedRoute && tooltip) {
          updateTooltipContent(pinnedRoute);
          tooltip.classList.add('visible');
          tooltip.classList.add('pinned');
          tooltip.setAttribute('aria-hidden', 'false');
          const updatedPosition = positionTooltip();
          if (updatedPosition) {
            pinnedPosition = updatedPosition;
          }
        }
      }

      function clamp(value, min, max) {
        if (!Number.isFinite(value)) {
          return min;
        }
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }

      function createNormalizedPointKey(x, y) {
        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          return null;
        }

        const clampedX = Math.min(Math.max(x, 0), 1);
        const clampedY = Math.min(Math.max(y, 0), 1);
        const scaledX = Math.round(clampedX * 10000);
        const scaledY = Math.round(clampedY * 10000);
        return `${scaledX}:${scaledY}`;
      }

      function buildNormalizedPointKeySet(points = []) {
        const keys = new Set();
        if (!Array.isArray(points) || !points.length) {
          return keys;
        }

        points.forEach((point) => {
          const x = Number(point?.x);
          const y = Number(point?.y);
          const key = createNormalizedPointKey(x, y);
          if (key) {
            keys.add(key);
          }
        });

        return keys;
      }

      function getRouteStrokeColor(route) {
        const rawColor = route?.strokeColor;
        if (typeof rawColor === 'string' && rawColor.trim()) {
          return rawColor;
        }
        return '#ffde59';
      }

      function getGradeColorForValue(value) {
        if (typeof value !== 'number' || !Number.isFinite(value)) {
          return null;
        }

        const rounded = Math.round(value);
        if (!Number.isFinite(rounded)) {
          return null;
        }

        const clamped = Math.min(Math.max(rounded, MIN_GRADE_VALUE), MAX_GRADE_VALUE);
        return GRADE_COLOR_MAP.get(clamped) ?? null;
      }

      function getRouteGradeColor(route) {
        if (!route) {
          return null;
        }

        let grade =
          typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)
            ? route.medianGrade
            : null;

        if (grade === null && typeof route.id === 'string') {
          const userGrade = getUserGradeForRoute(route.id);
          if (typeof userGrade === 'number' && Number.isFinite(userGrade)) {
            grade = userGrade;
          }
        }

        return getGradeColorForValue(grade);
      }

      function getRouteDisplayColor(route) {
        if (viewMode === VIEW_MODE_GRADE_COLORS) {
          return getRouteGradeColor(route) ?? getRouteStrokeColor(route);
        }
        return getRouteStrokeColor(route);
      }

      function createOverlapGroupKey(pathType, pointKey) {
        if (!pathType || !pointKey) {
          return null;
        }
        return `${pathType}::${pointKey}`;
      }

      function buildOverlappingShapeGroups(routeList = []) {
        const groups = new Map();

        if (!Array.isArray(routeList) || !routeList.length) {
          return groups;
        }

        routeList.forEach((route) => {
          if (!route) {
            return;
          }

          const pathType = normalizePathType(route.pathType);
          if (pathType !== PATH_TYPE_POINT && pathType !== PATH_TYPE_RECTANGLE) {
            return;
          }

          const points = Array.isArray(route.points) ? route.points : [];
          if (!points.length) {
            return;
          }

          const strokeColor = getRouteStrokeColor(route);
          const normalizedPointDiameter = normalizePointDiameter(route.pointDiameter);
          const normalizedRectangleWidth = normalizeRectangleSize(
            route.rectangleWidth,
            DEFAULT_RECTANGLE_WIDTH,
          );
          const normalizedRectangleHeight = normalizeRectangleSize(
            route.rectangleHeight,
            DEFAULT_RECTANGLE_HEIGHT,
          );

          points.forEach((point) => {
            const normalizedX = Number(point?.x);
            const normalizedY = Number(point?.y);
            const pointKey = createNormalizedPointKey(normalizedX, normalizedY);
            if (!pointKey) {
              return;
            }

            const groupKey = createOverlapGroupKey(pathType, pointKey);
            if (!groupKey) {
              return;
            }

            if (!groups.has(groupKey)) {
              groups.set(groupKey, {
                pathType,
                entries: [],
              });
            }

            const group = groups.get(groupKey);
            group.entries.push({
              routeId: route.id,
              color: strokeColor,
              pointDiameter: normalizedPointDiameter,
              rectangleWidth: normalizedRectangleWidth,
              rectangleHeight: normalizedRectangleHeight,
            });
          });
        });

        for (const [key, group] of groups) {
          if (!group || !Array.isArray(group.entries) || group.entries.length <= 1) {
            groups.delete(key);
          }
        }

        return groups;
      }

      function drawOverlappingPointGroup(ctx, center, entries) {
        if (!ctx || !center || !entries || entries.length <= 1) {
          return;
        }

        const total = entries.length;
        const radii = entries.map((entry) => Math.max(1, Number(entry.pointDiameter) / 2));
        const radius = Math.max(...radii, 4);
        const step = (Math.PI * 2) / total;
        const startAngle = -Math.PI / 2;

        ctx.save();
        ctx.setLineDash([]);
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';

        entries.forEach((entry, index) => {
          const strokeWidth = Math.max(2, Math.round(Number(entry.pointDiameter) / 10) || 2);
          const angleStart = startAngle + step * index;
          const angleEnd = angleStart + step;

          ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = entry.color || '#ffde59';
          ctx.beginPath();
          ctx.arc(center.x, center.y, radius, angleStart, angleEnd);
          ctx.stroke();
        });

        ctx.restore();
      }

      function drawOverlappingRectangleGroup(ctx, center, entries) {
        if (!ctx || !center || !entries || entries.length <= 1) {
          return;
        }

        const widths = entries.map((entry) => Math.max(1, Number(entry.rectangleWidth) || 0));
        const heights = entries.map((entry) => Math.max(1, Number(entry.rectangleHeight) || 0));
        const width = Math.max(...widths, 4);
        const height = Math.max(...heights, 4);
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const perimeter = 2 * (width + height);

        if (!Number.isFinite(perimeter) || perimeter <= 0) {
          return;
        }

        const segmentLength = perimeter / entries.length;
        const edges = [
          { length: width, startX: center.x - halfWidth, startY: center.y - halfHeight, dx: 1, dy: 0 },
          { length: height, startX: center.x + halfWidth, startY: center.y - halfHeight, dx: 0, dy: 1 },
          { length: width, startX: center.x + halfWidth, startY: center.y + halfHeight, dx: -1, dy: 0 },
          { length: height, startX: center.x - halfWidth, startY: center.y + halfHeight, dx: 0, dy: -1 },
        ];
        const edgeCount = edges.length;

        let offset = 0;

        entries.forEach((entry) => {
          let localOffset = offset % perimeter;
          if (localOffset < 0) {
            localOffset += perimeter;
          }

          let edgeIndex = 0;
          while (localOffset >= edges[edgeIndex].length && edgeIndex < edgeCount - 1) {
            localOffset -= edges[edgeIndex].length;
            edgeIndex += 1;
          }

          let currentX = edges[edgeIndex].startX + edges[edgeIndex].dx * localOffset;
          let currentY = edges[edgeIndex].startY + edges[edgeIndex].dy * localOffset;
          let remaining = segmentLength;

          ctx.save();
          ctx.setLineDash([]);
          ctx.lineCap = 'butt';
          ctx.lineJoin = 'miter';
          ctx.lineWidth = Math.max(
            2,
            Math.round(Math.max(Number(entry.rectangleWidth) || 0, Number(entry.rectangleHeight) || 0) / 10) || 2,
          );
          ctx.strokeStyle = entry.color || '#ffde59';
          ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;

          while (remaining > 0) {
            const edge = edges[edgeIndex];
            const available = edge.length - localOffset;
            const step = Math.min(remaining, available);
            const nextOffset = localOffset + step;
            const nextX = edge.startX + edge.dx * nextOffset;
            const nextY = edge.startY + edge.dy * nextOffset;

            ctx.beginPath();
            ctx.moveTo(currentX, currentY);
            ctx.lineTo(nextX, nextY);
            ctx.stroke();

            remaining -= step;
            currentX = nextX;
            currentY = nextY;
            localOffset = 0;
            edgeIndex = (edgeIndex + 1) % edgeCount;
          }

          ctx.restore();

          offset += segmentLength;
          if (offset >= perimeter) {
            offset -= perimeter;
          }
        });
      }

      function calculateRouteStrokeWidth(route) {
        const pathType = normalizePathType(route?.pathType);
        if (pathType === PATH_TYPE_POINT) {
          const diameter = normalizePointDiameter(route?.pointDiameter);
          return Math.max(2, Math.round(diameter / 10));
        }
        if (pathType === PATH_TYPE_RECTANGLE) {
          const width = normalizeRectangleSize(route?.rectangleWidth, DEFAULT_RECTANGLE_WIDTH);
          const height = normalizeRectangleSize(route?.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT);
          return Math.max(2, Math.round(Math.max(width, height) / 10));
        }
        return 10;
      }

      function drawRoute(route, options = {}) {
        const strokeColor = getRouteDisplayColor(route);
        const points = Array.isArray(route.points) ? route.points : [];

        const alphaValue = Number(options.alpha);
        const routeAlpha = Number.isFinite(alphaValue)
          ? Math.min(Math.max(alphaValue, 0), 1)
          : 1;

        const omitOverlapKeys =
          options?.omitOverlappingPointKeys instanceof Set ? options.omitOverlappingPointKeys : null;
        const overlapGroups =
          options?.overlapGroups instanceof Map ? options.overlapGroups : null;
        const handledOverlapKeys =
          options?.handledOverlapKeys instanceof Set ? options.handledOverlapKeys : null;
        const routeAlphaMap =
          options?.routeAlphaMap instanceof Map ? options.routeAlphaMap : null;
        const isFocusedRoute = Boolean(options?.isFocused);

        if (!points.length) {
          return;
        }

        const pathType = normalizePathType(route.pathType);
        const supportsOverlapPattern =
          pathType === PATH_TYPE_POINT || pathType === PATH_TYPE_RECTANGLE;
        const shouldFilterOverlaps =
          omitOverlapKeys && omitOverlapKeys.size > 0 && supportsOverlapPattern;

        const pathPoints = [];
        const visiblePoints = [];
        const interactionRegions = [];

        points.forEach((point) => {
          const normalizedX = Number(point?.x);
          const normalizedY = Number(point?.y);
          if (!Number.isFinite(normalizedX) || !Number.isFinite(normalizedY)) {
            return;
          }

          const scaledPoint = {
            x: normalizedX * canvas.width,
            y: normalizedY * canvas.height,
          };
          pathPoints.push(scaledPoint);

          const pointKey = supportsOverlapPattern
            ? createNormalizedPointKey(normalizedX, normalizedY)
            : null;

          if (shouldFilterOverlaps && pointKey && omitOverlapKeys.has(pointKey)) {
            return;
          }

          const overlapKey =
            pointKey && overlapGroups ? createOverlapGroupKey(pathType, pointKey) : null;
          const overlapGroup =
            overlapKey && overlapGroups ? overlapGroups.get(overlapKey) : null;

          if (
            overlapGroup &&
            Array.isArray(overlapGroup.entries) &&
            overlapGroup.entries.length > 1 &&
            !isFocusedRoute
          ) {
            if (handledOverlapKeys && handledOverlapKeys.has(overlapKey)) {
              return;
            }

            const entriesWithAlpha = overlapGroup.entries.map((entry) => {
              const mappedAlpha = routeAlphaMap?.get(entry.routeId);
              const entryAlpha = Number.isFinite(mappedAlpha) ? mappedAlpha : 1;
              return { ...entry, alpha: entryAlpha };
            });

            if (handledOverlapKeys) {
              handledOverlapKeys.add(overlapKey);
            }

            if (pathType === PATH_TYPE_POINT) {
              drawOverlappingPointGroup(ctx, scaledPoint, entriesWithAlpha);
            } else if (pathType === PATH_TYPE_RECTANGLE) {
              drawOverlappingRectangleGroup(ctx, scaledPoint, entriesWithAlpha);
            }
            return;
          }

          visiblePoints.push(scaledPoint);
        });

        if (!pathPoints.length) {
          return;
        }

        const pointDiameter = normalizePointDiameter(route.pointDiameter);
        const rectangleWidth = normalizeRectangleSize(route.rectangleWidth, DEFAULT_RECTANGLE_WIDTH);
        const rectangleHeight = normalizeRectangleSize(route.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT);

        ctx.save();
        ctx.globalAlpha = routeAlpha;
        if (pathType === PATH_TYPE_POINT) {
          const circleRadius = Math.max(1, pointDiameter / 2);
          const strokeWidth = Math.max(2, Math.round(pointDiameter / 10));
          if (visiblePoints.length) {
            const path = new Path2D();

            visiblePoints.forEach((point) => {
              path.moveTo(point.x + circleRadius, point.y);
              path.arc(point.x, point.y, circleRadius, 0, Math.PI * 2);
            });

            ctx.save();
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke(path);
            ctx.restore();

            const padding = Math.max(4, strokeWidth / 2);
            visiblePoints.forEach((point) => {
              interactionRegions.push({
                type: 'circle',
                cx: point.x,
                cy: point.y,
                r: circleRadius + padding,
              });
            });
          }
        } else if (pathType === PATH_TYPE_RECTANGLE) {
          const rectWidth = Math.max(1, rectangleWidth);
          const rectHeight = Math.max(1, rectangleHeight);
          const halfWidth = Math.max(1, rectWidth / 2);
          const halfHeight = Math.max(1, rectHeight / 2);
          const strokeWidth = Math.max(2, Math.round(Math.max(rectWidth, rectHeight) / 10));
          if (visiblePoints.length) {
            const path = new Path2D();

            visiblePoints.forEach((point) => {
              path.rect(point.x - halfWidth, point.y - halfHeight, rectWidth, rectHeight);
            });

            ctx.save();
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke(path);
            ctx.restore();

            const padding = Math.max(4, strokeWidth / 2);
            visiblePoints.forEach((point) => {
              interactionRegions.push({
                type: 'rect',
                left: point.x - halfWidth - padding,
                right: point.x + halfWidth + padding,
                top: point.y - halfHeight - padding,
                bottom: point.y + halfHeight + padding,
              });
            });
          }
        } else if (pathPoints.length >= 2) {
          const path = new Path2D();
          path.moveTo(pathPoints[0].x, pathPoints[0].y);

          for (let i = 0; i < pathPoints.length - 1; i++) {
            const p0 = i === 0 ? pathPoints[0] : pathPoints[i - 1];
            const p1 = pathPoints[i];
            const p2 = pathPoints[i + 1];
            const p3 = i + 2 < pathPoints.length ? pathPoints[i + 2] : pathPoints[i + 1];

            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;

            path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
          }

          ctx.save();
          const strokeWidth = Math.max(6, Math.round(calculateRouteStrokeWidth(route)) || 6);
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = strokeColor;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.stroke(path);
          ctx.restore();

          const padding = Math.max(6, strokeWidth / 2 + 4);
          for (let i = 0; i < pathPoints.length - 1; i += 1) {
            const start = pathPoints[i];
            const end = pathPoints[i + 1];
            if (!start || !end) {
              continue;
            }

            interactionRegions.push({
              type: 'segment',
              x1: start.x,
              y1: start.y,
              x2: end.x,
              y2: end.y,
              padding,
            });
          }
        }
        ctx.restore();

        if (interactionRegions.length) {
          interactionRegions.forEach((region) => {
            if (!region) {
              return;
            }
            routeInteractionEntries.push({
              ...region,
              route,
            });
          });
        }
      }

      function handlePointerMove(event) {
        if ('pointerType' in event) {
          const pointerType = event.pointerType;
          if (pointerType && pointerType !== 'mouse' && pointerType !== 'pen') {
            canvas.style.cursor = '';
            return;
          }
        }

        const entry = getRouteEntryAtClientPoint(event.clientX, event.clientY);

        if (entry && entry.route) {
          canvas.style.cursor = 'pointer';
        } else {
          canvas.style.cursor = '';
          if (!pinnedRouteId) {
            hideTooltip();
          }
        }
      }

      function handlePointerLeave() {
        canvas.style.cursor = '';
        if (!pinnedRouteId) {
          hideTooltip();
        }
      }

      function handleCanvasPointerDown(event) {
        const point = extractClientPoint(event);
        if (!point) {
          return;
        }

        const entry = getRouteEntryAtClientPoint(point.x, point.y);

        if (entry && entry.route) {
          showTooltip(entry.route, point.x, point.y, { pin: true });
        } else if (!pinnedRouteId) {
          hideTooltip({ force: true });
        }
      }

      function handleDocumentPointerDown(event) {
        if (!tooltip) {
          return;
        }

        if (event.target === canvas) {
          return;
        }

        if (tooltip.contains(event.target)) {
          return;
        }

        if (pinnedRouteId) {
          return;
        }

        hideTooltip({ force: true });
      }

      if ('PointerEvent' in window) {
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerleave', handlePointerLeave);
        canvas.addEventListener('pointerdown', handleCanvasPointerDown);
        document.addEventListener('pointerdown', handleDocumentPointerDown);
      } else {
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseleave', handlePointerLeave);
        canvas.addEventListener('mousedown', handleCanvasPointerDown);
        canvas.addEventListener('touchstart', handleCanvasPointerDown);
        document.addEventListener('mousedown', handleDocumentPointerDown);
        document.addEventListener('touchstart', handleDocumentPointerDown);
      }

      setupTutorialInteractions();

      window.addEventListener('resize', resizeCanvas);

      if (backgroundImage.complete) {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      } else {
        resizeCanvas();
      }
    </script>
  </body>
</html>
