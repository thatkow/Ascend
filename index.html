<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ascend</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #000;
        --wall-background: url('./location/New Wall.jpg');
        background-image: var(--wall-background);
        background-position: center;
        background-size: 100% 100%;
        background-repeat: no-repeat;
        background-attachment: fixed;
        color: #fff;
        overflow: hidden;
      }

      .hidden {
        display: none !important;
      }

      .canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .canvas-container.scrollable {
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
      }

      .canvas-utility-buttons {
        position: fixed;
        top: 1rem;
        left: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        z-index: 15;
        pointer-events: none;
      }

      .canvas-utility-buttons button {
        pointer-events: auto;
        border: 1px solid rgba(255, 255, 255, 0.35);
        border-radius: 999px;
        padding: 0.55rem 1.25rem;
        background: rgba(0, 0, 0, 0.65);
        color: #fff;
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 0.04em;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          border-color 0.2s ease;
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(6px);
      }

      .canvas-utility-buttons button:hover,
      .canvas-utility-buttons button:focus-visible {
        outline: none;
        transform: translateY(-1px);
        background: rgba(0, 0, 0, 0.85);
        border-color: rgba(255, 255, 255, 0.55);
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.45);
      }

      canvas {
        display: block;
        height: 100%;
        width: auto;
        min-width: 100%;
      }

      .auth-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        padding: 1.5rem;
        backdrop-filter: blur(2px);
        z-index: 10;
      }

      .auth-card {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1rem;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: min(90vw, 360px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      }

      .auth-card h1 {
        font-size: 1.4rem;
        text-align: center;
      }

      .auth-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.95rem;
      }

      .auth-field input {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        padding: 0.65rem 1rem;
        font-size: 1rem;
      }

      .auth-submit {
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1rem;
        background: #7ed957;
        color: #111;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .auth-submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
      }

      .auth-switch {
        font-size: 0.9rem;
        text-align: center;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        justify-content: center;
        align-items: center;
      }

      .auth-switch button {
        background: none;
        border: none;
        color: #7ed957;
        font-weight: 600;
        cursor: pointer;
        text-decoration: underline;
      }

      .auth-error {
        min-height: 1.25rem;
        color: #ff7a7a;
        text-align: center;
        font-size: 0.85rem;
      }

      .app-header {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 5;
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      .location-button {
        border: 1px solid rgba(255, 255, 255, 0.35);
        border-radius: 999px;
        padding: 0.6rem 1.25rem;
        font-size: 0.9rem;
        font-weight: 700;
        cursor: pointer;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.2));
        color: #fff;
        backdrop-filter: blur(6px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .location-button:hover,
      .location-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
        outline: none;
      }

      .location-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(3px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        z-index: 20;
      }

      .location-modal.hidden {
        display: none !important;
      }

      .location-modal-content {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1.25rem;
        width: min(720px, 92vw);
        max-height: 90vh;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .location-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .location-modal-title {
        font-size: 1.35rem;
        font-weight: 700;
      }

      .location-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.4rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .location-modal-close:hover,
      .location-modal-close:focus-visible {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .location-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
      }

      .location-option {
        border: none;
        border-radius: 1rem;
        padding: 0;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        cursor: pointer;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        text-align: left;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .location-option:hover,
      .location-option:focus-visible {
        transform: translateY(-4px);
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.4);
        outline: none;
        background: rgba(255, 255, 255, 0.18);
      }

      .location-option[aria-current='true'] {
        box-shadow: 0 0 0 3px rgba(126, 217, 87, 0.75);
        background: rgba(126, 217, 87, 0.18);
      }

      .location-option-preview {
        position: relative;
        width: 100%;
        padding-top: 66%;
        background-size: cover;
        background-position: center;
      }

      .location-option-label {
        padding: 0.9rem 1rem;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      .info-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .info-button {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 2px solid rgba(126, 217, 87, 0.6);
        background: #7ed957;
        color: #0c1905;
        font-size: 1.05rem;
        font-weight: 700;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 22px rgba(126, 217, 87, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }

      .info-button:hover,
      .info-button:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 12px 28px rgba(126, 217, 87, 0.45);
        border-color: rgba(126, 217, 87, 0.9);
        outline: none;
      }

      .info-button:focus-visible {
        box-shadow: 0 0 0 4px rgba(126, 217, 87, 0.25), 0 12px 28px rgba(126, 217, 87, 0.45);
      }

      .info-popover {
        position: absolute;
        top: calc(100% + 0.75rem);
        right: 0;
        width: min(280px, 70vw);
        padding: 0.9rem 1rem;
        border-radius: 0.75rem;
        background: rgba(0, 0, 0, 0.85);
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.85rem;
        line-height: 1.4;
        text-align: left;
      }

      .info-popover p {
        color: rgba(255, 255, 255, 0.85);
      }

      .info-popover .grade-bar-demo {
        display: flex;
        align-items: flex-end;
        gap: 0.55rem;
        margin-top: 0.2rem;
      }

      .info-popover .grade-bar-demo-bar {
        position: relative;
        --grade-value: 10;
        width: 0.65rem;
        height: calc(0.8rem + var(--grade-value) * 0.08rem);
        border-radius: 0.35rem 0.35rem 0 0;
        background: linear-gradient(180deg, rgba(126, 217, 87, 0.9), rgba(126, 217, 87, 0.35));
        border: 1px solid rgba(126, 217, 87, 0.9);
      }

      .info-popover .grade-bar-demo-bar::after {
        content: attr(data-grade);
        position: absolute;
        top: calc(100% + 0.25rem);
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.65rem;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.85);
      }

      .nav-links {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .nav-links a {
        padding: 0.55rem 0.95rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.18);
        color: #0c1905;
        font-size: 0.85rem;
        font-weight: 600;
        text-decoration: none;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background-image: linear-gradient(135deg, rgba(255, 255, 255, 0.85), rgba(255, 255, 255, 0.45));
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .nav-links a:hover,
      .nav-links a:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 10px 22px rgba(255, 255, 255, 0.25);
        outline: none;
      }

      .sign-out {
        border: 1px solid rgba(255, 255, 255, 0.35);
        border-radius: 999px;
        padding: 0.6rem 1.25rem;
        font-size: 0.9rem;
        font-weight: 700;
        cursor: pointer;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.22), rgba(255, 255, 255, 0.08));
        color: #fff;
        backdrop-filter: blur(6px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .sign-out:hover,
      .sign-out:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
        outline: none;
      }

      .route-tooltip {
        --tooltip-accent: #7ed957;
        --tooltip-accent-rgb: 126, 217, 87;
        --tooltip-accent-soft: rgba(126, 217, 87, 0.18);
        --tooltip-accent-strong: rgba(126, 217, 87, 0.85);
        --tooltip-on-accent: #000;
        --tooltip-foreground: #fff;
        --tooltip-soft-foreground: #000;
        --tooltip-muted-foreground: #d1d5db;
        --tooltip-surface: #0e150f;
        --tooltip-border-color: #7ed957;
        --tooltip-grade-size: 7.5rem;
        position: fixed;
        pointer-events: none;
        color: var(--tooltip-foreground, #fff);
        padding: 0.75rem 1rem;
        padding-right: calc(1rem + var(--tooltip-grade-size, 7.5rem) * 0.7);
        border-radius: 0.75rem;
        font-size: 0.85rem;
        line-height: 1.4;
        max-width: min(280px, 80vw);
        z-index: 6;
        opacity: 0;
        transform: translate(-50%, -12px);
        transition: opacity 0.12s ease, transform 0.12s ease;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        overflow: visible;
        background-color: var(--tooltip-surface, #0e150f);
        background: var(--tooltip-surface, #0e150f);
        border: 1px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.45);
      }

      .route-tooltip.pinned {
        pointer-events: auto;
      }

      .route-tooltip.visible {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      .route-tooltip .tooltip-title {
        display: block;
        font-size: 0.95rem;
        font-weight: 600;
      }

      .route-tooltip .tooltip-lines {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        white-space: pre-line;
      }

      .route-tooltip .tooltip-line {
        display: block;
      }

      .route-tooltip .tooltip-grade-cluster {
        position: absolute;
        top: 0;
        right: 0;
        transform: translate(50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.55rem;
        min-width: var(--tooltip-grade-size, 7.5rem);
        z-index: 1;
      }

      .route-tooltip .tooltip-grade-badge {
        width: var(--tooltip-grade-size, 7.5rem);
        height: var(--tooltip-grade-size, 7.5rem);
        border-radius: 50%;
        border: var(--tooltip-grade-stroke-width, 2px) solid var(--tooltip-accent, #7ed957);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: calc(var(--tooltip-grade-size, 7.5rem) * 0.32);
        line-height: 1;
        color: var(--tooltip-on-accent, #000);
        background: rgb(var(--tooltip-accent-rgb, 126, 217, 87));
        pointer-events: none;
        overflow: hidden;
      }

      .route-tooltip .tooltip-actions {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        margin-top: 0.5rem;
        width: 100%;
        pointer-events: auto;
      }

      .route-tooltip .tooltip-action-button {
        width: 100%;
        border-radius: 999px;
        padding: 0.6rem 0.9rem;
        font-size: 0.82rem;
        font-weight: 600;
        border: 2px solid var(--tooltip-border-color, var(--tooltip-accent, #7ed957));
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
        text-align: center;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease,
          color 0.15s ease, border-color 0.15s ease;
      }

      .route-tooltip .tooltip-action-button:hover,
      .route-tooltip .tooltip-action-button:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        outline: none;
      }

      .route-tooltip .tooltip-action-button.is-quiet {
        background: var(--tooltip-surface, #0e150f);
        color: var(--tooltip-foreground, #fff);
      }

      .route-tooltip .tooltip-action-button.is-quiet:hover,
      .route-tooltip .tooltip-action-button.is-quiet:focus-visible {
        border-color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .tooltip-action-button[aria-pressed='true'] {
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      }

      .route-tooltip .ascend-toggle[aria-pressed='true'] {
        background: var(--tooltip-on-accent, #000);
        color: var(--tooltip-accent, #7ed957);
      }

      .route-tooltip .focus-toggle {
        text-align: center;
      }

      .route-tooltip .focus-toggle[aria-pressed='true'] {
        background: var(--tooltip-accent, #7ed957);
        color: var(--tooltip-on-accent, #000);
      }

      .route-tooltip .tooltip-grade-value {
        position: relative;
        z-index: 1;
      }

      .route-tooltip .tooltip-grade-badge.ascended {
        box-shadow: 0 0 0 0.35rem rgba(var(--tooltip-accent-rgb, 126, 217, 87), 0.35);
      }

      .grade-section {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        margin-top: 0.75rem;
      }

      .grade-form {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .grade-form label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.8rem;
        font-weight: 600;
      }

      .grade-form input[type='number'] {
        border-radius: 0.65rem;
        border: 1px solid #fff;
        background: #fff;
        color: #111;
        padding: 0.45rem 0.6rem;
        font-size: 0.85rem;
      }

      .grade-form input[type='number']:disabled {
        cursor: not-allowed;
      }

      .grade-note {
        font-size: 0.75rem;
        color: var(--tooltip-foreground, #fff);
      }

    </style>
  </head>
  <body>
    <div id="authOverlay" class="auth-overlay" role="dialog" aria-modal="true" aria-labelledby="authTitle">
      <form id="authForm" class="auth-card">
        <h1 id="authTitle">Sign in to continue</h1>
        <label class="auth-field">
          <span>Username</span>
          <input id="authUsername" type="text" name="username" autocomplete="username" required />
        </label>
        <label class="auth-field">
          <span>Password</span>
          <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="6" required />
        </label>
        <p id="authError" class="auth-error" role="alert" aria-live="assertive"></p>
        <button type="submit" class="auth-submit">Sign In</button>
        <p class="auth-switch">
          <span id="authSwitchLabel">Don't have an account?</span>
          <button type="button" id="toggleAuthMode">Create one</button>
        </p>
      </form>
    </div>
    <div id="appContent" class="app hidden" aria-live="polite">
      <header class="app-header">
        <button id="locationButton" class="location-button" type="button" aria-haspopup="dialog">
          Select wall
        </button>
        <nav id="navLinks" class="nav-links" aria-label="Available pages">
          <a id="setterLink" class="hidden" href="setter.html">Setter Tools</a>
        </nav>
        <div class="info-wrapper">
          <button
            id="infoButton"
            class="info-button"
            type="button"
            aria-label="Learn about Ascend"
            aria-haspopup="dialog"
            aria-expanded="false"
            aria-controls="infoPopover"
          >
            i
          </button>
          <div
            id="infoPopover"
            class="info-popover hidden"
            role="dialog"
            aria-modal="false"
            aria-hidden="true"
            aria-label="About Ascend"
          >
            <p>Track which climbs you have completed.</p>
            <p>
              Grade bars grow taller for harder climbs. Here's how grades compare:
            </p>
            <div class="grade-bar-demo" aria-hidden="true">
              <div class="grade-bar-demo-bar" data-grade="7" style="--grade-value: 7"></div>
              <div class="grade-bar-demo-bar" data-grade="13" style="--grade-value: 13"></div>
              <div class="grade-bar-demo-bar" data-grade="25" style="--grade-value: 25"></div>
            </div>
            <p class="sr-only">Example grade bars: grade 7 is shortest, grade 13 is taller, and grade 25 is tallest.</p>
          </div>
        </div>
        <button id="signOutButton" class="sign-out">Sign out</button>
      </header>
      <div class="canvas-utility-buttons" aria-label="Canvas controls">
        <button id="resetZoomButton" type="button">Reset zoom</button>
      </div>
      <div class="canvas-container">
        <canvas id="previewCanvas" aria-hidden="true"></canvas>
      </div>
    </div>
    <div
      id="routeTooltip"
      class="route-tooltip"
      role="status"
      aria-live="polite"
      aria-hidden="true"
    ></div>
    <div
      id="locationModal"
      class="location-modal hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="locationModalTitle"
    >
      <div class="location-modal-content">
        <div class="location-modal-header">
          <h2 id="locationModalTitle" class="location-modal-title">Select a wall</h2>
          <button id="locationModalClose" class="location-modal-close" type="button" aria-label="Close wall selector">
            ×
          </button>
        </div>
        <div id="locationOptions" class="location-options" role="listbox"></div>
      </div>
    </div>
    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
        updateProfile,
        deleteUser,
        getIdTokenResult,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        serverTimestamp,
        collection,
        getDocs,
        query,
        limit,
        where,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
      import { firebaseConfig } from './config.js';

      const firebaseApp = initializeApp(firebaseConfig);
      const auth = getAuth(firebaseApp);

      const db = getFirestore(firebaseApp);

      const authOverlay = document.getElementById('authOverlay');
      const appContent = document.getElementById('appContent');
      const authForm = document.getElementById('authForm');
      const authUsername = document.getElementById('authUsername');
      const authPassword = document.getElementById('authPassword');
      const authError = document.getElementById('authError');
      const authTitle = document.getElementById('authTitle');
      const authSwitchLabel = document.getElementById('authSwitchLabel');
      const toggleAuthModeButton = document.getElementById('toggleAuthMode');
      const signOutButton = document.getElementById('signOutButton');
      const setterLink = document.getElementById('setterLink');
      const setterLinkBaseHref = setterLink?.getAttribute('href') || 'setter.html';
      const tooltip = document.getElementById('routeTooltip');
      const infoButton = document.getElementById('infoButton');
      const infoPopover = document.getElementById('infoPopover');
      const locationButton = document.getElementById('locationButton');
      const locationModal = document.getElementById('locationModal');
      const locationOptions = document.getElementById('locationOptions');
      const locationModalClose = document.getElementById('locationModalClose');
      const resetZoomButton = document.getElementById('resetZoomButton');

      const LOCATIONS = [
        { key: 'new-wall', name: 'New Wall', image: './location/New Wall.jpg' },
        { key: 'old-wall', name: 'Old Wall', image: './location/Old Wall.jpg' },
      ];

      const LOCATION_STORAGE_KEY = 'ascend.selectedWall';
      const WALL_QUERY_PARAM = 'wall';

      const PATH_TYPE_BREZER = 'brezer';
      const PATH_TYPE_POINT = 'point';
      const PATH_TYPE_RECTANGLE = 'rectangle';
      const DEFAULT_PATH_TYPE = PATH_TYPE_BREZER;
      const MIN_POINT_DIAMETER = 12;
      const MAX_POINT_DIAMETER = 160;
      const DEFAULT_POINT_DIAMETER = 48;
      const MIN_RECTANGLE_SIZE = 12;
      const MAX_RECTANGLE_SIZE = 200;
      const DEFAULT_RECTANGLE_WIDTH = 80;
      const DEFAULT_RECTANGLE_HEIGHT = 60;
      const MIN_GRADE_VALUE = 5;
      const MAX_GRADE_VALUE = 30;
      const MIN_GRADE_BAR_BASE_HEIGHT = 0;
      const MAX_GRADE_BAR_HEIGHT = 1000;
      const DEFAULT_GRADE_BAR_BASE_HEIGHT = 40;
      const DEFAULT_GRADE_BAR_MAX_HEIGHT = 220;
      const MIN_GRADE_BAR_WIDTH = 4;
      const MAX_GRADE_BAR_WIDTH = 160;
      const DEFAULT_GRADE_BAR_WIDTH = 24;
      const DEFAULT_GRADE_BAR_TRANSPARENCY = 0.85;
      const MIN_UNFOCUSED_TRANSPARENCY = 0;
      const MAX_UNFOCUSED_TRANSPARENCY = 1;
      const DEFAULT_UNFOCUSED_TRANSPARENCY = 0.25;
      const WALL_COLLECTION = 'walls';

      function normalizePathType(value) {
        if (typeof value === 'string') {
          const normalized = value.trim().toLowerCase();
          if (normalized === PATH_TYPE_POINT) {
            return PATH_TYPE_POINT;
          }
          if (normalized === PATH_TYPE_RECTANGLE) {
            return PATH_TYPE_RECTANGLE;
          }
        }
        return DEFAULT_PATH_TYPE;
      }

      function normalizePointDiameter(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_POINT_DIAMETER;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_POINT_DIAMETER),
          MAX_POINT_DIAMETER,
        );
        return clamped;
      }

      function normalizeRectangleSize(value, fallback = DEFAULT_RECTANGLE_WIDTH) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallback;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_RECTANGLE_SIZE),
          MAX_RECTANGLE_SIZE,
        );
        return clamped;
      }

      function normalizeGradeBarHeight(value, fallback) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return fallback;
        }
        const clamped = Math.min(
          Math.max(numeric, MIN_GRADE_BAR_BASE_HEIGHT),
          MAX_GRADE_BAR_HEIGHT,
        );
        return Math.round(clamped);
      }

      function normalizeGradeBarWidth(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_WIDTH;
        }
        const clamped = Math.min(
          Math.max(Math.round(numeric), MIN_GRADE_BAR_WIDTH),
          MAX_GRADE_BAR_WIDTH,
        );
        return clamped;
      }

      function normalizeGradeBarTransparency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_GRADE_BAR_TRANSPARENCY;
        }
        const clamped = Math.min(Math.max(numeric, 0), 1);
        return Math.round(clamped * 1000) / 1000;
      }

      function normalizeUnfocusedTransparency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_UNFOCUSED_TRANSPARENCY;
        }
        const clamped = Math.min(
          Math.max(numeric, MIN_UNFOCUSED_TRANSPARENCY),
          MAX_UNFOCUSED_TRANSPARENCY,
        );
        return Math.round(clamped * 1000) / 1000;
      }

      function normalizeWallSettings(raw = {}) {
        if (!raw || typeof raw !== 'object') {
          return {
            pointDiameter: DEFAULT_POINT_DIAMETER,
            rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
            rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
            gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
            gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
            gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
            gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
            unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
          };
        }

        const pointDiameter = normalizePointDiameter(raw.pointDiameter);
        const rectangleWidth = normalizeRectangleSize(
          raw.rectangleWidth,
          DEFAULT_RECTANGLE_WIDTH,
        );
        const rectangleHeight = normalizeRectangleSize(
          raw.rectangleHeight,
          DEFAULT_RECTANGLE_HEIGHT,
        );
        const gradeBarBaseHeight = normalizeGradeBarHeight(
          raw.gradeBarBaseHeight,
          DEFAULT_GRADE_BAR_BASE_HEIGHT,
        );
        const gradeBarMaxHeight = Math.max(
          gradeBarBaseHeight,
          normalizeGradeBarHeight(raw.gradeBarMaxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
        );
        const gradeBarWidth = normalizeGradeBarWidth(raw.gradeBarWidth);
        const gradeBarTransparency = normalizeGradeBarTransparency(
          raw.gradeBarTransparency ?? raw.transparency,
        );
        const unfocusedTransparency = normalizeUnfocusedTransparency(
          raw.unfocusedTransparency ?? raw.unfocused_transparency,
        );

        return {
          pointDiameter,
          rectangleWidth,
          rectangleHeight,
          gradeBarBaseHeight,
          gradeBarMaxHeight,
          gradeBarWidth,
          gradeBarTransparency,
          unfocusedTransparency,
        };
      }

      const wallSettingsCache = new Map();

      const normalizeLocationName = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      const normalizeWallKey = (value) => normalizeLocationName(value);

      function resolveWallSettings(locationKey, fallback = null) {
        const key = normalizeWallKey(locationKey);
        if (key) {
          const cached = wallSettingsCache.get(key);
          if (cached) {
            return { ...cached };
          }
        }

        if (fallback) {
          const normalized = normalizeWallSettings(fallback);
          if (key) {
            wallSettingsCache.set(key, normalized);
          }
          return normalized;
        }

        return {
          pointDiameter: DEFAULT_POINT_DIAMETER,
          rectangleWidth: DEFAULT_RECTANGLE_WIDTH,
          rectangleHeight: DEFAULT_RECTANGLE_HEIGHT,
          gradeBarBaseHeight: DEFAULT_GRADE_BAR_BASE_HEIGHT,
          gradeBarMaxHeight: DEFAULT_GRADE_BAR_MAX_HEIGHT,
          gradeBarWidth: DEFAULT_GRADE_BAR_WIDTH,
          gradeBarTransparency: DEFAULT_GRADE_BAR_TRANSPARENCY,
          unfocusedTransparency: DEFAULT_UNFOCUSED_TRANSPARENCY,
        };
      }

      const findLocationByKey = (key) => LOCATIONS.find((location) => location.key === key);

      const findLocationByName = (name) => {
        const normalized = normalizeLocationName(name);
        return (
          LOCATIONS.find((location) => normalizeLocationName(location.name) === normalized) ||
          null
        );
      };

      function buildWallAwareHref(baseHref, wallKey) {
        const normalizedKey = normalizeWallKey(wallKey);
        if (typeof baseHref !== 'string' || !baseHref) {
          return '';
        }

        try {
          const url = new URL(baseHref, window.location.origin);
          if (normalizedKey) {
            url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
          } else {
            url.searchParams.delete(WALL_QUERY_PARAM);
          }
          url.hash = '';
          const relativePath = `${url.pathname.replace(/^\//, '')}${url.search}`;
          return relativePath || baseHref;
        } catch (error) {
          if (!normalizedKey) {
            return baseHref;
          }

          const separator = baseHref.includes('?') ? '&' : '?';
          return `${baseHref}${separator}${encodeURIComponent(WALL_QUERY_PARAM)}=${encodeURIComponent(normalizedKey)}`;
        }
      }

      function getWallKeyFromQuery() {
        try {
          const params = new URLSearchParams(window.location.search);
          const raw = params.get(WALL_QUERY_PARAM);
          return normalizeWallKey(raw);
        } catch (error) {
          console.warn('Unable to read wall from query string:', error);
          return '';
        }
      }

      function updateWallQueryParam(wallKey) {
        try {
          const normalizedKey = normalizeWallKey(wallKey);
          const url = new URL(window.location.href);
          if (normalizedKey) {
            url.searchParams.set(WALL_QUERY_PARAM, normalizedKey);
          } else {
            url.searchParams.delete(WALL_QUERY_PARAM);
          }
          url.hash = '';
          const next = url.toString();
          if (next !== window.location.href) {
            window.history.replaceState({}, '', next);
          }
        } catch (error) {
          console.warn('Unable to update wall query parameter:', error);
        }
      }

      function persistSelectedWall(wallKey) {
        const normalizedKey = normalizeWallKey(wallKey);
        try {
          if (normalizedKey) {
            window.localStorage?.setItem(LOCATION_STORAGE_KEY, normalizedKey);
          } else {
            window.localStorage?.removeItem(LOCATION_STORAGE_KEY);
          }
        } catch (error) {
          console.warn('Unable to persist location preference:', error);
        }
      }

      function upsertLocation({ key = '', name = '', image = '', fallbackName = '' } = {}) {
        const trimmedName = typeof name === 'string' && name.trim() ? name.trim() : '';
        const fallback =
          trimmedName || (typeof fallbackName === 'string' && fallbackName.trim() ? fallbackName.trim() : '');
        const keySource = typeof key === 'string' && key.trim() ? key.trim() : fallback;
        const normalizedKey = normalizeWallKey(keySource);
        const displayName = fallback;
        if (!normalizedKey || !displayName) {
          return { entry: null, changed: false };
        }

        const normalizedImage = typeof image === 'string' ? image.trim() : '';
        const existingIndex = LOCATIONS.findIndex((location) => {
          if (!location) {
            return false;
          }
          if (location.key === normalizedKey) {
            return true;
          }
          return normalizeLocationName(location.name) === normalizeLocationName(displayName);
        });

        if (existingIndex >= 0) {
          const existing = LOCATIONS[existingIndex];
          const needsUpdate =
            existing.key !== normalizedKey || existing.name !== displayName || existing.image !== normalizedImage;

          if (!needsUpdate) {
            return { entry: existing, changed: false };
          }

          const updated = { ...existing, key: normalizedKey, name: displayName, image: normalizedImage };
          LOCATIONS[existingIndex] = updated;
          return { entry: updated, changed: true };
        }

        const created = { key: normalizedKey, name: displayName, image: normalizedImage };
        LOCATIONS.push(created);
        return { entry: created, changed: true };
      }

      function synchronizeCurrentLocationReference() {
        if (!currentLocation) {
          return;
        }

        const normalizedKey = normalizeWallKey(currentLocation.key || currentLocation.name);
        const refreshed =
          (normalizedKey && findLocationByKey(normalizedKey)) ||
          findLocationByName(currentLocation.name);

        if (refreshed && refreshed !== currentLocation) {
          currentLocation = refreshed;
          updateLocationButtonLabel();
          updateLocationOptionsState();
          updateBackgroundForCurrentLocation();
          const refreshedKey = getCurrentLocationKey();
          if (refreshedKey) {
            persistSelectedWall(refreshedKey);
          }
          updateWallQueryParam(refreshedKey);
          updateSetterLinkHref();
        }
      }

      const DEFAULT_LOCATION = LOCATIONS[0];

      let currentLocation = DEFAULT_LOCATION;

      function getCurrentLocationKey() {
        return normalizeWallKey(currentLocation?.key || currentLocation?.name);
      }

      function updateSetterLinkHref() {
        if (!setterLink) {
          return;
        }

        const wallKey = getCurrentLocationKey();
        setterLink.href = buildWallAwareHref(setterLinkBaseHref, wallKey);
      }

      let backgroundReady = false;
      let backgroundImageSource = '';

      const backgroundImage = new Image();

      function updateLocationButtonLabel() {
        if (!locationButton) {
          return;
        }

        locationButton.textContent = currentLocation?.name || 'Select wall';
      }

      function updateLocationOptionsState() {
        if (!locationOptions) {
          return;
        }

        const buttons = locationOptions.querySelectorAll('[data-location-key]');
        buttons.forEach((button) => {
          const key = button?.dataset?.locationKey;
          if (key && currentLocation && key === currentLocation.key) {
            button.setAttribute('aria-current', 'true');
          } else {
            button.removeAttribute('aria-current');
          }
        });
      }

      function applyBodyBackground(imagePath) {
        if (!document.body) {
          return;
        }

        if (imagePath) {
          document.body.style.setProperty('--wall-background', `url('${imagePath}')`);
        } else {
          document.body.style.removeProperty('--wall-background');
        }
      }

      function updateBackgroundForCurrentLocation() {
        const imagePath = currentLocation?.image || '';
        applyBodyBackground(imagePath);

        if (imagePath && imagePath !== backgroundImageSource) {
          backgroundImageSource = imagePath;
          backgroundReady = false;
          backgroundImage.src = imagePath;
        } else if (!imagePath) {
          backgroundImageSource = '';
          backgroundReady = false;
        }
      }

      backgroundImage.onload = () => {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      };

      backgroundImage.onerror = () => {
        backgroundReady = false;
        resizeCanvas();
      };

      function closeLocationModal() {
        if (!locationModal) {
          return;
        }

        if (!locationModal.classList.contains('hidden')) {
          locationModal.classList.add('hidden');
          locationModal.setAttribute('aria-hidden', 'true');
          locationButton?.setAttribute('aria-expanded', 'false');
        }
      }

      function openLocationModal() {
        if (!locationModal) {
          return;
        }

        locationModal.classList.remove('hidden');
        locationModal.setAttribute('aria-hidden', 'false');
        locationButton?.setAttribute('aria-expanded', 'true');
        updateLocationOptionsState();
      }

      function handleLocationSelection(locationKey) {
        const location = findLocationByKey(locationKey);
        if (!location) {
          return;
        }

        const changed = !currentLocation || currentLocation.key !== location.key;
        currentLocation = location;
        updateLocationButtonLabel();
        updateLocationOptionsState();
        updateBackgroundForCurrentLocation();

        const nextLocationKey = getCurrentLocationKey();
        if (nextLocationKey) {
          persistSelectedWall(nextLocationKey);
        }
        updateWallQueryParam(nextLocationKey);
        updateSetterLinkHref();

        if (changed) {
          applyLocationFilter();
        }

        closeLocationModal();
      }

      function renderLocationOptions() {
        if (!locationOptions) {
          return;
        }

        locationOptions.replaceChildren();

        LOCATIONS.forEach((location) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'location-option';
          button.dataset.locationKey = location.key;
          button.setAttribute('role', 'option');

          const preview = document.createElement('div');
          preview.className = 'location-option-preview';
          preview.style.backgroundImage = `url('${location.image}')`;
          button.appendChild(preview);

          const label = document.createElement('span');
          label.className = 'location-option-label';
          label.textContent = location.name;
          button.appendChild(label);

          button.addEventListener('click', () => {
            handleLocationSelection(location.key);
          });

          locationOptions.appendChild(button);
        });

        updateLocationOptionsState();
      }

      const SYNTHETIC_EMAIL_DOMAIN = 'users.anuascend.local';
      const USERNAME_PATTERN = /^[a-z0-9_]{3,20}$/;

      const normalizeUsername = (value) => {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim().toLowerCase();
      };

      function cacheAuthenticatedUsername(username) {
        const normalized = normalizeUsername(username);
        authenticatedUsernameClaim = isValidUsername(normalized) ? normalized : '';
        return authenticatedUsernameClaim;
      }

      async function resolveAuthenticatedUsername(options = {}) {
        const { forceRefresh = false } = options;

        if (!currentUser) {
          authenticatedUsernameClaim = '';
          return isValidUsername(currentUsername) ? normalizeUsername(currentUsername) : '';
        }

        if (!forceRefresh) {
          const cachedClaim = normalizeUsername(authenticatedUsernameClaim);
          if (isValidUsername(cachedClaim)) {
            return cachedClaim;
          }
        }

        const fallbackUsername = isValidUsername(currentUsername)
          ? normalizeUsername(currentUsername)
          : '';

        try {
          const tokenResult = await getIdTokenResult(currentUser, forceRefresh);
          const claimUsername = normalizeUsername(tokenResult?.claims?.username);

          if (isValidUsername(claimUsername)) {
            return cacheAuthenticatedUsername(claimUsername);
          }
        } catch (error) {
          console.warn(
            forceRefresh
              ? 'Failed to refresh authenticated username claim:'
              : 'Failed to read authenticated username claim:',
            error,
          );
        }

        if (!forceRefresh) {
          return resolveAuthenticatedUsername({ forceRefresh: true });
        }

        if (fallbackUsername) {
          return cacheAuthenticatedUsername(fallbackUsername);
        }

        return '';
      }

      const buildSyntheticEmail = (username) => {
        const normalized = normalizeUsername(username);
        return normalized ? `${normalized}@${SYNTHETIC_EMAIL_DOMAIN}` : '';
      };

      const isValidUsername = (value) => USERNAME_PATTERN.test(normalizeUsername(value));

      const tooltipColorCanvas = document.createElement('canvas');
      const tooltipColorContext = tooltipColorCanvas.getContext('2d');

      function getTextColor(bgColor) {
        const context = document.createElement('canvas').getContext('2d');
        if (!context) {
          return '#fff';
        }

        context.fillStyle = '#000';
        context.fillStyle = bgColor;
        const values = context.fillStyle.match(/\d+/g);

        if (!values || values.length < 3) {
          return '#fff';
        }

        const [r, g, b] = values.map(Number);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        return luminance > 0.5 ? '#000' : '#fff';
      }

      function parseTooltipColor(color) {
        if (!tooltipColorContext || typeof color !== 'string') {
          return null;
        }

        let normalized;
        try {
          tooltipColorContext.fillStyle = '#000000';
          tooltipColorContext.fillStyle = color;
          normalized = tooltipColorContext.fillStyle;
        } catch (error) {
          return null;
        }

        if (typeof normalized !== 'string' || !normalized) {
          return null;
        }

        if (/^#[0-9a-f]{6}$/i.test(normalized)) {
          const r = parseInt(normalized.slice(1, 3), 16);
          const g = parseInt(normalized.slice(3, 5), 16);
          const b = parseInt(normalized.slice(5, 7), 16);
          return { r, g, b, hex: normalized };
        }

        const rgbaMatch = normalized
          .replace(/\s+/g, '')
          .match(/^rgba?\((\d+),(\d+),(\d+)(?:,(0|1|0?\.\d+))?\)$/i);

        if (rgbaMatch) {
          const [, r, g, b] = rgbaMatch;
          return {
            r: Number.parseInt(r, 10),
            g: Number.parseInt(g, 10),
            b: Number.parseInt(b, 10),
            hex: null,
          };
        }

        return null;
      }

      function deriveTooltipColorScheme(color) {
        const parsed = parseTooltipColor(color);

        if (!parsed) {
          return null;
        }

        const clamp = (value) => Math.max(0, Math.min(255, value));
        const r = clamp(parsed.r);
        const g = clamp(parsed.g);
        const b = clamp(parsed.b);
        const rgbString = `${r}, ${g}, ${b}`;
        const accent = parsed.hex ? parsed.hex : `rgb(${rgbString})`;
        const soft = `rgba(${rgbString}, 0.18)`;
        const strong = `rgba(${rgbString}, 0.85)`;
        const surfaceFactor = 0.22;
        const surfaceOffset = 18;
        const mixChannel = (channel) => clamp(Math.round(channel * surfaceFactor + surfaceOffset));
        const surface = `rgb(${mixChannel(r)}, ${mixChannel(g)}, ${mixChannel(b)})`;
        const onAccent = getTextColor(strong);
        const foreground = getTextColor(surface);
        const softForeground = foreground;
        const mutedForeground = foreground === '#000' ? '#333333' : '#d1d5db';

        return {
          accent,
          rgb: rgbString,
          soft,
          strong,
          onAccent,
          foreground,
          softForeground,
          mutedForeground,
          surface,
          border: accent,
        };
      }

      const FALLBACK_TOOLTIP_SCHEME = (() => {
        const defaultRgb = '126, 217, 87';
        const soft = 'rgba(126, 217, 87, 0.18)';
        const strong = 'rgba(126, 217, 87, 0.85)';
        const surface = 'rgb(43, 71, 47)';
        const foreground = getTextColor(surface);

        return {
          accent: '#7ed957',
          rgb: defaultRgb,
          soft,
          strong,
          onAccent: getTextColor(strong),
          foreground,
          softForeground: foreground,
          mutedForeground: foreground === '#000' ? '#333333' : '#d1d5db',
          surface,
          border: '#7ed957',
        };
      })();

      const DEFAULT_TOOLTIP_SCHEME =
        deriveTooltipColorScheme('#7ed957') ?? FALLBACK_TOOLTIP_SCHEME;

      function applyTooltipColorScheme(route) {
        if (!tooltip) {
          return;
        }

        const base = DEFAULT_TOOLTIP_SCHEME;
        const scheme = deriveTooltipColorScheme(route?.strokeColor) ?? base;

        const accent = scheme.accent ?? base.accent;
        const rgb = scheme.rgb ?? base.rgb;
        const soft = scheme.soft ?? base.soft;
        const strong = scheme.strong ?? base.strong;
        const onAccent = scheme.onAccent ?? base.onAccent;
        const foreground = scheme.foreground ?? base.foreground;
        const softForeground = scheme.softForeground ?? base.softForeground;
        const mutedForeground = scheme.mutedForeground ?? base.mutedForeground;
        const surface = scheme.surface ?? base.surface;
        const border = scheme.border ?? base.border ?? accent;

        tooltip.style.setProperty('--tooltip-accent', accent);
        tooltip.style.setProperty('--tooltip-accent-rgb', rgb);
        tooltip.style.setProperty('--tooltip-accent-soft', soft);
        tooltip.style.setProperty('--tooltip-accent-strong', strong);
        tooltip.style.setProperty('--tooltip-on-accent', onAccent);
        tooltip.style.setProperty('--tooltip-foreground', foreground);
        tooltip.style.setProperty('--tooltip-soft-foreground', softForeground);
        tooltip.style.setProperty('--tooltip-muted-foreground', mutedForeground);
        tooltip.style.setProperty('--tooltip-surface', surface);
        tooltip.style.setProperty('--tooltip-border-color', border);
      }

      function closeInfoPopover() {
        if (!infoPopover) {
          return;
        }

        if (!infoPopover.classList.contains('hidden')) {
          infoPopover.classList.add('hidden');
          infoPopover.setAttribute('aria-hidden', 'true');
          if (infoButton) {
            infoButton.setAttribute('aria-expanded', 'false');
          }
        }
      }

      function toggleInfoPopover() {
        if (!infoPopover || !infoButton) {
          return;
        }

        const isHidden = infoPopover.classList.contains('hidden');
        if (isHidden) {
          infoPopover.classList.remove('hidden');
          infoPopover.setAttribute('aria-hidden', 'false');
          infoButton.setAttribute('aria-expanded', 'true');
        } else {
          closeInfoPopover();
        }
      }

      if (infoButton && infoPopover) {
        infoButton.addEventListener('click', (event) => {
          event.stopPropagation();
          toggleInfoPopover();
        });

        infoPopover.addEventListener('click', (event) => {
          event.stopPropagation();
        });

        document.addEventListener('click', () => {
          closeInfoPopover();
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            closeInfoPopover();
          }
        });
      }

      renderLocationOptions();

      const wallKeyFromQuery = getWallKeyFromQuery();
      let initialLocation = wallKeyFromQuery
        ? findLocationByKey(wallKeyFromQuery) || findLocationByName(wallKeyFromQuery)
        : null;

      let storedLocationKey = null;
      if (!initialLocation) {
        try {
          storedLocationKey = window.localStorage?.getItem(LOCATION_STORAGE_KEY) || null;
        } catch (error) {
          console.warn('Unable to read location preference:', error);
        }

        if (storedLocationKey) {
          const normalizedStoredKey = normalizeWallKey(storedLocationKey);
          initialLocation =
            findLocationByKey(normalizedStoredKey) || findLocationByName(normalizedStoredKey);
        }
      }

      if (initialLocation) {
        currentLocation = initialLocation;
      }

      const currentLocationKey = getCurrentLocationKey();
      if (currentLocationKey) {
        persistSelectedWall(currentLocationKey);
      }
      updateWallQueryParam(currentLocationKey);
      updateSetterLinkHref();

      updateLocationButtonLabel();
      updateLocationOptionsState();
      if (locationButton) {
        locationButton.setAttribute('aria-expanded', 'false');
      }
      updateBackgroundForCurrentLocation();

      if (locationButton) {
        locationButton.addEventListener('click', (event) => {
          event.preventDefault();
          openLocationModal();
        });
      }

      if (locationModalClose) {
        locationModalClose.addEventListener('click', (event) => {
          event.preventDefault();
          closeLocationModal();
        });
      }

      if (locationModal) {
        locationModal.addEventListener('click', (event) => {
          if (event.target === locationModal) {
            closeLocationModal();
          }
        });
      }

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeLocationModal();
        }
      });

      let authMode = 'login';
      let currentUser = null;
      let currentUsername = '';
      let authenticatedUsernameClaim = '';
      
      function setAuthMode(mode) {
        authMode = mode;
        const isLogin = authMode === 'login';
        authTitle.textContent = isLogin ? 'Sign in to continue' : 'Create your account';
        authSwitchLabel.textContent = isLogin ? "Don't have an account?" : 'Already have an account?';
        toggleAuthModeButton.textContent = isLogin ? 'Create one' : 'Sign in';
        authForm.querySelector('.auth-submit').textContent = isLogin ? 'Sign In' : 'Create Account';
        authPassword.setAttribute('autocomplete', isLogin ? 'current-password' : 'new-password');
        authError.textContent = '';
      }

      toggleAuthModeButton.addEventListener('click', () => {
        setAuthMode(authMode === 'login' ? 'register' : 'login');
      });

      async function lookupUsernameByUid(uid) {
        if (!uid) {
          return '';
        }

        try {
          const snapshot = await getDocs(
            query(collection(db, 'usernames'), where('uid', '==', uid), limit(1)),
          );

          if (snapshot.empty) {
            return '';
          }

          const docSnap = snapshot.docs[0];
          const data = docSnap.data() || {};
          const fromField = normalizeUsername(data.username);
          const fromId = normalizeUsername(docSnap.id);
          return fromField || fromId;
        } catch (error) {
          console.error('Failed to look up username by UID:', error);
          return '';
        }
      }

      async function resolveUsernameForUser(user) {
        if (!user) {
          return '';
        }

        const displayName = normalizeUsername(user.displayName);
        if (isValidUsername(displayName)) {
          return displayName;
        }

        const mapped = await lookupUsernameByUid(user.uid);
        if (isValidUsername(mapped)) {
          if (!displayName) {
            try {
              await updateProfile(user, { displayName: mapped });
            } catch (error) {
              console.warn('Unable to synchronise display name with username:', error);
            }
          }
          return mapped;
        }

        const syntheticEmail = typeof user.email === 'string' ? user.email : '';
        if (syntheticEmail.endsWith(`@${SYNTHETIC_EMAIL_DOMAIN}`)) {
          const derived = normalizeUsername(
            syntheticEmail.slice(0, -(`@${SYNTHETIC_EMAIL_DOMAIN}`.length)),
          );
          if (isValidUsername(derived)) {
            return derived;
          }
        }

        return '';
      }

      authForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        authError.textContent = '';

        const rawUsername = authUsername.value;
        const normalizedUsername = normalizeUsername(rawUsername);
        const password = authPassword.value;

        if (!normalizedUsername) {
          authError.textContent = 'Enter your username to continue.';
          return;
        }

        if (!isValidUsername(normalizedUsername)) {
          authError.textContent =
            'Usernames must be 3-20 characters using only letters, numbers, or underscores.';
          return;
        }

        const syntheticEmail = buildSyntheticEmail(normalizedUsername);

        try {
          if (authMode === 'login') {
            await signInWithEmailAndPassword(auth, syntheticEmail, password);
            return;
          }

          const credentials = await createUserWithEmailAndPassword(auth, syntheticEmail, password);
          const { user } = credentials;

          try {
            await setDoc(doc(db, 'usernames', normalizedUsername), {
              uid: user.uid,
              username: normalizedUsername,
              createdAt: serverTimestamp(),
              updatedAt: serverTimestamp(),
            });
          } catch (error) {
            console.error('Failed to reserve username:', error);
            try {
              await deleteUser(user);
            } catch (cleanupError) {
              console.warn('Unable to clean up user after username failure:', cleanupError);
            }
            const usernameError = new Error('Username unavailable');
            usernameError.code = 'auth/username-unavailable';
            throw usernameError;
          }

          try {
            await updateProfile(user, { displayName: normalizedUsername });
          } catch (profileError) {
            console.warn('Failed to update display name:', profileError);
          }
        } catch (error) {
          let message = 'Unable to complete the request. Please try again.';

          switch (error?.code) {
            case 'auth/user-not-found':
            case 'auth/wrong-password':
              message = 'Invalid username or password.';
              break;
            case 'auth/email-already-in-use':
            case 'auth/username-unavailable':
            case 'permission-denied':
              message = 'That username is already taken. Choose another one.';
              break;
            case 'auth/invalid-email':
              message = 'Enter a valid username.';
              break;
            case 'auth/weak-password':
              message = 'Choose a stronger password (at least 6 characters).';
              break;
            default:
              if (error?.message) {
                message = error.message;
              }
          }

          authError.textContent = message;
        }
      });

      signOutButton.addEventListener('click', () => {
        signOut(auth).catch((error) => {
          console.error('Failed to sign out:', error);
        });
      });

      async function ensureUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return { role: 'default' };
        }

        const roleRef = doc(db, 'roles', user.uid);
        const existingSnap = await getDoc(roleRef);

        if (existingSnap.exists()) {
          const existingData = existingSnap.data() || {};
          const storedLowerRaw =
            typeof existingData.usernameLower === 'string'
              ? existingData.usernameLower
              : typeof existingData.username === 'string'
              ? existingData.username
              : '';
          let effectiveLower = normalizeUsername(storedLowerRaw);
          const trimmedRole =
            typeof existingData.role === 'string' ? existingData.role.trim() : 'default';
          const mergedData = {
            ...existingData,
            role: trimmedRole,
          };

          if (effectiveLower !== normalizedUsername || !existingData.username) {
            try {
              await setDoc(
                roleRef,
                {
                  username: normalizedUsername,
                  usernameLower: normalizedUsername,
                  updatedAt: serverTimestamp(),
                },
                { merge: true },
              );
              mergedData.username = normalizedUsername;
              mergedData.usernameLower = normalizedUsername;
              effectiveLower = normalizedUsername;
            } catch (error) {
              console.warn('Failed to synchronise username on role document:', error);
            }
          }

          if (effectiveLower !== normalizedUsername) {
            mergedData.role = 'default';
          }

          return mergedData;
        }

        let role = 'default';

        try {
          const snapshot = await getDocs(
            query(collection(db, 'roles'), where('role', '==', 'setter'), limit(1)),
          );
          if (snapshot.empty) {
            role = 'setter';
          }
        } catch (error) {
          console.warn('Unable to inspect existing roles:', error);
        }

        const roleData = {
          role,
          username: normalizedUsername,
          usernameLower: normalizedUsername,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        };

        await setDoc(roleRef, roleData, { merge: true });
        return roleData;
      }

      async function resolveUserRole(user, username) {
        if (!user) {
          return null;
        }

        const normalizedUsername = normalizeUsername(username);
        if (!normalizedUsername) {
          return 'default';
        }

        try {
          const ensuredRole = await ensureUserRole(user, normalizedUsername);
          return typeof ensuredRole?.role === 'string' ? ensuredRole.role.trim() : 'default';
        } catch (error) {
          console.error('Failed to fetch user role:', error);
          return 'default';
        }
      }

      function updateNavigationForRole(role) {
        updateSetterLinkHref();
        setterLink.classList.toggle('hidden', role !== 'setter');
      }

      onAuthStateChanged(auth, async (user) => {
        if (user) {
          authOverlay.classList.add('hidden');

          currentUser = user;

          const resolvedUsername = await resolveUsernameForUser(user);
          if (!isValidUsername(resolvedUsername)) {
            authError.textContent =
              'Unable to resolve your username. Please contact a setter for assistance.';
            await signOut(auth);
            return;
          }

          currentUsername = normalizeUsername(resolvedUsername);
          authenticatedUsernameClaim = '';
          const canonicalUsername = await resolveAuthenticatedUsername();
          if (isValidUsername(canonicalUsername)) {
            currentUsername = canonicalUsername;
          }

          const role = await resolveUserRole(user, currentUsername);

          updateNavigationForRole(role);
          appContent.classList.remove('hidden');
          await loadAscents({ userId: user.uid, username: currentUsername });
          await loadRoutes();
        } else {
          authOverlay.classList.remove('hidden');
          appContent.classList.add('hidden');
          setterLink.classList.add('hidden');
          authForm.reset();
          setAuthMode('login');
          routes = [];
          focusedRouteId = null;
          currentUser = null;
          currentUsername = '';
          authenticatedUsernameClaim = '';
          ascendedRoutes.clear();
          routeGrades.clear();
          routeMedianGrades = new Map();
          hideTooltip({ force: true });
          redraw();
        }
      });

      setAuthMode('login');

      const canvasContainer = document.querySelector('.canvas-container');
      const canvas = document.getElementById('previewCanvas');
      const ctx = canvas.getContext('2d');

      const DEFAULT_CANVAS_ASPECT_RATIO = 1536 / 1024;
      let canvasAspectRatio = DEFAULT_CANVAS_ASPECT_RATIO;
      let isHorizontalScrollEnabled = false;

      let allRoutes = [];
      let routes = [];
      let focusedRouteId = null;
      let gradeBarEntries = [];
      let queuedGradeBarOverlays = [];
      let activeRouteId = null;
      let pinnedRouteId = null;
      let pinnedPosition = null;
      const ascendedRoutes = new Set();
      const routeGrades = new Map();
      let userAscentDetails = new Map();
      let routeMedianGrades = new Map();

      function synchroniseAscentsWithRoutes(options = {}) {
        const { shouldRedraw = true } = options;
        ascendedRoutes.clear();
        routeGrades.clear();

        if (!Array.isArray(routes) || routes.length === 0) {
          if (shouldRedraw) {
            redraw();
          }
          return;
        }

        routes.forEach((route) => {
          if (!route?.id) {
            return;
          }

          const ascent = userAscentDetails.get(route.id);
          if (!ascent) {
            return;
          }

          if (typeof ascent.grade === 'number' && Number.isFinite(ascent.grade)) {
            routeGrades.set(route.id, ascent.grade);
          }

          if (ascent.ascended) {
            ascendedRoutes.add(route.id);
          }
        });

        if (shouldRedraw) {
          redraw();
        }
      }

      async function loadAscents({ userId, username }) {
        ascendedRoutes.clear();
        routeGrades.clear();
        userAscentDetails = new Map();

        const normalizedUserId = typeof userId === 'string' ? userId.trim() : '';
        const normalizedUsername = normalizeUsername(username);
        const hasValidUsername = isValidUsername(normalizedUsername);
        if (!normalizedUserId && !hasValidUsername) {
          return;
        }

        try {
          let ascentData = null;

          if (normalizedUserId) {
            const ascentRef = doc(db, 'ascents', normalizedUserId);
            const ascentSnap = await getDoc(ascentRef);
            if (ascentSnap.exists()) {
              ascentData = ascentSnap.data() ?? {};
            }

            if (!ascentData && hasValidUsername && normalizedUsername !== normalizedUserId) {
              const legacyRef = doc(db, 'ascents', normalizedUsername);
              const legacySnap = await getDoc(legacyRef);

              if (legacySnap.exists()) {
                ascentData = legacySnap.data() ?? {};

                try {
                  const migrationPayload = {
                    ...ascentData,
                    climber_uid: normalizedUserId,
                    updatedAt: serverTimestamp(),
                  };

                  if (hasValidUsername) {
                    migrationPayload.climber_username = normalizedUsername;
                  }

                  await setDoc(ascentRef, migrationPayload, { merge: true });
                } catch (migrationError) {
                  console.warn('Failed to migrate legacy ascent document to UID path:', migrationError);
                }
              }
            }
          }

          if (!ascentData && hasValidUsername && normalizedUsername !== normalizedUserId) {
            const ascentRef = doc(db, 'ascents', normalizedUsername);
            const ascentSnap = await getDoc(ascentRef);

            if (!ascentSnap.exists()) {
              return;
            }

            ascentData = ascentSnap.data() ?? {};
          }

          if (!ascentData) {
            return;
          }

          const routesData = ascentData.routes;

          if (routesData && typeof routesData === 'object') {
            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!routeId || !details) {
                return;
              }

              const gradeValue = normalizeGradeValue(details?.grade);
              const normalizedDate = normalizeDate(details?.date_ascended);
              const ascended = details?.ascended === true || Boolean(normalizedDate);

              const entry = {
                ascended,
                grade: gradeValue,
              };

              if (normalizedDate) {
                entry.dateAscended = normalizedDate;
              }

              userAscentDetails.set(routeId, entry);
            });

            synchroniseAscentsWithRoutes();
            return;
          }

          const singleRouteId = typeof ascentData.route_id === 'string' ? ascentData.route_id : null;
          if (singleRouteId) {
            userAscentDetails.set(singleRouteId, { ascended: true, grade: null });
            synchroniseAscentsWithRoutes();
            return;
          }
        } catch (error) {
          console.error('Failed to load ascents:', error);
        }

        synchroniseAscentsWithRoutes();
      }

      function normalizeDate(value) {
        if (!value) {
          return null;
        }

        if (typeof value === 'string') {
          const date = new Date(value);
          return Number.isNaN(date.getTime()) ? null : date.toISOString();
        }

        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }

        if (typeof value?.toDate === 'function') {
          const date = value.toDate();
          if (date instanceof Date && !Number.isNaN(date.getTime())) {
            return date.toISOString();
          }
          return null;
        }

        return null;
      }

      function formatDisplayDate(isoString) {
        if (!isoString) {
          return 'Unknown';
        }

        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return 'Unknown';
        }

        return date.toLocaleDateString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
        });
      }

      function normalizeGradeValue(value) {
        if (value === null || value === undefined) {
          return null;
        }

        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return null;
        }

        if (!Number.isInteger(numeric)) {
          return null;
        }

        if (numeric < MIN_GRADE_VALUE || numeric > MAX_GRADE_VALUE) {
          return null;
        }

        return numeric;
      }

      function formatGradeDisplay(value) {
        if (typeof value !== 'number' || !Number.isFinite(value)) {
          return '—';
        }

        return Number.isInteger(value) ? String(value) : value.toFixed(1);
      }

      function getUserGradeForRoute(routeId) {
        if (!routeId) {
          return null;
        }

        const stored = routeGrades.get(routeId);
        return typeof stored === 'number' && Number.isFinite(stored) ? stored : null;
      }

      function buildGradeControls(route) {
        if (!route || !route.id) {
          return null;
        }

        const container = document.createElement('div');
        container.className = 'grade-section';

        const gradeForm = document.createElement('form');
        gradeForm.className = 'grade-form';
        gradeForm.noValidate = true;

        const gradeLabel = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.textContent = `Your grade (${MIN_GRADE_VALUE}-${MAX_GRADE_VALUE})`;
        gradeLabel.appendChild(labelText);

        const gradeInput = document.createElement('input');
        gradeInput.type = 'number';
        gradeInput.min = String(MIN_GRADE_VALUE);
        gradeInput.max = String(MAX_GRADE_VALUE);
        gradeInput.step = '1';
        gradeInput.inputMode = 'numeric';
        const existingGrade = getUserGradeForRoute(route.id);
        gradeInput.value = existingGrade !== null ? String(existingGrade) : '';
        gradeInput.placeholder = '—';
        gradeLabel.appendChild(gradeInput);

        gradeForm.appendChild(gradeLabel);

        let isSubmittingGrade = false;
        let lastSubmittedValue = gradeInput.value.trim();

        const commitGradeFromInput = async () => {
          if (isSubmittingGrade) {
            return;
          }

          const rawValue = gradeInput.value.trim();
          if (rawValue === lastSubmittedValue) {
            return;
          }

          isSubmittingGrade = true;

          try {
            if (!rawValue) {
              gradeInput.setCustomValidity('');
              await applyUserRouteGrade(route, null);
              lastSubmittedValue = '';
              gradeInput.value = '';
              return;
            }

            const parsed = normalizeGradeValue(rawValue);
            if (parsed === null) {
              gradeInput.setCustomValidity(
                `Enter a whole number between ${MIN_GRADE_VALUE} and ${MAX_GRADE_VALUE}.`,
              );
              gradeInput.reportValidity();
              return;
            }

            gradeInput.setCustomValidity('');
            await applyUserRouteGrade(route, parsed);
            lastSubmittedValue = String(parsed);
            gradeInput.value = String(parsed);
          } finally {
            isSubmittingGrade = false;
          }
        };

        gradeInput.addEventListener('input', () => {
          gradeInput.setCustomValidity('');
        });

        gradeInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            gradeForm.requestSubmit();
          }
        });

        gradeInput.addEventListener('blur', () => {
          void commitGradeFromInput();
        });

        gradeForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          event.stopPropagation();
          await commitGradeFromInput();
        });

        container.appendChild(gradeForm);

        return container;
      }

      async function applyUserRouteGrade(route, gradeValue) {
        if (!route || !route.id) {
          return;
        }

        if (!currentUser) {
          console.warn('Unable to save grade: no authenticated user.');
          return;
        }

        const username = await resolveAuthenticatedUsername();
        if (!username) {
          console.warn('Unable to save grade: user username missing.');
          return;
        }

        const userId = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to save grade: user ID missing.');
          return;
        }

        const sanitizedGrade = gradeValue === null ? null : normalizeGradeValue(gradeValue);
        if (sanitizedGrade === null && gradeValue !== null) {
          console.warn('Unable to save grade: invalid grade value provided.');
          return;
        }

        const ascentRef = doc(db, 'ascents', userId);

        try {
          await setDoc(
            ascentRef,
            {
              climber_uid: userId,
              climber_username: username,
              updatedAt: serverTimestamp(),
              routes: {
                [route.id]: {
                  grade: sanitizedGrade,
                  route_id: route.id,
                  climber_uid: userId,
                  climber_username: username,
                },
              },
            },
            { merge: true },
          );

          const existingEntry = userAscentDetails.get(route.id);
          const isAscended = existingEntry?.ascended === true;

          if (sanitizedGrade === null) {
            routeGrades.delete(route.id);

            if (existingEntry) {
              userAscentDetails.set(route.id, { ...existingEntry, ascended: isAscended, grade: null });
            } else {
              userAscentDetails.delete(route.id);
            }
          } else {
            routeGrades.set(route.id, sanitizedGrade);
            const nextEntry = { ...(existingEntry || {}), ascended: isAscended, grade: sanitizedGrade };
            userAscentDetails.set(route.id, nextEntry);
          }

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          await refreshMedianGrades();
        } catch (error) {
          console.error('Failed to update route grade:', error);
        }
      }

      async function fetchMedianGrades() {
        const medianMap = new Map();

        try {
          const snapshot = await getDocs(collection(db, 'ascents'));
          const gradeBuckets = new Map();

          snapshot.forEach((docSnap) => {
            const data = docSnap.data() ?? {};
            const routesData = data.routes;

            if (!routesData || typeof routesData !== 'object') {
              return;
            }

            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!details) {
                return;
              }

              const grade = normalizeGradeValue(details.grade);
              if (grade === null) {
                return;
              }

              if (!gradeBuckets.has(routeId)) {
                gradeBuckets.set(routeId, []);
              }

              gradeBuckets.get(routeId).push(grade);
            });
          });

          gradeBuckets.forEach((grades, routeId) => {
            if (!Array.isArray(grades) || grades.length === 0) {
              return;
            }

            grades.sort((a, b) => a - b);
            const mid = Math.floor(grades.length / 2);

            if (grades.length % 2 === 0) {
              medianMap.set(routeId, (grades[mid - 1] + grades[mid]) / 2);
            } else {
              medianMap.set(routeId, grades[mid]);
            }
          });
        } catch (error) {
          console.error('Failed to load route grades:', error);
        }

        return medianMap;
      }

      async function refreshMedianGrades() {
        routeMedianGrades = await fetchMedianGrades();

        if (Array.isArray(allRoutes)) {
          allRoutes.forEach((route) => {
            const median = routeMedianGrades.get(route.id);
            route.medianGrade = typeof median === 'number' && Number.isFinite(median) ? median : null;
          });
        }

        redraw();
      }

      function updateTooltipContent(route) {
        if (!tooltip) {
          return;
        }

        applyTooltipColorScheme(route);

        const fragment = document.createDocumentFragment();
        const ariaLines = [];

        const displayTitle = (route.title || route.id || '').trim();
        if (displayTitle) {
          const titleLine = document.createElement('strong');
          titleLine.className = 'tooltip-title';
          titleLine.textContent = displayTitle;
          fragment.appendChild(titleLine);
          ariaLines.push(displayTitle);
        }

        const medianGrade =
          route && typeof route.medianGrade === 'number' && Number.isFinite(route.medianGrade)
            ? route.medianGrade
            : null;
        const gradeDisplay = formatGradeDisplay(medianGrade);
        const gradeBadge = document.createElement('div');
        gradeBadge.className = 'tooltip-grade-badge';
        gradeBadge.setAttribute('aria-hidden', 'true');
        gradeBadge.setAttribute('data-grade', gradeDisplay);
        const gradeValue = document.createElement('span');
        gradeValue.className = 'tooltip-grade-value';
        gradeValue.textContent = gradeDisplay;
        gradeBadge.appendChild(gradeValue);
        const isAscended = Boolean(route && ascendedRoutes.has(route.id));
        if (isAscended) {
          gradeBadge.classList.add('ascended');
        }
        const gradeStrokeWidth = Math.max(2, Math.round(calculateRouteStrokeWidth(route)) || 2);
        gradeBadge.style.setProperty('--tooltip-grade-stroke-width', `${gradeStrokeWidth}px`);
        tooltip.style.setProperty('--tooltip-grade-stroke-width', `${gradeStrokeWidth}px`);
        const gradeCluster = document.createElement('div');
        gradeCluster.className = 'tooltip-grade-cluster';
        gradeCluster.appendChild(gradeBadge);

        let actionsContainer = null;
        const ensureActionsContainer = () => {
          if (!actionsContainer) {
            actionsContainer = document.createElement('div');
            actionsContainer.className = 'tooltip-actions';
          }
          return actionsContainer;
        };

        if (currentUser) {
          const actionButton = document.createElement('button');
          actionButton.type = 'button';
          actionButton.className = 'tooltip-action-button ascend-toggle';
          actionButton.setAttribute('aria-pressed', isAscended ? 'true' : 'false');
          actionButton.textContent = isAscended ? 'Ascended' : 'Not ascended';
          actionButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            toggleRouteAscent(route);
          });
          ensureActionsContainer().appendChild(actionButton);
        }

        const focusButton = document.createElement('button');
        focusButton.type = 'button';
        focusButton.className = 'tooltip-action-button focus-toggle';
        const isFocused = focusedRouteId === route.id;
        if (!isFocused) {
          focusButton.classList.add('is-quiet');
        }
        focusButton.textContent = isFocused ? 'Show all routes' : 'Focus';
        focusButton.setAttribute('aria-pressed', isFocused ? 'true' : 'false');
        focusButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleRouteFocus(route);
        });
        ensureActionsContainer().appendChild(focusButton);

        fragment.appendChild(gradeCluster);
        if (actionsContainer) {
          fragment.appendChild(actionsContainer);
        }
        ariaLines.push(`Grade: ${gradeDisplay}`);
        ariaLines.push(isAscended ? 'Ascended' : 'Not ascended');

        const infoContainer = document.createElement('div');
        infoContainer.className = 'tooltip-lines';
        fragment.appendChild(infoContainer);

        const appendInfoLine = (text, className = '') => {
          if (!text) {
            return;
          }
          const line = document.createElement('div');
          line.className = className ? `tooltip-line ${className}` : 'tooltip-line';
          line.textContent = text;
          infoContainer.appendChild(line);
          ariaLines.push(text);
        };

        const setterValue = typeof route.setter === 'string' ? route.setter : '';
        appendInfoLine(`Setter: ${setterValue.trim() || 'Unknown'}`);

        const descriptionText =
          typeof route.description === 'string' ? route.description.trim() : '';
        appendInfoLine(descriptionText ? `Description: ${descriptionText}` : 'Description: —');

        appendInfoLine(`Date set: ${formatDisplayDate(route.date_set)}`);

        if (currentUser) {
          const gradeControls = buildGradeControls(route);
          if (gradeControls) {
            fragment.appendChild(gradeControls);
          }
        }

        tooltip.replaceChildren(fragment);

        if (ariaLines.length) {
          tooltip.setAttribute('aria-label', ariaLines.join('\n'));
        } else {
          tooltip.removeAttribute('aria-label');
        }
      }

      function positionTooltip() {
        if (!tooltip) {
          return null;
        }

        const tooltipWidth = tooltip.offsetWidth || 0;
        const tooltipHeight = tooltip.offsetHeight || 0;
        const halfWidth = tooltipWidth / 2;

        const minHorizontalMargin = 12;
        const minLeft = halfWidth + minHorizontalMargin;
        const maxLeft = window.innerWidth - halfWidth - minHorizontalMargin;
        const desiredLeft = window.innerWidth / 2;
        const clampedLeft = maxLeft < minLeft ? window.innerWidth / 2 : Math.min(maxLeft, Math.max(minLeft, desiredLeft));

        const minVerticalMargin = 12;
        const maxTop = window.innerHeight - tooltipHeight - minVerticalMargin;
        const safeMaxTop = maxTop < minVerticalMargin ? Math.max(minVerticalMargin, maxTop) : maxTop;
        const desiredTop = (window.innerHeight - tooltipHeight) / 2;
        const clampedTop = Math.min(safeMaxTop, Math.max(minVerticalMargin, desiredTop));

        tooltip.style.left = `${clampedLeft}px`;
        tooltip.style.top = `${clampedTop}px`;

        return { x: clampedLeft, y: clampedTop };
      }

      function showTooltip(route, clientX, clientY, options = {}) {
        if (!tooltip) {
          return;
        }

        const { pin = false } = options;

        if (route.id !== activeRouteId) {
          updateTooltipContent(route);
        }

        const position = positionTooltip();
        tooltip.classList.add('visible');
        tooltip.setAttribute('aria-hidden', 'false');
        activeRouteId = route.id;

        if (pin) {
          pinnedRouteId = route.id;
          pinnedPosition = position;
          tooltip.classList.add('pinned');
        } else {
          pinnedRouteId = null;
          pinnedPosition = null;
          tooltip.classList.remove('pinned');
        }
      }

      function hideTooltip(options = {}) {
        if (!tooltip) {
          return;
        }

        const { force = false } = options;

        if (!force && pinnedRouteId) {
          return;
        }

        tooltip.classList.remove('visible');
        tooltip.classList.remove('pinned');
        tooltip.setAttribute('aria-hidden', 'true');
        activeRouteId = null;
        pinnedRouteId = null;
        pinnedPosition = null;
      }

      function toggleRouteFocus(route) {
        if (!route || typeof route.id !== 'string') {
          return;
        }

        const shouldFocus = focusedRouteId !== route.id;
        focusedRouteId = shouldFocus ? route.id : null;

        redraw();

        if (tooltip && tooltip.classList.contains('visible') && activeRouteId === route.id) {
          updateTooltipContent(route);
        }
      }

      function getGradeBarEntryAtClientPoint(clientX, clientY) {
        if (!gradeBarEntries.length) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        for (let index = gradeBarEntries.length - 1; index >= 0; index -= 1) {
          const entry = gradeBarEntries[index];
          if (!entry) {
            continue;
          }

          const padding = Math.max(4, entry.width * 0.1);
          const left = entry.left - padding;
          const right = entry.right + padding;
          const top = entry.top - padding;
          const bottom = entry.bottom + padding;

          if (x >= left && x <= right && y >= top && y <= bottom) {
            return entry;
          }
        }

        return null;
      }

      function extractClientPoint(event) {
        if (typeof event.clientX === 'number' && typeof event.clientY === 'number') {
          return { x: event.clientX, y: event.clientY };
        }

        const touch = event.touches?.[0] ?? event.changedTouches?.[0];
        if (touch) {
          return { x: touch.clientX, y: touch.clientY };
        }

        return null;
      }

      function applyLocationFilter() {
        const desiredLocation = normalizeLocationName(currentLocation?.name);
        const fallbackLocation = normalizeLocationName(DEFAULT_LOCATION?.name);
        const targetLocation = desiredLocation || fallbackLocation;

        if (!targetLocation) {
          routes = [...allRoutes];
        } else {
          routes = allRoutes.filter((route) => {
            const routeLocation =
              typeof route?.locationKey === 'string'
                ? route.locationKey
                : normalizeLocationName(route?.location);
            return routeLocation === targetLocation;
          });
        }

        if (focusedRouteId) {
          const hasFocusedRoute = routes.some((route) => route.id === focusedRouteId);
          if (!hasFocusedRoute) {
            focusedRouteId = null;
            hideTooltip({ force: true });
          }
        }

        synchroniseAscentsWithRoutes({ shouldRedraw: false });
        redraw();
      }

      async function loadRoutes() {
        try {
          const [routesSnapshot, medianMap, wallSnapshot] = await Promise.all([
            getDocs(collection(db, 'routes')),
            fetchMedianGrades(),
            getDocs(collection(db, WALL_COLLECTION)),
          ]);

          routeMedianGrades = medianMap instanceof Map ? medianMap : new Map();

          wallSettingsCache.clear();
          let locationsChanged = false;
          wallSnapshot.forEach((docSnap) => {
            const data = docSnap.data();
            const settings = normalizeWallSettings(data);
            const normalizedId = normalizeWallKey(docSnap.id);
            const normalizedName = normalizeWallKey(data?.name);

            if (normalizedId) {
              wallSettingsCache.set(normalizedId, settings);
            }

            if (normalizedName) {
              wallSettingsCache.set(normalizedName, settings);
            }

            const { changed } = upsertLocation({
              key: typeof data?.key === 'string' ? data.key : docSnap.id,
              name: typeof data?.name === 'string' ? data.name : '',
              image: typeof data?.background_url === 'string' ? data.background_url : '',
              fallbackName: typeof data?.name === 'string' && data.name ? data.name : docSnap.id,
            });

            if (changed) {
              locationsChanged = true;
            }
          });

          if (locationsChanged) {
            renderLocationOptions();
            synchronizeCurrentLocationReference();
          }

          allRoutes = routesSnapshot.docs
            .map((docSnap) => {
              const data = docSnap.data();
              const normalizedPoints = Array.isArray(data.points)
                ? data.points
                    .map((point) => {
                      const x = Number(point?.x);
                      const y = Number(point?.y);
                      if (!Number.isFinite(x) || !Number.isFinite(y)) {
                        return null;
                      }
                      return { x, y };
                    })
                    .filter(Boolean)
                : [];

              const median = routeMedianGrades.get(docSnap.id);
              const medianGrade = typeof median === 'number' && Number.isFinite(median) ? median : null;
              const rawLocationValue = typeof data.location === 'string' ? data.location.trim() : '';
              const normalizedLocation =
                normalizeLocationName(rawLocationValue) || normalizeLocationName(DEFAULT_LOCATION?.name);
              const displayLocation = rawLocationValue || DEFAULT_LOCATION?.name || '';

              const fallbackWallSettings = {
                pointDiameter: data.pointDiameter,
                rectangleWidth: data.rectangleWidth,
                rectangleHeight: data.rectangleHeight,
                gradeBarBaseHeight: data.gradeBarBaseHeight,
                gradeBarMaxHeight: data.gradeBarMaxHeight,
                gradeBarWidth: data.gradeBarWidth,
                transparency: data.transparency ?? data.gradeBarTransparency,
                unfocusedTransparency: data.unfocusedTransparency,
              };
              const wallSettings = resolveWallSettings(normalizedLocation, fallbackWallSettings);

              return {
                id: docSnap.id,
                strokeColor: typeof data.strokeColor === 'string' ? data.strokeColor : '#ffde59',
                points: normalizedPoints,
                title: typeof data.title === 'string' ? data.title : '',
                setter: typeof data.setter === 'string' ? data.setter : '',
                description: typeof data.description === 'string' ? data.description : '',
                date_set: normalizeDate(data.date_set),
                date_removed: normalizeDate(data.date_removed),
                location: displayLocation,
                locationKey: normalizedLocation,
                medianGrade,
                pathType: normalizePathType(data.pathType),
                pointDiameter: wallSettings.pointDiameter,
                rectangleWidth: wallSettings.rectangleWidth,
                rectangleHeight: wallSettings.rectangleHeight,
                gradeBarBaseHeight: wallSettings.gradeBarBaseHeight,
                gradeBarMaxHeight: wallSettings.gradeBarMaxHeight,
                gradeBarWidth: wallSettings.gradeBarWidth,
                gradeBarTransparency: wallSettings.gradeBarTransparency,
                unfocusedTransparency: wallSettings.unfocusedTransparency,
              };
            })
            .sort((a, b) => {
              const nameA = (a.title || a.id).toLowerCase();
              const nameB = (b.title || b.id).toLowerCase();
              return nameA.localeCompare(nameB);
            });

          applyLocationFilter();
        } catch (error) {
          console.error('Failed to load routes:', error);
          allRoutes = [];
          routes = [];
          focusedRouteId = null;
          routeMedianGrades = new Map();
          redraw();
        }
      }

      async function toggleRouteAscent(route) {
        if (!currentUser) {
          return;
        }

        const username = await resolveAuthenticatedUsername();
        if (!username) {
          console.warn('Unable to mark ascent: user username missing.');
          return;
        }

        const userId = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
        if (!userId) {
          console.warn('Unable to mark ascent: user ID missing.');
          return;
        }

        const routeId = route?.id;
        if (!routeId) {
          console.warn('Unable to mark ascent: route ID missing.');
          return;
        }
        const ascentRef = doc(db, 'ascents', userId);
        const isAscended = ascendedRoutes.has(routeId);
        const previousEntry = userAscentDetails.get(routeId) || {};
        const persistedGrade =
          typeof previousEntry.grade === 'number' && Number.isFinite(previousEntry.grade)
            ? previousEntry.grade
            : getUserGradeForRoute(routeId);
        const normalizedGrade =
          typeof persistedGrade === 'number' && Number.isFinite(persistedGrade)
            ? persistedGrade
            : null;

        try {
          if (isAscended) {
            await setDoc(
              ascentRef,
              {
                climber_uid: userId,
                climber_username: username,
                updatedAt: serverTimestamp(),
                routes: {
                  [routeId]: {
                    route_id: routeId,
                    climber_uid: userId,
                    climber_username: username,
                    grade: normalizedGrade,
                    ascended: false,
                    date_ascended: null,
                  },
                },
              },
              { merge: true },
            );

            userAscentDetails.set(routeId, {
              ascended: false,
              grade: normalizedGrade,
            });
          } else {
            const now = new Date().toISOString();
            await setDoc(
              ascentRef,
              {
                climber_uid: userId,
                climber_username: username,
                updatedAt: serverTimestamp(),
                routes: {
                  [routeId]: {
                    route_id: routeId,
                    date_ascended: now,
                    climber_uid: userId,
                    climber_username: username,
                    grade: normalizedGrade,
                    ascended: true,
                  },
                },
              },
              { merge: true },
            );
            userAscentDetails.set(routeId, {
              ascended: true,
              grade: normalizedGrade,
              dateAscended: now,
            });
          }

          synchroniseAscentsWithRoutes({ shouldRedraw: false });
          updateTooltipContent(route);
          redraw();
        } catch (error) {
          console.error('Failed to update ascent:', error);
        }
      }

      function computeCanvasDimensions() {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const aspectRatio = Number.isFinite(canvasAspectRatio) && canvasAspectRatio > 0
          ? canvasAspectRatio
          : DEFAULT_CANVAS_ASPECT_RATIO;
        const enableScroll = viewportWidth <= 768 && viewportHeight > viewportWidth;

        if (enableScroll) {
          const height = viewportHeight;
          const width = Math.max(viewportWidth, Math.round(height * aspectRatio));
          return { width, height, enableScroll };
        }

        return {
          width: viewportWidth,
          height: viewportHeight,
          enableScroll: false,
        };
      }

      function resizeCanvas() {
        const { width, height, enableScroll } = computeCanvasDimensions();

        if (canvasContainer) {
          canvasContainer.classList.toggle('scrollable', enableScroll);
        }

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        if (canvasContainer) {
          if (enableScroll) {
            const maxScrollLeft = Math.max(0, width - window.innerWidth);
            if (!isHorizontalScrollEnabled) {
              canvasContainer.scrollLeft = Math.max(0, maxScrollLeft / 2);
            } else if (canvasContainer.scrollLeft > maxScrollLeft) {
              canvasContainer.scrollLeft = maxScrollLeft;
            }
          } else if (isHorizontalScrollEnabled) {
            canvasContainer.scrollLeft = 0;
          }
          canvasContainer.scrollTop = 0;
        }

        isHorizontalScrollEnabled = enableScroll;
        redraw();
      }

      function resetCanvasZoom() {
        if (!canvas || !canvasContainer) {
          return;
        }

        if (ctx && typeof ctx.setTransform === 'function') {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        resizeCanvas();

        if (canvasContainer.classList.contains('scrollable')) {
          const maxScrollLeft = Math.max(0, canvasContainer.scrollWidth - canvasContainer.clientWidth);
          canvasContainer.scrollLeft = Math.max(0, maxScrollLeft / 2);
        } else {
          canvasContainer.scrollLeft = 0;
        }

        canvasContainer.scrollTop = 0;
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (backgroundReady && backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        gradeBarEntries = [];
        queuedGradeBarOverlays = [];
        let isFocusActive = false;
        let resolvedFocusRoute = null;
        let focusedRoutePointKeys = null;

        if (focusedRouteId) {
          resolvedFocusRoute = routes.find((route) => route.id === focusedRouteId) || null;
          if (resolvedFocusRoute) {
            isFocusActive = true;
            focusedRoutePointKeys = buildNormalizedPointKeySet(resolvedFocusRoute.points);
          } else {
            focusedRouteId = null;
          }
        }

        const shouldPreservePinned = Boolean(
          pinnedRouteId &&
            pinnedPosition &&
            (!isFocusActive || pinnedRouteId === focusedRouteId),
        );
        const pinnedRoute = shouldPreservePinned
          ? routes.find((route) => route.id === pinnedRouteId)
          : null;

        if (!shouldPreservePinned) {
          hideTooltip();
        } else if (!pinnedRoute) {
          hideTooltip({ force: true });
        }

        const overlapGroups = buildOverlappingShapeGroups(routes);
        const routeAlphaMap = new Map();

        routes.forEach((route) => {
          if (!route || typeof route.id !== 'string') {
            return;
          }
          const isFocused = isFocusActive && route.id === focusedRouteId;
          const routeAlpha = isFocused
            ? 1
            : isFocusActive
              ? normalizeUnfocusedTransparency(route.unfocusedTransparency)
              : 1;
          routeAlphaMap.set(route.id, routeAlpha);
        });

        const handledOverlapKeys = new Set();

        routes.forEach((route) => {
          const isFocused = isFocusActive && route.id === focusedRouteId;
          const routeAlpha = routeAlphaMap.get(route?.id) ?? 1;
          const omitOverlaps = !isFocused && focusedRoutePointKeys?.size ? focusedRoutePointKeys : null;
          drawRoute(route, {
            alpha: routeAlpha,
            omitOverlappingPointKeys: omitOverlaps,
            overlapGroups,
            handledOverlapKeys,
            routeAlphaMap,
            isFocused,
          });
        });
        renderQueuedGradeBarOverlays();

        if (pinnedRoute && tooltip) {
          updateTooltipContent(pinnedRoute);
          tooltip.classList.add('visible');
          tooltip.classList.add('pinned');
          tooltip.setAttribute('aria-hidden', 'false');
          const updatedPosition = positionTooltip();
          if (updatedPosition) {
            pinnedPosition = updatedPosition;
          }
        }
      }

      function clamp(value, min, max) {
        if (!Number.isFinite(value)) {
          return min;
        }
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }

      function createNormalizedPointKey(x, y) {
        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          return null;
        }

        const clampedX = Math.min(Math.max(x, 0), 1);
        const clampedY = Math.min(Math.max(y, 0), 1);
        const scaledX = Math.round(clampedX * 10000);
        const scaledY = Math.round(clampedY * 10000);
        return `${scaledX}:${scaledY}`;
      }

      function buildNormalizedPointKeySet(points = []) {
        const keys = new Set();
        if (!Array.isArray(points) || !points.length) {
          return keys;
        }

        points.forEach((point) => {
          const x = Number(point?.x);
          const y = Number(point?.y);
          const key = createNormalizedPointKey(x, y);
          if (key) {
            keys.add(key);
          }
        });

        return keys;
      }

      function getRouteStrokeColor(route) {
        const rawColor = route?.strokeColor;
        if (typeof rawColor === 'string' && rawColor.trim()) {
          return rawColor;
        }
        return '#ffde59';
      }

      function createOverlapGroupKey(pathType, pointKey) {
        if (!pathType || !pointKey) {
          return null;
        }
        return `${pathType}::${pointKey}`;
      }

      function buildOverlappingShapeGroups(routeList = []) {
        const groups = new Map();

        if (!Array.isArray(routeList) || !routeList.length) {
          return groups;
        }

        routeList.forEach((route) => {
          if (!route) {
            return;
          }

          const pathType = normalizePathType(route.pathType);
          if (pathType !== PATH_TYPE_POINT && pathType !== PATH_TYPE_RECTANGLE) {
            return;
          }

          const points = Array.isArray(route.points) ? route.points : [];
          if (!points.length) {
            return;
          }

          const strokeColor = getRouteStrokeColor(route);
          const normalizedPointDiameter = normalizePointDiameter(route.pointDiameter);
          const normalizedRectangleWidth = normalizeRectangleSize(
            route.rectangleWidth,
            DEFAULT_RECTANGLE_WIDTH,
          );
          const normalizedRectangleHeight = normalizeRectangleSize(
            route.rectangleHeight,
            DEFAULT_RECTANGLE_HEIGHT,
          );

          points.forEach((point) => {
            const normalizedX = Number(point?.x);
            const normalizedY = Number(point?.y);
            const pointKey = createNormalizedPointKey(normalizedX, normalizedY);
            if (!pointKey) {
              return;
            }

            const groupKey = createOverlapGroupKey(pathType, pointKey);
            if (!groupKey) {
              return;
            }

            if (!groups.has(groupKey)) {
              groups.set(groupKey, {
                pathType,
                entries: [],
              });
            }

            const group = groups.get(groupKey);
            group.entries.push({
              routeId: route.id,
              color: strokeColor,
              pointDiameter: normalizedPointDiameter,
              rectangleWidth: normalizedRectangleWidth,
              rectangleHeight: normalizedRectangleHeight,
            });
          });
        });

        for (const [key, group] of groups) {
          if (!group || !Array.isArray(group.entries) || group.entries.length <= 1) {
            groups.delete(key);
          }
        }

        return groups;
      }

      function drawOverlappingPointGroup(ctx, center, entries) {
        if (!ctx || !center || !entries || entries.length <= 1) {
          return;
        }

        const total = entries.length;
        const radii = entries.map((entry) => Math.max(1, Number(entry.pointDiameter) / 2));
        const radius = Math.max(...radii, 4);
        const step = (Math.PI * 2) / total;
        const startAngle = -Math.PI / 2;

        ctx.save();
        ctx.setLineDash([]);
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';

        entries.forEach((entry, index) => {
          const strokeWidth = Math.max(2, Math.round(Number(entry.pointDiameter) / 10) || 2);
          const angleStart = startAngle + step * index;
          const angleEnd = angleStart + step;

          ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = entry.color || '#ffde59';
          ctx.beginPath();
          ctx.arc(center.x, center.y, radius, angleStart, angleEnd);
          ctx.stroke();
        });

        ctx.restore();
      }

      function drawOverlappingRectangleGroup(ctx, center, entries) {
        if (!ctx || !center || !entries || entries.length <= 1) {
          return;
        }

        const widths = entries.map((entry) => Math.max(1, Number(entry.rectangleWidth) || 0));
        const heights = entries.map((entry) => Math.max(1, Number(entry.rectangleHeight) || 0));
        const width = Math.max(...widths, 4);
        const height = Math.max(...heights, 4);
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const perimeter = 2 * (width + height);

        if (!Number.isFinite(perimeter) || perimeter <= 0) {
          return;
        }

        const segmentLength = perimeter / entries.length;
        const edges = [
          { length: width, startX: center.x - halfWidth, startY: center.y - halfHeight, dx: 1, dy: 0 },
          { length: height, startX: center.x + halfWidth, startY: center.y - halfHeight, dx: 0, dy: 1 },
          { length: width, startX: center.x + halfWidth, startY: center.y + halfHeight, dx: -1, dy: 0 },
          { length: height, startX: center.x - halfWidth, startY: center.y + halfHeight, dx: 0, dy: -1 },
        ];
        const edgeCount = edges.length;

        let offset = 0;

        entries.forEach((entry) => {
          let localOffset = offset % perimeter;
          if (localOffset < 0) {
            localOffset += perimeter;
          }

          let edgeIndex = 0;
          while (localOffset >= edges[edgeIndex].length && edgeIndex < edgeCount - 1) {
            localOffset -= edges[edgeIndex].length;
            edgeIndex += 1;
          }

          let currentX = edges[edgeIndex].startX + edges[edgeIndex].dx * localOffset;
          let currentY = edges[edgeIndex].startY + edges[edgeIndex].dy * localOffset;
          let remaining = segmentLength;

          ctx.save();
          ctx.setLineDash([]);
          ctx.lineCap = 'butt';
          ctx.lineJoin = 'miter';
          ctx.lineWidth = Math.max(
            2,
            Math.round(Math.max(Number(entry.rectangleWidth) || 0, Number(entry.rectangleHeight) || 0) / 10) || 2,
          );
          ctx.strokeStyle = entry.color || '#ffde59';
          ctx.globalAlpha = Number.isFinite(entry.alpha) ? entry.alpha : 1;

          while (remaining > 0) {
            const edge = edges[edgeIndex];
            const available = edge.length - localOffset;
            const step = Math.min(remaining, available);
            const nextOffset = localOffset + step;
            const nextX = edge.startX + edge.dx * nextOffset;
            const nextY = edge.startY + edge.dy * nextOffset;

            ctx.beginPath();
            ctx.moveTo(currentX, currentY);
            ctx.lineTo(nextX, nextY);
            ctx.stroke();

            remaining -= step;
            currentX = nextX;
            currentY = nextY;
            localOffset = 0;
            edgeIndex = (edgeIndex + 1) % edgeCount;
          }

          ctx.restore();

          offset += segmentLength;
          if (offset >= perimeter) {
            offset -= perimeter;
          }
        });
      }

      function calculateRouteStrokeWidth(route) {
        const pathType = normalizePathType(route?.pathType);
        if (pathType === PATH_TYPE_POINT) {
          const diameter = normalizePointDiameter(route?.pointDiameter);
          return Math.max(2, Math.round(diameter / 10));
        }
        if (pathType === PATH_TYPE_RECTANGLE) {
          const width = normalizeRectangleSize(route?.rectangleWidth, DEFAULT_RECTANGLE_WIDTH);
          const height = normalizeRectangleSize(route?.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT);
          return Math.max(2, Math.round(Math.max(width, height) / 10));
        }
        return 10;
      }

      function calculateAverageXFromCanvasPoints(routePoints = []) {
        if (!Array.isArray(routePoints) || !routePoints.length) {
          return null;
        }

        const valid = routePoints
          .map((point) => Number(point?.x))
          .filter((x) => Number.isFinite(x));

        if (!valid.length) {
          return null;
        }

        const sum = valid.reduce((total, x) => total + x, 0);
        return sum / valid.length;
      }

      function queueGradeBarOverlay({
        route = null,
        routePoints = [],
        color = '#ffde59',
        alpha = 1,
        medianGrade = null,
        baseHeight = DEFAULT_GRADE_BAR_BASE_HEIGHT,
        maxHeight = DEFAULT_GRADE_BAR_MAX_HEIGHT,
        width = DEFAULT_GRADE_BAR_WIDTH,
        transparency = DEFAULT_GRADE_BAR_TRANSPARENCY,
        isAscended = false,
      } = {}) {
        if (!Array.isArray(routePoints) || !routePoints.length) {
          return;
        }

        const averageX = calculateAverageXFromCanvasPoints(routePoints);
        if (!Number.isFinite(averageX)) {
          return;
        }

        const normalizedBaseHeight = normalizeGradeBarHeight(
          baseHeight,
          DEFAULT_GRADE_BAR_BASE_HEIGHT,
        );
        const normalizedMaxHeight = Math.max(
          normalizedBaseHeight,
          normalizeGradeBarHeight(maxHeight, DEFAULT_GRADE_BAR_MAX_HEIGHT),
        );
        const normalizedWidth = Math.min(
          Math.max(normalizeGradeBarWidth(width), MIN_GRADE_BAR_WIDTH),
          canvas.width,
        );
        const normalizedTransparency = normalizeGradeBarTransparency(transparency);
        const gradeValue =
          typeof medianGrade === 'number' && Number.isFinite(medianGrade)
            ? clamp(medianGrade, MIN_GRADE_VALUE, MAX_GRADE_VALUE)
            : null;
        const gradeRatio =
          gradeValue === null ? 0 : clamp(gradeValue / MAX_GRADE_VALUE, 0, 1);
        const targetHeight =
          gradeValue === null
            ? normalizedBaseHeight
            : normalizedBaseHeight +
              (normalizedMaxHeight - normalizedBaseHeight) * gradeRatio;
        const height = Math.min(
          Math.max(targetHeight, normalizedBaseHeight),
          normalizedMaxHeight,
        );
        const bottom = canvas.height;
        const top = Math.max(0, bottom - height);
        const resolvedAlpha = Math.max(
          0,
          Math.min(1, alpha * normalizedTransparency),
        );

        queuedGradeBarOverlays.push({
          route,
          desiredCenter: averageX,
          width: normalizedWidth,
          top,
          bottom,
          color,
          alpha: resolvedAlpha,
          gradeValue,
          isAscended: Boolean(gradeValue !== null && isAscended),
        });
      }

      function drawGradeBar(route, scaledPoints, strokeColor, alpha = 1) {
        if (!route || !Array.isArray(scaledPoints) || !scaledPoints.length) {
          return;
        }

        queueGradeBarOverlay({
          route,
          routePoints: scaledPoints,
          color: strokeColor,
          alpha,
          medianGrade: route.medianGrade,
          baseHeight: route.gradeBarBaseHeight,
          maxHeight: route.gradeBarMaxHeight,
          width: route.gradeBarWidth,
          transparency: route.gradeBarTransparency,
          isAscended: ascendedRoutes.has(route.id),
        });
      }

      function drawRoute(route, options = {}) {
        const strokeColor = getRouteStrokeColor(route);
        const points = Array.isArray(route.points) ? route.points : [];

        const alphaValue = Number(options.alpha);
        const routeAlpha = Number.isFinite(alphaValue)
          ? Math.min(Math.max(alphaValue, 0), 1)
          : 1;

        const omitOverlapKeys =
          options?.omitOverlappingPointKeys instanceof Set ? options.omitOverlappingPointKeys : null;
        const overlapGroups =
          options?.overlapGroups instanceof Map ? options.overlapGroups : null;
        const handledOverlapKeys =
          options?.handledOverlapKeys instanceof Set ? options.handledOverlapKeys : null;
        const routeAlphaMap =
          options?.routeAlphaMap instanceof Map ? options.routeAlphaMap : null;
        const isFocusedRoute = Boolean(options?.isFocused);

        if (!points.length) {
          return;
        }

        const pathType = normalizePathType(route.pathType);
        const supportsOverlapPattern =
          pathType === PATH_TYPE_POINT || pathType === PATH_TYPE_RECTANGLE;
        const shouldFilterOverlaps =
          omitOverlapKeys && omitOverlapKeys.size > 0 && supportsOverlapPattern;

        const gradeBarPoints = [];
        const visiblePoints = [];

        points.forEach((point) => {
          const normalizedX = Number(point?.x);
          const normalizedY = Number(point?.y);
          if (!Number.isFinite(normalizedX) || !Number.isFinite(normalizedY)) {
            return;
          }

          const scaledPoint = {
            x: normalizedX * canvas.width,
            y: normalizedY * canvas.height,
          };
          gradeBarPoints.push(scaledPoint);

          const pointKey = supportsOverlapPattern
            ? createNormalizedPointKey(normalizedX, normalizedY)
            : null;

          if (shouldFilterOverlaps && pointKey && omitOverlapKeys.has(pointKey)) {
            return;
          }

          const overlapKey =
            pointKey && overlapGroups ? createOverlapGroupKey(pathType, pointKey) : null;
          const overlapGroup =
            overlapKey && overlapGroups ? overlapGroups.get(overlapKey) : null;

          if (
            overlapGroup &&
            Array.isArray(overlapGroup.entries) &&
            overlapGroup.entries.length > 1 &&
            !isFocusedRoute
          ) {
            if (handledOverlapKeys && handledOverlapKeys.has(overlapKey)) {
              return;
            }

            const entriesWithAlpha = overlapGroup.entries.map((entry) => {
              const mappedAlpha = routeAlphaMap?.get(entry.routeId);
              const entryAlpha = Number.isFinite(mappedAlpha) ? mappedAlpha : 1;
              return { ...entry, alpha: entryAlpha };
            });

            if (handledOverlapKeys) {
              handledOverlapKeys.add(overlapKey);
            }

            if (pathType === PATH_TYPE_POINT) {
              drawOverlappingPointGroup(ctx, scaledPoint, entriesWithAlpha);
            } else if (pathType === PATH_TYPE_RECTANGLE) {
              drawOverlappingRectangleGroup(ctx, scaledPoint, entriesWithAlpha);
            }
            return;
          }

          visiblePoints.push(scaledPoint);
        });

        if (!gradeBarPoints.length) {
          return;
        }

        const pointDiameter = normalizePointDiameter(route.pointDiameter);
        const rectangleWidth = normalizeRectangleSize(route.rectangleWidth, DEFAULT_RECTANGLE_WIDTH);
        const rectangleHeight = normalizeRectangleSize(route.rectangleHeight, DEFAULT_RECTANGLE_HEIGHT);

        ctx.save();
        ctx.globalAlpha = routeAlpha;
        if (pathType === PATH_TYPE_POINT) {
          const circleRadius = Math.max(1, pointDiameter / 2);
          const strokeWidth = Math.max(2, Math.round(pointDiameter / 10));
          if (visiblePoints.length) {
            const path = new Path2D();

            visiblePoints.forEach((point) => {
              path.moveTo(point.x + circleRadius, point.y);
              path.arc(point.x, point.y, circleRadius, 0, Math.PI * 2);
            });

            ctx.save();
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke(path);
            ctx.restore();
          }
        } else if (pathType === PATH_TYPE_RECTANGLE) {
          const rectWidth = Math.max(1, rectangleWidth);
          const rectHeight = Math.max(1, rectangleHeight);
          const halfWidth = Math.max(1, rectWidth / 2);
          const halfHeight = Math.max(1, rectHeight / 2);
          const strokeWidth = Math.max(2, Math.round(Math.max(rectWidth, rectHeight) / 10));
          if (visiblePoints.length) {
            const path = new Path2D();

            visiblePoints.forEach((point) => {
              path.rect(point.x - halfWidth, point.y - halfHeight, rectWidth, rectHeight);
            });

            ctx.save();
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke(path);
            ctx.restore();
          }
        } else if (gradeBarPoints.length >= 2) {
          const path = new Path2D();
          path.moveTo(gradeBarPoints[0].x, gradeBarPoints[0].y);

          for (let i = 0; i < gradeBarPoints.length - 1; i++) {
            const p0 = i === 0 ? gradeBarPoints[0] : gradeBarPoints[i - 1];
            const p1 = gradeBarPoints[i];
            const p2 = gradeBarPoints[i + 1];
            const p3 = i + 2 < gradeBarPoints.length ? gradeBarPoints[i + 2] : gradeBarPoints[i + 1];

            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;

            path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
          }

          ctx.save();
          ctx.lineWidth = 10;
          ctx.strokeStyle = strokeColor;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.stroke(path);
          ctx.restore();
        }
        ctx.restore();

        drawGradeBar(route, gradeBarPoints, strokeColor, routeAlpha);
      }

      function renderQueuedGradeBarOverlays() {
        if (!Array.isArray(queuedGradeBarOverlays) || !queuedGradeBarOverlays.length) {
          queuedGradeBarOverlays = [];
          return;
        }

        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        if (canvasWidth <= 0 || canvasHeight <= 0) {
          queuedGradeBarOverlays = [];
          return;
        }

        const centerX = canvasWidth / 2;
        const entries = queuedGradeBarOverlays
          .map((entry, index) => {
            const width = Math.max(1, Math.min(Number(entry?.width) || 0, canvasWidth));
            if (!Number.isFinite(width) || width <= 0) {
              return null;
            }

            const desiredCenter = Number(entry?.desiredCenter);
            if (!Number.isFinite(desiredCenter)) {
              return null;
            }

            const halfWidth = width / 2;
            const clampedCenter = clamp(
              desiredCenter,
              halfWidth,
              Math.max(halfWidth, canvasWidth - halfWidth),
            );

            return {
              index,
              original: entry,
              width,
              halfWidth,
              clampedCenter,
            };
          })
          .filter(Boolean);

        if (!entries.length) {
          queuedGradeBarOverlays = [];
          return;
        }

        const leftEntries = entries
          .filter((entry) => entry.clampedCenter <= centerX)
          .sort((a, b) => b.clampedCenter - a.clampedCenter);
        const rightEntries = entries
          .filter((entry) => entry.clampedCenter > centerX)
          .sort((a, b) => a.clampedCenter - b.clampedCenter);

        const placements = new Map();

        let leftBoundary = centerX;
        for (const entry of leftEntries) {
          let rightEdge = Math.min(leftBoundary, entry.clampedCenter + entry.halfWidth);
          let leftEdge = rightEdge - entry.width;

          if (leftEdge < 0) {
            leftEdge = 0;
            rightEdge = entry.width;
          }

          if (rightEdge > leftBoundary) {
            rightEdge = leftBoundary;
            leftEdge = rightEdge - entry.width;
            if (leftEdge < 0) {
              leftEdge = 0;
              rightEdge = entry.width;
            }
          }

          leftBoundary = Math.max(0, leftEdge);
          placements.set(entry.index, {
            ...entry,
            left: leftEdge,
            right: rightEdge,
          });
        }

        let rightBoundary = centerX;
        for (const entry of rightEntries) {
          let leftEdge = Math.max(rightBoundary, entry.clampedCenter - entry.halfWidth);
          let rightEdge = leftEdge + entry.width;

          if (rightEdge > canvasWidth) {
            rightEdge = canvasWidth;
            leftEdge = rightEdge - entry.width;
          }

          if (leftEdge < rightBoundary) {
            leftEdge = rightBoundary;
            rightEdge = leftEdge + entry.width;
            if (rightEdge > canvasWidth) {
              rightEdge = canvasWidth;
              leftEdge = rightEdge - entry.width;
            }
          }

          rightBoundary = Math.min(canvasWidth, rightEdge);
          placements.set(entry.index, {
            ...entry,
            left: leftEdge,
            right: rightEdge,
          });
        }

        const nextGradeBarEntries = [];

        for (let i = 0; i < queuedGradeBarOverlays.length; i += 1) {
          const placement = placements.get(i);
          if (!placement) {
            continue;
          }

          const { original, left, right } = placement;
          const actualLeft = Math.max(0, Math.min(canvasWidth, left));
          const actualRight = Math.max(actualLeft, Math.min(canvasWidth, right));
          const actualWidth = Math.max(1, actualRight - actualLeft);
          const actualTop = Math.max(0, Math.min(canvasHeight, original.top));
          const actualBottom = Math.max(actualTop, Math.min(canvasHeight, original.bottom));
          const height = Math.max(0, actualBottom - actualTop);
          if (height <= 0) {
            continue;
          }

          ctx.save();
          ctx.globalAlpha = original.alpha;

          const strokeWidth = Math.max(2, Math.round(actualWidth * 0.18));
          ctx.lineWidth = strokeWidth;
          ctx.lineJoin = 'miter';
          ctx.lineCap = 'butt';
          ctx.strokeStyle = original.color;

          if (original.gradeValue === null) {
            const dashLength = Math.max(4, actualWidth * 0.6);
            ctx.setLineDash([dashLength, dashLength]);
          } else {
            ctx.setLineDash([]);
          }

          if (original.isAscended) {
            ctx.fillStyle = original.color;
            ctx.fillRect(actualLeft, actualTop, actualWidth, height);
          }

          const halfStroke = strokeWidth / 2;
          const insetLeft = actualLeft + halfStroke;
          const insetTop = actualTop + halfStroke;
          const insetWidth = Math.max(1, actualWidth - strokeWidth);
          const insetHeight = Math.max(1, height - strokeWidth);

          ctx.strokeRect(insetLeft, insetTop, insetWidth, insetHeight);
          ctx.restore();

          nextGradeBarEntries.push({
            route: original.route,
            x: actualLeft + actualWidth / 2,
            left: actualLeft,
            right: actualRight,
            top: actualTop,
            bottom: actualTop + height,
            width: actualWidth,
            height,
          });
        }

        gradeBarEntries = nextGradeBarEntries;
        queuedGradeBarOverlays = [];
      }

      function handlePointerMove(event) {
        if ('pointerType' in event) {
          const pointerType = event.pointerType;
          if (pointerType && pointerType !== 'mouse' && pointerType !== 'pen') {
            canvas.style.cursor = '';
            return;
          }
        }

        const entry = getGradeBarEntryAtClientPoint(event.clientX, event.clientY);

        if (entry) {
          canvas.style.cursor = 'pointer';
        } else {
          canvas.style.cursor = '';
          if (!pinnedRouteId) {
            hideTooltip();
          }
        }
      }

      function handlePointerLeave() {
        canvas.style.cursor = '';
        if (!pinnedRouteId) {
          hideTooltip();
        }
      }

      function handleCanvasPointerDown(event) {
        const point = extractClientPoint(event);
        if (!point) {
          return;
        }

        const entry = getGradeBarEntryAtClientPoint(point.x, point.y);

        if (entry) {
          const rect = canvas.getBoundingClientRect();
          const tooltipX = rect.left + entry.x;
          const tooltipY = rect.top + entry.top;
          showTooltip(entry.route, tooltipX, tooltipY, { pin: true });
        } else {
          hideTooltip({ force: true });
        }
      }

      function handleDocumentPointerDown(event) {
        if (!tooltip) {
          return;
        }

        if (event.target === canvas) {
          return;
        }

        if (tooltip.contains(event.target)) {
          return;
        }

        hideTooltip({ force: true });
      }

      if ('PointerEvent' in window) {
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerleave', handlePointerLeave);
        canvas.addEventListener('pointerdown', handleCanvasPointerDown);
        document.addEventListener('pointerdown', handleDocumentPointerDown);
      } else {
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseleave', handlePointerLeave);
        canvas.addEventListener('mousedown', handleCanvasPointerDown);
        canvas.addEventListener('touchstart', handleCanvasPointerDown);
        document.addEventListener('mousedown', handleDocumentPointerDown);
        document.addEventListener('touchstart', handleDocumentPointerDown);
      }

      if (resetZoomButton) {
        resetZoomButton.addEventListener('click', () => {
          resetCanvasZoom();
        });
      }

      window.addEventListener('resize', resizeCanvas);

      if (backgroundImage.complete) {
        backgroundReady = true;
        if (backgroundImage.naturalWidth > 0 && backgroundImage.naturalHeight > 0) {
          const ratio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
          if (Number.isFinite(ratio) && ratio > 0) {
            canvasAspectRatio = ratio;
          }
        }
        resizeCanvas();
      } else {
        resizeCanvas();
      }
    </script>
  </body>
</html>
